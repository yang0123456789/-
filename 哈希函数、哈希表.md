![image-20220121094438997](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121094438997.png)



对于hash结构，如果是自定义的类的实例作为key则传递的是内存的地址，只占了八个字节，如果是string或者基本数据类型比如int 、char这种，则是值传递。比如string的长度特别长，key就是深拷贝，栈的内存也就响应的非常的长。



# 位运算

## ^运算符理解

- ^ 可理解为不进位相加

- a^a=0

- a^0=a

  ```
  public static void sway(int[] arr,int i,int j){
  	if(i!=j){
  		//不能两个值指向同一地址
  	    arr[i]=arr[i]^arr[j];
  	    arr[j]=arr[i]^arr[j];//就是arr[i]^arr[j]^arr[j]就表示a
  	    arr[i]=arr[i]^arr[j];//表示arr[i]^arr[j]^arr[i]^arr[j]^arr[j]就是b
      }
  }
  
  ```

  ## 寻找出现双中的单数

  题目：一组数只有一个数出现一次，其他出现两次，找出这个出现一次的数

```
public class Main {
	private static int process(int[] arr) {
		int res = 0;
		for (int i : arr) {
			res ^= i;
		}
		return res;
	}
}

```

## 取出一个数最右边1的位置



```
int mostRightOne = pos & (~pos + 1); 
// mostRightOne值在二进制位上的位次就是pos得最右第一个1的位置

```

60 = 0011 1**1**00

-61 = 1100 0011

-60+1 = 1100 0100

60&(-60+1)=0000 0**1**00
得出答案



下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

```
public class Test {
  public static void main(String[] args) {
     int a = 60; /* 60 = 0011 1100 */ 
     int b = 13; /* 13 = 0000 1101 */
     int c = 0;
     c = a & b;       /* 12 = 0000 1100 */
     System.out.println("a & b = " + c );
 
     c = a | b;       /* 61 = 0011 1101 */
     System.out.println("a | b = " + c );
 
     c = a ^ b;       /* 49 = 0011 0001 */
     System.out.println("a ^ b = " + c );
 
     c = ~a;          /*-61 = 1100 0011 */
     System.out.println("~a = " + c );
 
     c = a << 2;     /* 240 = 1111 0000 */
     System.out.println("a << 2 = " + c );
 
     c = a >> 2;     /* 15 = 1111 */
     System.out.println("a >> 2  = " + c );
  
     c = a >>> 2;     /* 15 = 0000 1111 */
     System.out.println("a >>> 2 = " + c );
  }
} 
```

以上实例编译运行结果如下：

```
a & b = 12
a | b = 61
a ^ b = 49
~a = -61
a << 2 = 240
a >> 2  = 15
a >>> 2 = 15
```

### [java运算符 与（&）、非（~）、或（|）、异或（^）](https://www.cnblogs.com/jpfss/p/11014780.html)

1.十进制转二进制

原理：给定的数循环除以2，直到商为0或者1为止。将每一步除的结果的余数记录下来，然后反过来就得到相应的二进制了。

比如8转二进制，第一次除以2等于4（余数0），第二次除以2等于2（余数0），第三次除以2等于1（余数0），最后余数1，得到的余数依次是0 0 0 1 ，

反过来就是1000，计算机内部表示数的字节长度是固定的，比如8位，16位，32位。所以在高位补齐，java中字节码是8位的，所以高位补齐就是00001000.

写法位（8）10=（00001000）2；

```
package sourceCode.hashMap;

public class mapHashCodeTest {
    public static void main(String[] args) {
        String str = toBinary(8);
        System.out.println(str);
    }

    static String toBinary(int num) {
        String str = "";
        while (num != 0) {
            str = num % 2 + str;
            num = num / 2;
        }
        return str;
    }

}
```

运行结果：1000

2.二进制转十进制

计算也很简单，比如8的二进制表示位00001000，去掉补齐的高位就是1000.此时从个位开始计算2的幂（个位是0，依次往后推）乘以对应位数上的数，然后得到的值想加

于是有了，（2的0次幂）*0+（2的1次幂）*0+（2的2次幂）*0+（2的3次幂）*1 = 8

代码实现，直接调用Integer.parseInt("",2);

```
1 System.out.println(Integer.parseInt("1000",2));
```

运行结果：8

3.位异或运算（^）

运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。

比如：8^11.

8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是Integer.parseInt("0011",2)=3;

 

延伸：

4.位与运算符（&）

运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。

比如：129&128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.

 

5.位或运算符（|）

运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。

比如：129|128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.

 

**6.位非运算符（~）**

运算规则：如果位为0，结果是1，如果位为1，结果是0.

比如：~37

在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.

8转为二进制是100101.

补码后为： 00000000 00000000 00000000 00100101

取反为：  11111111 11111111 11111111 11011010

因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。

因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：

00000000 00000000 00000000 00100110，此时二进制转原码为38

所以~37 = -38. 



## 找所有双出现中的两个单数

题目：一组数只有两个数出现一次，其他出现两次，找出这两个数：

- 因为两个值不同，所以两个值定存在二进制某一位定不同，用这两个值的异或结果二进制中的1，从而将数字分成两组，该位为1和不为1

```java
public class Main {
	private static void process(int[] arr) {
		int med = 0;
		for (int a : arr) {
			med ^= a;// 两个不同的单数^最后得到med
		}
		int rightOne = med & (~med + 1);// 取出med中二进制为1的位值（必存在，因为不同值）
		int med1 = 0;
		for (int a : arr) {
			// 对应位为1的值取出进行^最后的到两个单数对应位为1的
			// (a&rightOne)== 0得到对应位为0
			if ((a & rightOne) == rightOne) {
				med1 ^= a;
			}
		}
		System.out.println(med1);// 两个单数其中一个值
		System.out.println(med ^ med1);// 两个单数令一个值
	}
}

```

## 整数二进制奇数位偶数位交换

题目 : 例如：010110—>101001

```
public class Main {
	private static int process(int pos) {
		int pre = 0xAAAAAAAA; // 1010 1010 1010 1010 1010 1010 1010 1010 
		int post = 0x55555555; // 0101 0101 0101 0101 0101 0101 0101 0101 
		pre &= pos;
		post &= pos;
		pre >>= 1;
		post <<= 1;
		return pos + post;
	}
}

```



## 数组中全部出现k次返回出现一次的数

题目：给定一个整数数组，只有一个数出现了一次，其他数字均出现了三次，输出这一个只出现一次的数。

- 只看出现三次到数字，那么对于这些值的二进制位的累加和定能被3整除。
- 现在出现了一个只出现一次的数，由于该数的存在，所有二进制位累加和除以3的余数就是该值的对应二进制位数。
- 除了3，主要是大于等于2都可以这样做。

```
public class Main {
	public static int twoSingleNum(int[] arr) {
		int[] bit = new int[32];// 每一位求和
		for (int a : arr) {
			int b = 1;
			for (int i = 31; i >= 0; --i) {
				if ((a & b) != 0) {// 为1就累加
					++bit[i];
				}
				b <<= 1;// 换位
			}
		}
		int res = 0;
		for (int i = 0; i < 32; ++i) {
			res = res << 1;
			res += (bit[i] % 3);// 取余数
		}
		return res;
	}
}

```





# 链表

## 判读链表元素是否回文

### 利用栈结构

- 先遍历后全部入栈，然后再遍历和栈中元素依次比较。

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Stack<Node> stack = new Stack<>();
		Node tail = header;
		while (tail != null) {
			stack.push(tail);
			tail = tail.next;
		}
		tail = header;
		while (tail != null) {
			if (stack.pop().value != tail.value) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```

### 利用栈结构和快慢指针

- 先用快慢指针定位中间位置，然后继续运动慢指针依次和栈中元素进行比较。需要注意链表整体的个数是双是单。

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Node slow = header;
		Node quick = header;
		Stack<Node> stack = new Stack<>();
		while (quick.next != null && quick.next.next != null) {
			stack.push(slow);
			slow = slow.next;
			quick = quick.next.next;
		}
		// 此时若整个链表为双数，slow指向上一半的最后一个，需要入栈slow
		// 若为单数，指向中间元素，不需要入栈slow
		// 单双数的判断由quick的终止条件确定
		if (quick.next!=null) {
			stack.push(slow);
		}
		slow = slow.next;
		while (!stack.isEmpty()) {
			if (slow.value != stack.pop().value) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```



### 快慢指针和链表反向

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Node slow = header;
		Node quick = header;
		while (quick.next != null && quick.next.next != null) {
			slow = slow.next;
			quick = quick.next.next;
		}
		slow=slow.next;
		Node preNode=null;
		Node postNode=null;
		// 后半段反转
		while (slow!=null) {
			preNode=slow.next;
			slow.next=postNode;
			postNode=slow;
			slow=preNode;
		}
		Node tailLeft=header;
		Node tailRight=postNode;
		boolean flag=true;
		// 两边向中间判断
		while (tailRight!=null) {
			if (tailLeft.value!=tailRight.value) {
				flag=false;
				break;
			}
			tailLeft=tailLeft.next;
			tailRight=tailRight.next;
		}
		Node tailNode=null;
		// 后半段链表恢复
		while (postNode!=null) {
			preNode=postNode.next;
			postNode.next=tailNode;
			tailNode=postNode;
			postNode=preNode;
		}
		return flag;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```







空间复杂度为o(1)
快慢指针,从终点开始，将后半段翻转，然后用头尾节点遍历开始比对

```
node node1 = head;
node node2 = head;
while(node2.next!=null&&node2.next.next!=null){
  node1=node1.next;
  node2=node2.next.next;
}

```

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142095356-102e2456-154b-4a69-8741-8297cc0df337.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142095813-184c2d8a-b460-4225-94a6-03832ea7fa52.png)



## 三分链表

给定一个值，将比该值小的节点放左边，大的放右边

借助六个变量。分别是小于基准节点的子链表头尾节点、大于的头尾、等于的头尾。然后合并小于和等于的部分。然后分别对两个子链表递归执行以上操作。返回以后就合并两个子链表。基本跟快拍的操作一致。

- 该题并不是思维上难点，主要是注意边界条件

```java
class SEL{
    public static Node sEL(Node header,int pivot){
        Node head_1=null;
        Node tail_1=null;
        Node head_2=null;
        Node tail_2=null;
        Node head_3=null;
        Node tail_3=null;
        Node nextNode=null;
        while (header!=null){
            nextNode=header.next;
            header.next=null;
            if (header.num<pivot){
                if (head_1==null){
                    head_1=header;
                    tail_1=header;
                }else { 
                    tail_1.next=header;
                    tail_1=tail_1.next;
                }
            }else if (header.num==pivot){
                if (head_2==null){
                    head_2=header;
                    tail_2=header;
                }else {
                    tail_2.next=header;
                    tail_2=tail_2.next;
                }
            }else {
                if (head_3==null){
                    head_3=header;
                    tail_3=header;
                }else {
                    tail_3.next=header;
                    tail_3=tail_3.next;
                }
            }
            header=nextNode;
        }
        if (tail_1==null){
            if (tail_2==null){
                return head_3;
            }else {
                tail_2.next=head_3;
                return head_2;
            }
        }else {
            if (tail_2==null){
                tail_1.next=head_3;
            }else {
                tail_1.next=head_2;
                tail_2.next=head_3;
            }
            return head_1;
        }
    }
	public static class Node {
		int value;
		Node next;
	}
}

```







## 用快排的思想实现单链表的排序



## 复制带rand指针的单链表，要求空间复杂度01





![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204359-3b6bd820-aa26-421d-8915-1c57cb0e0c44.png)

将复制的节点直接连在原来节点的后面，然后执行复制节点的rand节点的指向操作。然后去掉老节点就是新的复制的链表，
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204315-a050c13c-f9b3-4507-b91d-96454758b0c9.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142203370-5b7792a7-ff35-498e-8c26-ffbb7177ca83.png)



## 判断单链表是否有环

判断链表是否有环，若有返回第一个入环节点

流程：一开始快慢指针都在开始节点处。快指针走两步，慢指针走一步。然后一直走。如果相遇，快指针回到开始节点处，开始走一步，慢指针也走一步，下一次相遇的时候就是环的入口。

慢:1 快:2
若慢:1快3：
都入环时相差奇数步，且环节点数量为偶数则永不相交,都入环时相差奇数步说明每次差值减少2步，定在第一轮反超，此时差 环节点个数-1，若该值仍为奇数，那么第二轮也反超，故永不相遇

流程：一开始快慢指针都在开始节点处。快指针走两步，慢指针走一步。然后一直走。如果相遇，快指针回到开始节点处，开始走一步，慢指针也走一步，下一次相遇的时候就是环的入口。
 通过计算a和b走的位置可以推导出来。

```
    private static Node hasCircle(Node header){
        if (header==null)return null;
        boolean flag=false;
        Node slow=header;
        Node quick=header;
        //
        // 有环肯定会相遇
        while (quick.next!=null&&quick.next.next!=null){
            slow=slow.next;
            quick=quick.next.next;
            if (slow==quick){//判断是否却有环
                flag=true;
                break;
            }
        }
        if (!flag)return null;
        quick=header;
        while (quick!=slow){//相遇时将其中一个指针指向header走相同的步数定在入环节点相遇
            quick=quick.next;
            slow=slow.next;
        }
        return quick;
    }
```





## 链表环问题	







 ![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142207642-041fc64c-815b-4c76-9b94-c4006bf3a1fc.png)










## 两个单链表相交的问题

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204613-79d522e5-27e2-4b7d-8835-b3b9a72f6109.png)

1.先根据上面的方法判断两个链表有没有环。
2如果两个链表都没有环的话，则说明两个单链表要么没有相交，要么尾部的一小段是公共部分。
 这个时候就分别遍历两个链表，记录长度和尾结点，看一下尾结点的内存地址是不是同一个，如果不是同一个，则肯定不想交。
 如果是同一个，就根据两个链表的长度，长的先走到剩余长度一致的节点，然后一起遍历，直到找到内存地址一样的节点，这个就是相交部分第一个节点。

3.如果一个有环一个无环，则不可能相交的。
4.如果两个都有环：
  ![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142335167-abff9244-c9d5-4aac-9c56-c5a22e371a70.png)
  通过上面的方法我们可以拿到两个环的入环位置。如果相等，则变成了2的方法找相交部分。
  如果不相等，就要区分一下图中1和3两种情况：
 让loop1继续往下走，直到转了一圈。
     - 如果能遇到loop2就是3的情况，相交，返回loop1或者loop2都可以，都算相交的节点。
          - 如果遇不到loop2就是1的情况。 不想交


![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142336010-5d834c73-3d6a-476f-808f-f1582a387e9c.png)







```java
class List{
    /*
    有环：
            1.同环：
                - 入环节点相同  返回相交节点
                - 入环节点不同  返回其中一个入环节点
            2.不同环：
                - 返回null
     无环：
            1.相交：
                - 返回相交节点
            2.不相交：
                - 返回null
     */
    public static Node getIntersectNode(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node loop1 = hasCircle(head1);
        Node loop2 = hasCircle(head2);
        if (loop1 == null && loop2 == null) {
            return noLoop(head1, head2);//无环，判断是否为链式相交或不相交
        }
        if (loop1 != null && loop2 != null) {
            return bothLoop(head1, loop1, head2, loop2);//有环，返回相交节点
        }
        return null;//一有环，一无环必定不相交
    }


    private static Node hasCircle(Node header){
        if (header==null)return null;
        boolean flag=false;
        Node slow=header;
        Node quick=header;
        while (quick.next!=null&&quick.next.next!=null){
            slow=slow.next;
            quick=quick.next.next;
            if (slow==quick){//判断是否却有环
                flag=true;
                break;
            }
        }
        if (!flag)return null;
        quick=header;
        while (quick!=slow){//相遇时将其中一个指针指向header走相同的步数定在入环节点相遇
            quick=quick.next;
            slow=slow.next;
        }
        return quick;
    }

    private static Node noLoop(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;
        //计算链表差值
        while (cur1.next != null) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2.next != null) {
            n--;
            cur2 = cur2.next;
        }
        if (cur1 != cur2) {
            return null;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        //长的走到和短的长度同位置
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        //判断是否有相同节点，若无就会走到最后返回null
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }

    private static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
        Node cur1 = null;
        Node cur2 = null;
        if (loop1 == loop2) {
            cur1 = head1;
            cur2 = head2;
            int n = 0;
            while (cur1 != loop1) {
                n++;
                cur1 = cur1.next;
            }
            while (cur2 != loop2) {
                n--;
                cur2 = cur2.next;
            }
            cur1 = n > 0 ? head1 : head2;
            cur2 = cur1 == head1 ? head2 : head1;
            n = Math.abs(n);
            while (n != 0) {
                n--;
                cur1 = cur1.next;
            }
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            return cur1;
        } else {
            cur1 = loop1.next;
            while (cur1 != loop1) {
                if (cur1 == loop2) {
                    return loop1;//环内相交
                }
                cur1 = cur1.next;
            }
            return null;//两个有环链表环不是同一个
        }
    }
    public class Node{
	    int value;
	    Node next;
	}
}

```





### 

# 二叉树

## 一套拳法👊刷掉n个遍历树的问题

https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen-5/



## 递归遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142337278-120e5275-fd69-415a-8cc1-31a7a2dcb965.png)

## 非递归遍历

自己进行压栈的操作。

### 先序遍历：

- 新建一个stack
- 1.先放入头结点，
  2 再弹一个出来头结点。
  栈弹出一个头节点弹出，然后打印，然后右节点加入栈中，左节点加入栈中。周而复始直到栈中元素为空。
  注意先压右节点再压左节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142418160-c72f1041-1001-4b4b-9d8a-830208e8a8d0.png)

### 中序遍历


左子树一溜烟儿进栈，相当于找到最左子节点，然后弹出，打印。然后右节点进栈，右节点的左子节点跟着一溜烟儿进栈。然后返回开始周而复始。直到栈中元素为空。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142419929-989b9ca9-3c3c-49d7-8a69-b9ece28decd9.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142420645-4a4cd13f-3eed-4925-9534-616ff213b190.png)

```java
class Solution {
     List<Integer> lists=new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
      
      Stack<TreeNode> st=new Stack<>();
      if(root==null) return lists;
      while(root!=null||!st.isEmpty()){
          while(root!=null){
              st.push(root);
              root=root.left;
          }
          root=st.pop();
          lists.add(root.val);
          root=root.right;
      }
    return lists;
    }
}
```







### 后续遍历

借助一个辅助的栈，按照先序遍历的方法压栈，改成弹出一个节点以后放入到辅助栈中，然后先压右边再压左边子节点的思路。最后压栈为空的时候，挨个弹出辅助栈，就成了后续遍历了。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142418738-d23990ea-809d-4c7c-8846-88d565339640.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142419498-75ea6f21-e8d5-4138-b107-4ee68a101585.png)



```
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
          if (root == null){
              return res;
          }
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        s1.push(root);
        while(!s1.isEmpty()){
        root = s1.pop();
        s2.push(root);
        if(root.left!=null){
             s1.add(root.left);
        }
            if(root.right!=null){
            s1.add(root.right);
        }   
        }
        while(!s2.isEmpty()){
            res.add(s2.pop().val);
        }
        return res;

    }
}
```



```
public class Main {
	public static void postOrder(Node header) {
		if (header == null) {
			return;
		}
		Stack<Node> stack = new Stack<>();
		Stack<Node> postStack = new Stack<>();
		stack.push(header);
		while (!stack.isEmpty()) {
			// 先右后左的先序遍历的反向就是先左后右的后序遍历
			Node popNode = stack.pop();
			postStack.push(popNode);
			if (popNode.leftNode != null) {
				stack.push(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				stack.push(popNode.rightNode);
			}
		}
		while (!postStack.isEmpty()) {
			System.out.println(postStack.pop().value);
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



方法2

```
public class Main {
	public static void postOrder(Node header) {
		if (header == null) {
			return;
		}
		Stack<Node> stack = new Stack<Node>();
		stack.push(header);
		Node tail = null;
		while (!stack.isEmpty()) {
			tail = stack.peek();
			if (tail.leftNode != null && header != tail.leftNode && header != tail.rightNode) {
				stack.push(tail.leftNode);
			} else if (tail.rightNode != null && header != tail.rightNode) {
				stack.push(tail.rightNode);
			} else {
				System.out.print(stack.pop().value + " ");
				header = tail;
			}
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



### 层次遍历



```java
public class Main {
	public static void wedthOrder(Node header) {
		if (header == null) {
			return;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		deque.add(header);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			System.out.println(popNode.value);
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
			}
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 求二叉树的宽度

层次遍历，统计栈的长度。
或者搞一个队列，搞一个hashmap，key为node，value为层数。然后按照层次遍历，统计每一层的数量。
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142424040-fe0736b0-dda3-4f43-b2da-d90960f143b3.png)

如果就是用一个队列的话，可以搞两个变量，一个记录当前层最后一个node，一个记录下一层最后一个node。当前遍历的节点不是当前层最后一个node，在将左右孩子加入到队列的时候，就更新下一层最后一个node。如果等于当前层最后一个node，则将左右孩子入队列以后，当前最后一个node指向下一层最后一个node，下一层最后一个node志为空。同时在这个过程中记录节点的个数，更新最大宽度。

- 这里对于每层来说就是一个层次，所以显然就是基于横向遍历。
- 在横向遍历时我们要随机记录每个节点所在层数，以便判断该层是否已经结束，进入了下一层。有两种方式进行层数的记录：
  - map空间记录，比较耗空间
  - 用指针记录每一层结束节点的位置

**map实现**

```
public class Main {
	public static int floorMaxNodeNum(Node header) {
		if (header == null) {
			return 0;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		int thisFloorNum = 0;// 该层节点个数记录
		int thisFloor = 1;// 这是第几层
		int max = Integer.MIN_VALUE;
		HashMap<Node, Integer> map = new HashMap<>();
		deque.add(header);
		map.put(header, thisFloor);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			if (map.get(popNode) == thisFloor) {// 若是该层元素
				++thisFloorNum;
			} else {// 若已经进入下一层中的节点
				max = Math.max(max, thisFloorNum);
				++thisFloor;
				thisFloorNum = 1;
			}
			// 每次添加都要在map中记录节点层数
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
				map.put(popNode.leftNode, thisFloor + 1);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
				map.put(popNode.rightNode, thisFloor + 1);
			}
		}
		// 这一这里还是取最大值，最后一层没有和max比较过
		return Math.max(max, thisFloorNum);
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



**指针实现**

```
public class Main {
	public static int floorMaxNodeNum(Node header) {
		if (header == null) {
			return 0;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		int thisFloorNum = 0;// 该层节点个数记录
		int max = Integer.MIN_VALUE;
		Node thisFloorLastNode = header;// 该层最后一个节点，只能继承nextFloorLastNode
		Node nextFloorLastNode = null;// 下一层最后一个节点，用于更新thisFloorLastNode
		deque.add(header);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			thisFloorNum++;
			// 入队就要更新nextFloorLastNode
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
				nextFloorLastNode = popNode.leftNode;
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
				nextFloorLastNode = popNode.rightNode;
			}
			// 若该层结束
			if (popNode == thisFloorLastNode) {
				max = Math.max(max, thisFloorNum);
				thisFloorLastNode = nextFloorLastNode;
				nextFloorLastNode = null;
				thisFloorNum = 0;
			}
		}
		return max;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 看一个二叉树是不是搜索二叉树

https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/

中序遍历是升序的就是搜索二叉树。设置一个全局变量，表示上一个遍历的节点的值，如果当前节点是空，返回TRUE。递归左子树。如果左子树返回FALSE，就返回FALSE，如果左子树返回TRUE，看当前节点的值是否大于全局变量，如果小于，则返回FALSE。如果大于，设置全局变量为当前节点的值，递归右子树，看右子树是不是。

**中序遍历实现**

![image-20220311225822382](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220311225822382.png)

### 递归实现

```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean isValidBST(TreeNode node, long lower, long upper) {
        if (node == null) {
            return true;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        return isValidBST(node.left, lower, node.val) && isValidBST(node.right, node.val, upper);
    }
}
```





```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return pastOrder(root).valid;
    }
    public Tem pastOrder(TreeNode root){
        if(root==null){
            return new Tem(Long.MIN_VALUE,Long.MAX_VALUE, true);
        }
        Tem leftData=pastOrder(root.left);
        Tem rightData = pastOrder(root.right);
       boolean flag =leftData.valid&&rightData.valid &&leftData.maxV < root.val && rightData.minV > root.val;
		return new Tem( Math.max(rightData.maxV, root.val), Math.min(leftData.minV,root.val),flag);
    }
    public static class Tem{
        long maxV;
        long minV;
        boolean valid;
        Tem(long maxV, long minV, boolean valid) {
         this.maxV = maxV;
          this.minV = minV;
         this.valid = valid;
    }
    }
}
```



### 中序遍历实现



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public static long preValue = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        preValue = Long.MIN_VALUE;
          if (root==null){
            return true;
        }
        if(root.left==null&&root.right==null){
            return true;
        }
       return help(root);
    }
     public boolean help(TreeNode root) {
        if (root==null){
            return true;
        }
        if(root.left!=null){
            if(!help(root.left)){
                 System.out.println(3);
                return false;
            }
        }
 
        if(preValue>=root.val){
            System.out.println(preValue);
            System.out.println(1);
            return false;
        }
        preValue = root.val;
        if(root.right!=null){
            if(!help(root.right)){
                System.out.println(2);
                return false;
            }
        }
        return true;
    }
}
```



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        double inorder = -Double.MAX_VALUE;

        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
              // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root.val <= inorder) {
                return false;
            }
            inorder = root.val;
            root = root.right;
        }
        return true;
    }
}


```




## 判断一颗二叉树是否是完全二叉树

二叉树按宽度来遍历，如果有右子树没有左子树，直接返回FALSE
如果有一个孩子左右两个孩子不双全，则下一层所有的节点都应该是叶子节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142552913-816c0a18-a18a-4709-b68c-8fbcc35c3acc.png)





```java
public class Main {
	public static boolean isBST(Node header) {
		if (header == null) {
			return true;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		deque.add(header);
		boolean flag = false;
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			if ((popNode.leftNode == null && popNode.rightNode != null)// 左无节点有右节点定不是完全二叉树
					|| (flag && (popNode.leftNode != null || popNode.rightNode != null))) {// 标记后左右存在节点
				return false;
			}
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
			}
			// 此后不该有子节点，应该放在最后判断，因为判断结果flag不能对此次结果有影响
			// 去掉popNode.leftNode == null不影响
			if (popNode.leftNode == null || popNode.rightNode == null) {
				flag = true;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 判断一个树是不是平衡二叉树

左右子树高度差不超过1，每个节点都适用

https://leetcode-cn.com/problems/balanced-binary-tree/



套路是开始条件+最终放回值+左右信息递归



![image-20220312003552669](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220312003552669.png)



```
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = isAVLTree(header);
		return data.isAVL;
	}

	private static TransformData isAVLTree(Node header) {
		if (header == null) {
			return new TransformData(true, 0);
		}
		TransformData lData = isAVLTree(header.leftNode);
		TransformData rData = isAVLTree(header.rightNode);
		return new TransformData(lData.isAVL && rData.isAVL && Math.abs(lData.height - rData.height) <= 1,
				Math.max(lData.height, rData.height) + 1);

	}

	public static class TransformData {
		boolean isAVL;
		int height;
		public TransformData(boolean flag, int h) {
			this.isAVL = flag;
			this.height = h;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root==null){
            return true;
        }
        return height(root)>=0;
    } 
     public int height(TreeNode root){
        if(root==null) return 0;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if(leftHeight ==-1||rightHeight == -1|| Math.abs(leftHeight-rightHeight)>1){
            return -1;
        }else{
            return Math.max(leftHeight,rightHeight)+1;
        }
     }

}
```



## 判断一个树是不是满二叉树

思路是看一下这个树的节点的总数是不是高度的二的次方加一。
子节点返回自己的高度和节点的个数。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142629204-75121bf2-53ad-41ee-a030-8f2e1847ef90.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142629079-02ef35ea-496f-40a4-9fcd-22d237a8dc95.png)

## 求两个节点的最近公共祖先

https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/



### 借助hashmap

方法一：遍历所有的节点，然后将每个节点的子节点作为hashmap的key，自己作为v放入一个hashmap中。然后从给定的节点开始查hashmap，相当于把根节点到自己的路径放入到一个set中。第二个节点用同样的方法找父节点的链路，每次都看在不在上个节点的set中，在的话就是最近的公共父节点，直接返回。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        HashMap<TreeNode, TreeNode> map = new HashMap<>();
        process(root,map);
        HashSet<TreeNode> set = new HashSet<>();
        while(p!=null){
            set.add(p);
            p = map.get(p);
        }
        while(q!=null){
            if(set.contains(q)){
                return q;
            }
            q = map.get(q);
        }
        return null;
        

        
    }
    public void process(TreeNode root, HashMap map){
        if(root==null) return;
        if(root.left!=null){
            map.put(root.left, root);
            process(root.left,map);
        }
        if(root.right!=null){
            map.put(root.right, root);
            process(root.right,map);
        }
    }
}
```



### 递归

两种情况：

- 01和02一个是另一个的祖先。
- o1和02一个不是另一个的祖先。
  两种情况都走一下代码就能理解了。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null||root == p || root == q){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null){
            return root;
        }
        return left==null?right:left;
        
    }
}
```

```
public class Main {
	/**
	 * @param header 根节点
	 * @param o1     节点一
	 * @param o2     节点二
	 * @return 最近共父节点
	 * 
	 */
	public static Node ancestor(Node header, Node o1, Node o2) {
		if (header == null || o1 == header || o2 == header)
			return header;
		Node lNode = ancestor(header.leftNode, o1, o2);
		Node rNode = ancestor(header.rightNode, o1, o2);

		// 该条件只会成功一次，返回的header就是我们所要找的节点
		// 当该条件成立时，header结果就找到了，我们接下来的目的就是向上传递直至结束该递归调用
		// 由于我们不知道这个header节点是它的父节点的左还是右
		// 但是我们知道成功进入该条件后的所有递归中只能出现一边为null，另一边为header节点
		// 所以 返回： lNode != null ? lNode : rNode
		// 另外这句话也会在找到目标节点前将o1或o2传到上一个递归中，代表着这个路径上存在o1或o2
		// 当路径上没有o1或o2时，lNode和rNode均为空，随便返回一个
		if (lNode != null && rNode != null)
			return header;
		return lNode != null ? lNode : rNode;
	}

	static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

## [ 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

![image-20220312222216582](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220312222216582.png)

因此对于最大层数为 hh 的完全二叉树，节点个数一定在 `[2^h，2^(h+1)-1]` 的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。



如何判断第 k 个节点是否存在呢？如果第 k 个节点位于第 hh 层，则 k 的二进制表示包含 h+1位，其中最高位是 1，其余各位从高到低表示从根节点到第 kk个节点的路径，0表示移动到左子节点，1表示移动到右子节点。通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 kk 个节点是否存在。

层数从0开始，

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root==null) return 0;
        int height = 0;//根节点算是第0层
        TreeNode lchild = root;
        while(lchild.left !=null){
            height++;
            lchild=lchild.left;
        }
        int less = 1<<height;//根节点编号从1开始。
        int most= (1<<(height+1))-1;
        while(less<most){
            int mid = less+(most-less+1)/2;
            if(existNode( root, mid,height)){
                less=mid;
            }
            else{
                most=mid-1;
            }

        }
        return less;


    }
    public boolean existNode(TreeNode root, int mid, int level){
        int binNum = 1<<(level-1);//除了第一位1，第二位开始
        TreeNode tem=root;
        while(binNum>0&&tem!=null){
            //1往右，0往左
            if((binNum&mid)==0){
                tem=tem.left;

            }else{
                tem =tem.right;
            }
           binNum>>=1;
        }
        return tem!=null;
    }
}
```



## 子搜索二叉树的节点个数（套路题）

找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点个数。.

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {

			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;
		int childMaxBSTNodeNum;
		int maxValue;
		int minValue;
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 找到二叉树的后继节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142754947-ef41d590-bd86-4087-8aaa-e44d837ebba4.png)

node节点的下一个有三种情况：
1.node有右子树，则就是右子树的最左最下节点
2.node节点没有右子树：

node节点没有父节点，那也就是根节点，由于没有右子树，这时候没有下一个节点，parent也是null

node节点是父节点的左子树，那下一个节点就是父节点

node节点是父节点的右子树，那下一个节点就是一直往上找，直到找到一个节点，node在这个节点的左子树上




```
public class Main {
	public static Node process(Node header) {
		if (header == null) {
			return null;
		}
		if (header.rightNode != null) {
			return lastLeftNode(header.rightNode);
		}
		Node parent = header.parentNode;
		while (parent != null && parent.leftNode != header) {
			header = parent;
			parent = parent.parentNode;
		}
		return parent;
	}
	private static Node lastLeftNode(Node rightNode) {
		while (rightNode.leftNode != null) {
			rightNode = rightNode.leftNode;
		}
		return rightNode;
	}
	static class Node {
		int value;
		Node leftNode;
		Node rightNode;
		Node parentNode;
	}
}

```



https://leetcode-cn.com/problems/successor-lcci/solution/100liang-chong-qing-kuang-zhi-xu-yao-yi-ghpai/

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode pre = null;//记录最近一次左转的头结点
        while(root.val!=p.val){
            //右边
            if(p.val > root.val){          
                root = root.right;
            }
            //左边
            else{   
                pre = root;
                root = root.left;
            }
        }
        //假如没有右子树
        if(root.right==null){
            return pre;
        } 
        else{
            root = root.right;
            while(root.left!=null){
                root = root.left;
            }
            return root;
        }  
    }
}
```



## 二叉树的序列化和反序列化

https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/

https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756102-75b789e5-e277-4cde-8627-213fa40205f9.png)


![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756247-068974c6-5e8a-4013-a0d7-817756339d4b.png)

递归的方式：



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "null,";
        String res = root.val+",";
        res += serialize(root.left);
        res += serialize(root.right);
        return res;
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] values = data.split(",");
        Queue<String> queue= new LinkedList<>();
        for(int i=0;i<values.length;i++){
            queue.add(values[i]);
        }
        
        return reconPreOrder(queue);
    }

    public static TreeNode reconPreOrder(Queue<String> queue){
        String val = queue.poll();
        if(val.equals("null")){
            return null;
        }
        TreeNode head = new TreeNode(Integer.valueOf(val));
        head.left=reconPreOrder(queue);
        head.right=reconPreOrder(queue);
        return head;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

非递归的方式

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
          if(root == null) return "[]";
        StringBuilder res = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node != null) {
                res.append(node.val + ",");
                queue.add(node.left);
                queue.add(node.right);
            }
            else res.append("null,");
        }
        res.deleteCharAt(res.length() - 1);
        res.append("]");
        return res.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
          if(data.equals("[]")) return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            if(!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;

    }
}

```

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756826-89cdd006-6b38-4c4c-bfc6-a9146fc92b15.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756841-53102096-a643-4c93-9c4f-0fdaf98fc261.png)
中序遍历就是 纸条显示的内容  



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 递归

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null ){
            return true;
        }
        return valid(root.left,root.right);
    }
    public boolean valid(TreeNode left, TreeNode right){
        if (left==null&&right==null){
            return true;
        }
        if(left==null||right==null){
            return false;
        }
        return left.val==right.val&&valid(left.right,right.left)&&valid(left.left,right.right);
    }
}
```



### 迭代

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null ){
            return true;
        }
        return valid(root,root);
    }
    public boolean valid(TreeNode u, TreeNode v){
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(u);
        q.offer(v);
        while(!q.isEmpty()){
            u = q.poll();
            v = q.poll();
            if (u == null && v == null) {
                continue;
            }
            if ((u == null || v == null) || (u.val != v.val)) {
                return false;
            }
            q.offer(u.left);
            q.offer(v.right);
            q.offer(v.left);
            q.offer(u.right);

        }
        return true;
    }
}
```



## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

### 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int count = 0;
    public TreeNode convertBST(TreeNode root) {
        reInOreder(root);
        return root;
    }
    public void reInOreder(TreeNode root){
        if(root == null) return;
        reInOreder(root.right);
        count += root.val;
        root.val = count;
        reInOreder(root.left);
    }
    
}
```



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}

```

### 方法二：Morris 遍历

![image-20220316212053354](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220316212053354.png)

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        int sum = 0;
        TreeNode node = root;

        while (node != null) {
            if (node.right == null) {
                sum += node.val;
                node.val = sum;
                node = node.left;
            } else {
                TreeNode succ = getSuccessor(node);
                if (succ.left == null) {
                    succ.left = node;
                    node = node.right;
                } else {
                    succ.left = null;
                    sum += node.val;
                    node.val = sum;
                    node = node.left;
                }
            }
        }

        return root;
    }

    public TreeNode getSuccessor(TreeNode node) {
        TreeNode succ = node.right;
        while (succ.left != null && succ.left != node) {
            succ = succ.left;
        }
        return succ;
    }
}
```

## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

我自己的解法

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
         if(root==null){
            return 0;
        }
        dfs(root);
        return res-1;
        


    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int left=dfs(root.left);
        int right=dfs(root.right);
        res = Math.max(res,left+right+1);
        return Math.max(left,right)+1;
    }
}
```



## 哈夫曼最小代价问题

**哈夫曼树相关的几个名词**

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

> WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/09563Tb0-0.png)







**什么是哈夫曼树**

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

**构建哈夫曼树的过程**

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/09563QS5-1.png)

图 2 哈夫曼树的构建过程


图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。







### 金条切割问题

<img src="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220318230316327.png" alt="image-20220318230316327" style="zoom:60%;" />



```java
public class Main {
	public static int lessConsumer(int[] arr) {
		if (arr.length == 1)
			return arr[0];
		PriorityQueue<Integer> queue = new PriorityQueue<>();// 内部元素为堆结构（优先队列：默认是小顶堆，有小到大排列）
		for (int i : arr)
			queue.add(i);
		int sum = 0;
		while (queue.size() > 1) {
			// 构建赫夫曼树
			int num1 = queue.poll();
			int num2 = queue.poll();
			sum += (num1 + num2);
			queue.add(num1 + num2);
		}
		return sum;
	}
}

```





# 树形dp

![sdfsdfdssd](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D95FBD3D6DD4FF2CBDAA5A9011CCC7E.jpg)



风 9:11:52
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8137EC9804C17A0400E254509CD5AD74.jpg)

风 9:11:53
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/759C819ADFCB16E2CA56D2AEED307D6A.jpg)

## 树节点最远距离



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3D9B73ED255C5D81E3CC844F11CB856B.jpg)




![image-20220313150713372](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313150713372.png)



***递归套路：***

- 根据子树最大深度计算出经过当前节点的最长距离
- 向上传递子树和经过当前节点最长距离 的最大值
- 最长距离需要子树深度
- 所以递归数据包括最大距离和最大深度



最大深度表示当前子树的最大深度。最大距离表示当前子树包含的最大距离，有可能经过子节点，也有可能不经过子节点。

```
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 员工的快乐值



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/513BBF7364AF9B669F89CB5E33521B1C.jpg)


![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/36AEC04043D12E4DD4B9DD9B070B6BE8.jpg)

***递归套路：***

- 最大值和每个节点是否去有关，就是取 **当前节点不去（0）+子节点去或不去的最大值** 和 **当前节点去（happy）+子节点不去的最大值**
- 每个节点的去和不去都会直接影响父类节点，间接影响祖宗节点。
- 只要递归传递该节点去和不去的最大值信息即可。

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxHappy(header);
		return Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
	}

	private static TransformData maxHappy(Node header) {
		if (header.nexts == null) {
			return new TransformData(0, header.happyNum);
		}
		int dontWent = 0;
		int went = 0;
		for (Node nextNode : header.nexts) {
			TransformData data = maxHappy(nextNode);
			went += data.thisNodeDontWentSumHappy;
			dontWent += Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
		}
		return new TransformData(dontWent, went);
	}

	public static class TransformData {
		int thisNodeDontWentSumHappy;
		int thisNodeWentSumHappy;
		public TransformData(int thisNodeDontWentSumHappy, int thisNodeWentSumHappy) {
			this.thisNodeDontWentSumHappy = thisNodeDontWentSumHappy;
			this.thisNodeWentSumHappy = thisNodeWentSumHappy;
		}

	}

	public static class Node {
		int happyNum;
		Node[] nexts;
	}
}

```

## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

跟上个题类似，只不过是二叉树

递归的解法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        if(root==null) return 0;
        nodeMaxV res =  dfs(root);
        return Math.max(res.have,res.donehave);

    }
    public nodeMaxV dfs(TreeNode root){
        if(root == null){
            return new nodeMaxV(0,0);
        }
        nodeMaxV left = dfs(root.left);
        nodeMaxV right = dfs(root.right);

        return new nodeMaxV(left.donehave+right.donehave+root.val,
                            Math.max(left.have,left.donehave)+Math.max(right.have,right.donehave)
                            );
    }
    public static class nodeMaxV{
        int have;
        int donehave;
        public nodeMaxV(int have,int donehave){
            this.have = have;
            this.donehave = donehave;
        }
    }
}
```



换成不用定义类的解法，用int代替类

```
class Solution {
    public int rob(TreeNode root) {
        int[] rootStatus = dfs(root);
        return Math.max(rootStatus[0], rootStatus[1]);
    }

    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        int[] l = dfs(node.left);
        int[] r = dfs(node.right);
        int selected = node.val + l[1] + r[1];
        int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        return new int[]{selected, notSelected};
    }
}

```




## 树结构转成链表（套路题）

![image-20220313152313422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313152313422.png)

- 将左右子树构建好的结果通过本节点链接，就是递归对数据就是链接起始和结束节点。

中序遍历



```java
public class Main {
    public static Data process(Node x) {
        if (x == null) {
            return new Data(null, null);
        }
        // 将x作为中间节点，x.leftNode为创建x的前面的链表，x.rightNode为创建后面的链表。
        Data leftData = process(x.leftNode);
        Data rightData = process(x.rightNode);
        // 前后创建的链表和中间节点x链接，因为是双向链表，所以要有四句链接
        if (leftData.end != null) {
            leftData.end.rightNode = x;
        }
        x.leftNode = leftData.end;
        if (rightData.start != null) {
            rightData.start.leftNode = x;
        }
        x.rightNode = rightData.start;
        // 创建好后重新分装返回起始节点和尾节点
        return new Data(leftData.start != null ? leftData.start : x,
                rightData.end != null ? rightData.end : x);
    }

    static class Data {
        Node start;
        Node end;
        public Data(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/



```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    public Node treeToDoublyList(Node root) {
             if (root == null) return null;
        Stack<Node> stack=new Stack<>();
        Node pre=null;
        Node p=root;
        boolean isFirst=true;
        while (p!=null||!stack.isEmpty()){
            while (p!=null){//寻找子树的最左节点
                stack.push(p);
                p=p.left;
            }
            p=stack.pop();
            if (isFirst){//处理第一个节点，第一个节点没有前置节点
                root=p;
                pre=root;
                isFirst=false;
            }else {pre.right=p;//相当于遍历当前节点，因为不是第一个了，修改他之前节点的指向
            p.left=pre;
            pre=p;

            }
            p=p.right;//中序遍历，遍历下一个节点

        }
        root.left=pre;
        pre.right=root;
        return  root;
    }
}
```

递归的方式

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre,head;
    public Node treeToDoublyList(Node root) {
        if(root==null)return null;
           dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    public void dfs(Node root){
        if(root == null) return;
        dfs(root.left);
        if(pre!=null){
            pre.right=root;
        }else{
            head=root;
        }
        root.left=pre;
        pre=root;
        dfs(root.right);

    }
}
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

我个人的解法：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode pre;
    public void flatten(TreeNode root) {
         if(root==null) return;
        if(pre!=null){
            pre.right=root;
            pre.left=null;
        }
       TreeNode right=root.right;
        pre = root;
        flatten(root.left);
        flatten(right);
    }
   
} 
```







## 二叉树的个数

https://leetcode-cn.com/problems/unique-binary-search-trees/solution/

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/adea57019f814883a17071344d4f5f96.png)

### 递归

```java
public class Main {
	public static int process(int N) {
		if (N == 0 || N == 1) {
			return 1;
		}
		int res = 0;
		for (int i = 0; i < N; i++) {
			res += process(i) * process(N - i - 1);
		}
		return res;
	}
}

```

![image-20211227231055343](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227231055343.png)

### 动态规划

```java
public static int num(int n) {
    if (n < 2) {
        return 1;
    }
    int[] dp = new int (n + 1);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];

}
```

### **数学公式**

![image-20220314232245177](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220314232245177.png)

```
class Solution {
    public int numTrees(int n) {
        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }
}
```



## 判断是搜索二叉树（套路题）

**中序遍历实现**

中序遍历是有小到大的

```
public class Main {
	public static int lastNum=Integer.MIN_VALUE;
	public static boolean isBST(Node header) {
		if (header.leftNode!=null) {
			if (!isBST(header.leftNode)) {
				return false;
			}
		}
		if (lastNum>header.value) {
			return false;
		}
		lastNum=header.value;
		if (header.rightNode!=null) {
			if (!isBST(header.rightNode)) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

**递归套路实现**

![image-20220117092658302](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092658302.png)



```
public class Main {
	public static TransformData isBST(Node header) {
		if (header == null) {
			return new TransformData(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = isBST(header.leftNode);
		TransformData rightData = isBST(header.rightNode);
		boolean flag = leftData.max < header.value && rightData.min > header.value;
		return new TransformData(flag, Math.max(rightData.max, header.value), Math.min(leftData.min, header.value));
	}

	private static class TransformData {
		boolean sucess;
		int max;
		int min;
		public TransformData(boolean sucess, int max, int min) {
			this.sucess = sucess;
			this.max = max;
			this.min = min;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 子搜索二叉树的节点个数（套路题）

![image-20220117092722704](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092722704.png) 





![image-20220117093905556](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117093905556.png)

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
	//basecase 如果是空节点，也希望传递个上层节点已有能将递归进行下去，所以给最大值和最小值。 	
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		//递归左右子节点获取信息
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		//判断加上目前节点是不是构成一颗二叉搜索树，该节点的值应该大于左子树最大值，小于右子树最小值
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {
			//可能性1，该节点与左右子树构成一颗新的二叉搜索树，左右都得是二叉搜索树
			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
        // 可能性2 ，该节点与左右子树构不成二叉搜索树，就给maxValue赋值最小，minValue赋值最大，保证上层节点无法构成二叉搜索树。然后比较左右子树哪个节点多就返回哪个
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;//以该节点为根节点的子树是不是二叉搜索树
		int childMaxBSTNodeNum;//不管是或者不是，这颗子树拥有的最大的搜索二叉树的节点个数
		int maxValue;// 构成搜索二叉树的最大的值
		int minValue;//构成搜索二叉树最小的值
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```









## 前中序推后序遍历

![image-20220117235316030](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235316030.png)

- 关注在前中后序遍历之间的元素相对位置关系。
- ![image-20220117235951620](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235951620.png)

```java
public class Test {
    public static void main(String[] args) {
        int[] post = genPost(new int[]{1, 2, 4, 5, 3, 6, 7}, new int[]{4, 2, 5, 1, 6, 3, 7});
        System.out.println(Arrays.toString(post));
    }

    public static int[] genPost(int[] pre, int[] in) {
        int[] post = new int[pre.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        genPost(pre, 0, pre.length - 1, in, 0, in.length - 1, post, 0, post.length - 1, map);
        return post;
    }

    private static void genPost(int[] pre, int preStart, int preEnd,
                                int[] in, int medStart, int medEnd,
                                int[] post, int postStart, int postEnd,
                                HashMap<Integer, Integer> map) {
        if (preStart > preEnd) {
            return;
        }
        if (postStart == postEnd) {
            post[postStart] = pre[preStart];
            return;
        }
        //每一轮的前序第一个元素就是后序最后一个元素，在后续的genPost中不能再包含其他元素
        post[postEnd] = pre[preStart];

        //此时寻找pre[preStart]在med中的索引indexStart，那么最后的 indexStart - medStart 就是中间元素个数
        int indexStart = map.get(pre[preStart]);
        
        //以pre中preStart位置的元素为左右分割点,根据 indexStart 确定pre,in,post中的数据范围
        genPost(pre, preStart + 1, preStart + indexStart - medStart,
                in, medStart, indexStart - 1,
                post, postStart, postStart + indexStart - medStart - 1,
                map);
        genPost(pre, preStart + indexStart - medStart + 1, preEnd,
                in, indexStart + 1, medEnd,
                post, postStart + indexStart - medStart, postEnd - 1,
                map);
    }
}

```

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/



```
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}

```



## 求完全二叉树的节点的个数

​	

![image-20220118092613612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092613612.png)

![image-20220118093215169](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093215169.png)

求完全二叉树的深度的方法。

![image-20220118092804821](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092804821.png)



![image-20220118093156008](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093156008.png)

![image-20220118093510245](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093510245.png)

看右子树的深度是不是与当前最深度相等，是的，那左子树肯定是满二叉树，如果不是的话，那这个右子树肯定是满二叉树。确定了满二叉树的个数，就可以递归计算另外一个不是满二叉树的子二叉树的个数。base是空或者到了最后一层，肯定没有子树了，返回1。



## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

![image-20220313221616601](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313221616601.png)

```
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}

```







## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)



递归



```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left=right;
        root.right=left;
        return root;

    }
}
```



```
   /**
     * 层序遍历方式反转
     */
    public TreeNode invertTreeByQueue(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return root;
    }

    /**
     * 深度优先遍历的方式反转
     */
    private TreeNode invertTreeByStack(TreeNode root) {
        if (root == null) {
            return null;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            int size = stack.size();
            for (int i = 0; i < size; i++) {
                TreeNode cur = stack.pop();
                TreeNode temp = cur.left;
                cur.left = cur.right;
                cur.right = temp;
                if (cur.right != null) {
                    stack.push(cur.right);
                }
                if (cur.left != null) {
                    stack.push(cur.left);
                }
            }
        }
        return root;
    }
```

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

### 我的解法

就是深度优先搜索

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null && root2==null){
            return null;
        }
        if(root1==null){
            root1=root2;
        }else if(root2!=null){
            root1.val+=root2.val;
            root1.left = mergeTrees(root1.left,root2.left);
            root1.right = mergeTrees(root1.right,root2.right);
        }
        return root1;
    }
}
```

### 官方的深度优先搜索

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
```



### 广度优先搜索

![image-20220316222307002](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220316222307002.png)



其实就是层次遍历,借助三个队列

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        Queue<TreeNode> queue1 = new LinkedList<TreeNode>();
        Queue<TreeNode> queue2 = new LinkedList<TreeNode>();
        queue.offer(merged);
        queue1.offer(t1);
        queue2.offer(t2);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();
            TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;
            if (left1 != null || left2 != null) {
                if (left1 != null && left2 != null) {
                    TreeNode left = new TreeNode(left1.val + left2.val);
                    node.left = left;
                    queue.offer(left);
                    queue1.offer(left1);
                    queue2.offer(left2);
                } else if (left1 != null) {
                    node.left = left1;
                } else if (left2 != null) {
                    node.left = left2;
                }
            }
            if (right1 != null || right2 != null) {
                if (right1 != null && right2 != null) {
                    TreeNode right = new TreeNode(right1.val + right2.val);
                    node.right = right;
                    queue.offer(right);
                    queue1.offer(right1);
                    queue2.offer(right2);
                } else if (right1 != null) {
                    node.right = right1;
                } else {
                    node.right = right2;
                }
            }
        }
        return merged;
    }
}

```



## 折纸凹凸问题

![image-20220318230102031](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220318230102031.png)

- 上次每个折痕都有两个子折痕，上凹下凸，也就是二叉树节点都有一个凹左节点一个凸右节点。这些折痕的顺序就是二叉树的中序遍历。

```
public class Main {
	/**
	 * @param N 折N次
	 */
	public static void pre(int N) {
		pre(N, true);
	}

	private static void pre(int num, boolean down) {
		if (num == 0)
			return;
		pre(num - 1, true);// true表示凹，false表示凸
		System.out.print(down ? "down " : "up ");
		pre(num - 1, false);
	}
}

```

# 字典树



## [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

![image-20220321215557982](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220321215557982.png)

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/21
 * @Version 1.0
 **/
class Trie {
    private TrieNode root = new TrieNode('/');

    class TrieNode {
        public char data;
        public TrieNode[] children = new TrieNode[26];
        public boolean isEndingChar = false;

        public TrieNode(char data) {
            this.data = data;
        }
    }


    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); ++i) {
            int index = word.charAt(i) - 'a';
            if (p.children[index] == null) {
                TrieNode newNode = new TrieNode(word.charAt(i));
                p.children[index] = newNode;
            }
            p = p.children[index];
        }
        p.isEndingChar = true;
    }

    public boolean search(String word) {
        TrieNode p = root;//上一个单词找完到结尾了，从root开始找
        for (int i = 0; i < word.length(); i++) {//i以前的单词都被找完了。
            int index = word.charAt(i) - 'a';
            if (p.children[index] == null) {
                return false;
            }
            p = p.children[index];
        }
        if (p.isEndingChar == true) {
            return true;
        }
        return false;


    }

    public boolean startsWith(String prefix) {
        TrieNode p = root;//上一个单词找完到结尾了，从root开始找
        for (int i = 0; i < prefix.length(); i++) {//i以前的单词都被找完了。
            int index = prefix.charAt(i) - 'a';
            if (p.children[index] == null) {
                return false;
            }
            p = p.children[index];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

官方的解法

```java
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

### 字典树

```java
import java.util.List;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/20
 * @Version 1.0
 **/
public class wordBreak {
    // 1ms
    public boolean wordBreak(String s, List<String> wordDict) {
        Trie trie = new Trie();

        for (String word : wordDict)
            trie.insert(word.toCharArray());

        return trie.find(s, 0);
    }

    class TrieNode {
        public char data;
        public TrieNode[] children = new TrieNode[26];
        public boolean isEndingChar = false;

        public TrieNode(char data) {
            this.data = data;
        }
    }

    class Trie {
        private TrieNode root = new TrieNode('/');
        boolean[] failed = new boolean[301]; // s.length <= 300

        public void insert(char[] text) {
            TrieNode p = root;
            for (int i = 0; i < text.length; ++i) {
                int index = text[i] - 'a';
                if (p.children[index] == null) {
                    TrieNode newNode = new TrieNode(text[i]);
                    p.children[index] = newNode;
                }
                p = p.children[index];
            }
            p.isEndingChar = true;
        }

        public boolean find(String s, int i) {
            if (failed[i])//说明从i+1往后找s[i+1:...]往后的匹配，后续找不到了。
                return false;

            if (i >= s.length())//匹配完成
                return true;
            TrieNode p = root;//上一个单词找完到结尾了，从root开始找
            for (; i < s.length(); i++) {//i以前的单词都被找完了。
                int index = s.charAt(i) - 'a';
                if (p.children[index] == null) {
                    return false;
                }
                p = p.children[index];
                if (p.isEndingChar) {//找到了i才能走到这一步

                    if (find(s, i + 1))//，相当于是每次如果p位置是一个单词的结尾就先往下递归。相当于先匹配较短的单词
                        return true;
                    failed[i + 1] = true;//走到这一步，说明从i+1往后找s[i+1:...]往后的字符串失败了，后续找不到了。后面就不用从i位置找了。
                }
            }
            return false;//默认返回false，走到这一步，
        }
    }
}
```



最后之所以要return false，说明i没有走到匹配的一个单词的完整部分。例如这个，最终走到的是一个字母a，没有 走完一个完整单词

![image-20220321010020897](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220321010020897.png)



### 动态规划

s.substring(j,i) 从0位置开始计算，包含j不包含i位置的字符。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length()+1];
        dp[0] =true;
        for(int i = 1;i<=s.length();i++){
            for(int j = 0;j<i;j++){
                if(dp[j]&&set.contains(s.substring(j,i))){
                    dp[i]=true;
                    break;
                }
            }
        }

    return dp[s.length()];

    }
}
```







## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

递归

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if(root==null) return 0;
        int res=0;
        res+=rootSum(root,targetSum);
        res+=pathSum(root.left,targetSum);
        res+=pathSum(root.right,targetSum);
        return res;

    }
    public int rootSum(TreeNode root, int targetSum) {
        if(root==null){
            return 0;
        }
        
        int ret=0;
        if(targetSum==root.val){
            ret++;
        }
        ret+=rootSum(root.left,targetSum-root.val);
        ret+=rootSum(root.right,targetSum-root.val);
        return ret;

    }
}
```

前缀和

看这个地方来理解。

https://leetcode-cn.com/problems/path-sum-iii/solution/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6/

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        //HashMap的key是前缀和， value是该前缀和的节点数量，记录数量是因为有出现复数路径的可能。
        HashMap<Long, Integer> map=new HashMap<>();
        map.put(0L,1);
        
        return dfs(root,map,0,targetSum);

    }
    public int dfs(TreeNode root,HashMap<Long, Integer> prefix,long cur,int targetSum){
        if(root==null)  return 0;
        cur +=root.val;
        int res = prefix.getOrDefault(cur-targetSum,0);
          prefix.put(cur, prefix.getOrDefault(cur, 0) + 1);
        res+=dfs(root.left,prefix,cur,targetSum);
        res+=dfs(root.right,prefix,cur,targetSum);
        prefix.put(cur,prefix.getOrDefault(cur,0)-1);
        return res;




    }
}
```







## 文件夹结构



![image-20220111233804077](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111233804077.png)

![image-20220112000055179](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000055179.png)

然后深度优先遍历

![image-20220112000201818](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000201818.png)

![image-20220112003108883](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112003108883.png)



# 图

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142758750-d7ee486b-38b2-4b2b-958d-0399c5511f58.png)

表达图的一种方式
表示node的描述
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759443-88012d8e-dd5b-43f0-a2f3-bc297580ce16.png)
从上到下，分别是

- 值
- 入度
- 出度
- 由这个点指向的点的集合
- 指向这个点的集合

表示边的描述
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759537-dba9a3aa-e7ef-4716-a095-6d902dd50a39.png)

- 权值
- 从哪个点起
- 指向哪个点

图的表示，边集和点集

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759679-95421d22-2b96-4681-9b32-d3a4753945b6.png)

根据二维矩阵构建上面的图的代码
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759766-81df64fe-81ae-4ee2-b917-8d0b186511b6.png)

## 图的宽度优先遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759860-a07c5d09-3996-41a9-b7f5-9650028eee9c.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759911-078d0e38-bda0-49aa-8b4f-9f91c181d2b7.png)





## 图的广度优先遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142760807-8415810b-d085-452f-8411-4cb220a1270c.png)
栈里面的每个节点都是访问过的，因此下次只是弹出来寻找深度下一个节点，如果找到了，就把这两个都加入到栈中，然后访问下一个节点，将下一个节点保存到set中。set的作用就是保存已经访问过的节点。

## 拓扑排序

在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。

先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。

一直做改操作，直到所有的节点都被分离出来。

如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。

下面是算法的演示过程。

![image-20220319231051717](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220319231051717.png)





![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142765102-871b3421-eca8-4dfd-87c4-9cabaf885886.png)

## 最小生成树

1、什么是最小生成树
现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？
于是我们就可以引入连通图来解决我们遇到的问题，n个城市就是图上的n个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。

构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST性质（假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。

#### 普里姆算法—Prim算法

算法思路：
首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。

下面我们对下面这幅图求其最小生成树：

p算法:
加边，for循环使为了避免森林的问题
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142767395-d89aa4a6-bcb7-41ff-864d-c22f8d464456.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142767572-6ccb7b09-4da9-4f6e-9400-93ecfc21b498.png)
这个有时间再回来看吧，后边学了并查集可以替代这个算法。



p算法和k算法，要求最小生成树,以及要求无向图

#### 克鲁斯卡算法

算法思路：
（1）将图中的所有边都去掉。
（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环
（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。

这里同样我们给出一个和Prim算法讲解中同样的例子，模拟克鲁斯卡算法生成最小生成树的详细的过程：



k算法;
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142766500-43e8c50e-8913-4ed3-bed8-4232da9dc2d5.png)

定义一个比较器，然后按从小打大的顺序排列边，刚开始的时候每个节点是一个集合。然后一条一条的取出将边的两个节点加入到一个集合中，如果边的两个节点在一个集合中，就放弃这个边。直到只剩一个集合，也就是所有的节点已经联通了，同时使用到的边就是使集合联通的最小的权重。
用到的优先队列就是堆排序。



## 迪杰斯特拉算法

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768080-4cf6efd9-a5c4-4189-823b-9e9d2e63f60e.png)

规定了起点和终点，来算最短的路径
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768094-838451a3-d4dd-4e28-9359-3da6e5e989c8.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768230-963b952f-f4a1-4ffd-b760-9e45a1adf66d.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144153411-dac2e1b5-5a65-41ec-bedf-e718171fb0e6.png)
![Screenshot_2021-11-29-13-04-31-099_tv danmaku bil](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144153422-cc3c5bef-fce4-49b7-8101-d3a073755fd8.jpg)







# 暴力递归

## 递归实现字符串求值计算

可以用栈做，但是很麻烦。

不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。

![image-20220202172047991](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202172047991.png)

![image-20220202171131832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202171131832.png)



遇见括号就进行递归，让递归计算完括号内的部分，然后返回计算的值和计算到的位置，然后继续往下计算。



```java
public class StrToNum {
	public static void main(String[] args) {
		int a = value("4-(1+2)*3+1");
		System.out.println(a);
	}

	public static int value(String string) {
		if (string == null || string.length() == 0) {
			return 0;
		}
		return value(string.toCharArray(), 0)[0];
	}
    
//请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止
//返回两个值，长度为2的数组
​	// 0)负责的这-段的结果是多少
​	// 1) 负责的这- -段计算到了哪个位置
	private static int[] value(char[] str, int i) {
		LinkedList<String> list = new LinkedList<>();//双端队列，当成栈使用
		int num = 0;
		int[] bra = null;
		while (i < str.length && str[i] != ')') {
			if (str[i] >= '0' && str[i] <= '9') {
				num = num * 10 + str[i++] - '0';
			} else if (str[i] != '(') {
				addNum(list, num);
				list.addLast(String.valueOf(str[i++]));
				num = 0;
			} else {
				bra = value(str, i + 1);
				num = bra[0];
				i = bra[1] + 1;
			}

		}
		addNum(list, num);
		return new int[] { getNum(list), i };
	}
//不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。
	private static void addNum(LinkedList<String> list, int num) {
		if (!list.isEmpty()) {
			int cur = 0;
			String top = list.pollLast();
			if (top.equals("+") || top.equals("-")) {
				list.addLast(top);
			} else {
				cur = Integer.valueOf(list.pollLast());
				num = top.equals("*") ? (cur * num) : (cur / num);
			}
		}
		list.addLast(String.valueOf(num));

	}

	private static int getNum(LinkedList<String> list) {
		int res = 0;
		boolean add = true;
		String curString = null;
		int num = 0;
		while (!list.isEmpty()) {
			curString = list.pollFirst();
			if (curString.equals("+")) {
				add = true;
			} else if (curString.equals("-")) {
				add = false;
			} else {
				num = Integer.valueOf(curString);
				res += add ? num : (-num);
			}
		}
		return res;
	}
}

```



## [ 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/143888259-7d85ba99-28c5-4d52-9597-930321814669.png)


采用递归的思路
三要素如下：
递归结束条件：只剩下最后一个盘子需要移动
递归函数主功能：
1.首先将 n-1 个盘子，从第一个柱子移动到第二个柱子
2.然后将最后一个盘子移动到第三个柱子上
3.最后将第二个柱子上的 n-1 个盘子，移动到第三个柱子上
函数的等价关系式：
f(n,A,B,C) 表示将n个盘子从A移动到C
f(n,A,B,C)=f(n-1,A,C,B)+f(1,A,B,C)+f(n-1,B,A,C)

```
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlant(A.size(),A,B,C);
    }
    public void movePlant(int size, List<Integer> from, List<Integer> in, List<Integer> to){
        if(size==1){
            to.add(from.remove(from.size()-1));
            return;
        }
        movePlant(size-1,from,to,in);
         to.add(from.remove(from.size()-1));
         movePlant(size-1,in,from,to);
    }
}
```



## [ 字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)


全排列不重复

visit记录这个位置是否已经被当前字母试过全排列试过，每次都重新初始化visit，这样可以在同一个位置的下一个位置去跟别的位置交换的时候看是不是重复过。



### 回溯

```java
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/12
 * @Version 1.0
 **/
class Solution {
    public List<String> list = new ArrayList<>();
    public String[] permutation(String s) {
        char[] chars = s.toCharArray();
        process(chars, 0);
        int size = list.size();
        String[] recArr = new String[size];
        for (int i = 0; i < size; i++) {
            recArr[i] = list.get(i);
        }
        return recArr;

    }

    private void process(char[] chars, int i) {
        if (i == chars.length) {// 结果
            list.add(new String(chars));
            return;
        }
        boolean[] isVisited = new boolean[26];// 默认只有小写字母
        for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
            if (!isVisited[chars[j] - 'a']) {// 是否重复
                isVisited[chars[j] - 'a'] = true;
                swap(chars, i, j);// 交换
                process(chars, i + 1);// 递归
                swap(chars, i, j);// 恢复
            }
        }
    }

    private static void swap(char[] chars, int i, int j) {
        char c = chars[i];
        chars[i] = chars[j];
        chars[j] = c;
    }
}

```

```java
class Solution {
    List<String> rec;
    boolean[] vis;

    public String[] permutation(String s) {
        int n = s.length();
        rec = new ArrayList<String>();
        vis = new boolean[n];
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        StringBuffer perm = new StringBuffer();
        backtrack(arr, 0, n, perm);
        int size = rec.size();
        String[] recArr = new String[size];
        for (int i = 0; i < size; i++) {
            recArr[i] = rec.get(i);
        }
        return recArr;
    }

    public void backtrack(char[] arr, int i, int n, StringBuffer perm) {
        if (i == n) {
            rec.add(perm.toString());
            return;
        }
        for (int j = 0; j < n; j++) {
            if (vis[j] || (j > 0 && !vis[j - 1] && arr[j - 1] == arr[j])) {
                continue;
            }
            vis[j] = true;
            perm.append(arr[j]);
            backtrack(arr, i + 1, n, perm);
            perm.deleteCharAt(perm.length() - 1);
            vis[j] = false;
        }
    }
}


```





### 下一个排列

[31. 下一个排列的官方题解](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/)

```
class Solution {
    public String[] permutation(String s) {
        List<String> ret = new ArrayList<String>();
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        do {
            ret.add(new String(arr));
        } while (nextPermutation(arr));
        int size = ret.size();
        String[] retArr = new String[size];
        for (int i = 0; i < size; i++) {
            retArr[i] = ret.get(i);
        }
        return retArr;
    }

    public boolean nextPermutation(char[] arr) {
        int i = arr.length - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) {//从后往前寻找一个逆序排列的ab（a<b），此时i位于b
            i--;
        }
        if (i < 0) {
            return false;//说明已经是最大的字符串了，无法继续找下一个大点的字典序
        }
        int j = arr.length - 1;
        while (j >= 0 && arr[i] >= arr[j]) {//从后往前找第一个比i大的最小值，i后面应该都是从大到小排列了，相当于找到的是比i大的最小的
            j--;
        }
        swap(arr, i, j);//交换这俩位置，交换后应该还是有序的（倒叙成54321），因为j前面的比i大，j后面的比i小。因为是逆序，肯定能在i后面找一个这样的j
        reverse(arr, i + 1);//从i+1（包含）位置开始，倒叙，也就是54321变为12345.
        return true;
    }

    public void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public void reverse(char[] arr, int start) {
        int left = start, right = arr.length - 1;
        while (left < right) {
            swap(arr, left, right);
            left++;
            right--;
        }
    }
}

```









## 不借助额外空间把栈逆序

![image-20220322214134780](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322214134780.png)

```java
import javax.swing.*;
import java.util.Stack;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/
public class reservestack {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < 10; i++) {
            stack.push(i);
        }
        reverse(stack);
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }

    }

    public static void reverse(Stack<Integer> stack) {
        if (stack.isEmpty()) {
            return;
        }
        //f 返回最下面的值,剩下的按照原来的排列
        int i = f(stack);
        //反转栈中剩下元素
        reverse(stack);
        //放入最后一个元素
        stack.push(i);

    }

    //返回栈中最下面的元素
    public static int f(Stack<Integer> stack) {
        int i = stack.pop();
        //如果拿到这个就直接返回给上层，不需要放进去了
        if (stack.isEmpty()) {
            return i;
        }
        //不是最后一个元素就继续递归
        int j = f(stack);
        //把这个放进去，顺序还是不变
        stack.push(i);
        return j;
    }
}

```



## ?-N皇后（最優解法）

![image-20220323223431345](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323223431345.png)

```java
class Main {
    public static int num(int num) {
        if (num < 1 || num > 32) return 0;
        //limit用于限制在所有数据运算过程中保证除后num位的所有位数据均为零，来判断结束和标志结束
        int limit = num == 32 ? -1 : (1 << num) - 1;
        return process(limit, 0, 0, 0);
    }

    /**
     * @param limit    限制数据在一定的位运算范围内
     * @param coLim    该步前所有皇后纵向上已经存在皇后
     * @param leftLim  该步前所有皇后在k=-1的方向上对于我们该步皇后存在的限制
     * @param rightLim 该步前所有皇后在k=1的方向上对于我们该步皇后存在的限制
     * @return 该路径上存在的的情况，只会在成功时返回1
     * coLim/leftLim/rightLim三者的限制均是在位上为1的时候表示存在皇后
     */
    private static int process(int limit, int coLim, int leftLim, int rightLim) {
        if (limit == coLim) return 1;

        //(coLim | leftLim | rightLim)结果表示所有位上为1的位置均存在皇后，不能存放。
        //~后表示1的地方没有限制，可以存放皇后（但是，在32位的前32-num位上也为1，我们知道这是不合理的，因为不存在那么多的皇后）
        //limit&    表示将除num位的值变成0，这样就保证所有为1的元素均为空缺位置。
        int pos = limit & (~(coLim | leftLim | rightLim));
        int res = 0, mostRightOne;
        while (pos != 0) {//pos为0.说明不存在空缺位置
            mostRightOne = pos & (~pos + 1);//此时在后num位存在1，就将最右端的1取出。
            res += process(limit, coLim | mostRightOne  // 该mostRightOne位的皇后对于下一皇后纵向上的影响
                    , (leftLim | mostRightOne) << 1     // mostRightOne对于k=-1方向的影响
                    , (rightLim | mostRightOne) >> 1);  //mostRightOne对于k=1方向的影响
            pos = pos - mostRightOne;//更新pos，将取出的1减掉，表明mostRightOne中1所对应的位存在了，不能放了。
        }
        return res;
    }
}

```



![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154459-ca341852-9d1f-40ad-8a27-d5bfc8b0fb8f.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154742-1b451761-2ed2-4e48-bc5c-d71f75a5061e.png)

优化：
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154985-54ea35d8-11a6-481b-a243-8dd8c4dfe2b3.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144155019-15c3e157-96eb-4b1e-b848-30d9a34cba2a.png)


回头再学习这一部分



## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

![image-20220322223900565](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322223900565.png)

#### 深度优先搜索

```java
class Main {
    private static int[][] arr;
    private static int N;
    private static int M;
    public static int process(int[][] arr){
        PB.arr=arr;
        PB.N=arr.length;
        PB.M=arr[0].length;
        int res=0;//记录结果
        for (int i=0;i<N;i++){
            for (int j=0;j<M;j++){
                if (arr[i][j]==1){//有1且为被感染
                    res++;
                    infect(i,j);//感染
                }
            }
        }
        
        return res;
    }
    // 感染函数
    private static void infect(int i, int j) {
        if (i<0||i>=N||j<0||j>=M||arr[i][j]!=1)return;
        arr[i][j]=2;
        infect(i-1,j);
        infect(i+1,j);
        infect(i,j-1);
        infect(i,j+1);
    }
}






```



#### 方法二：广度优先搜索



```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;

        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    grid[r][c] = '0';
                    Queue<Integer> neighbors = new LinkedList<>();
                    //这么计算，可以反向得出r和c，这样只用存一个
                    neighbors.add(r * nc + c);
                    while (!neighbors.isEmpty()) {
                        int id = neighbors.remove();
                        int row = id / nc;
                        int col = id % nc;
                        //相当于是上面的递归的过程，把相邻的四个位置设置成0，如果有1就放入栈中继续
                        if (row - 1 >= 0 && grid[row-1][col] == '1') {
                            neighbors.add((row-1) * nc + col);
                            grid[row-1][col] = '0';
                        }
                        if (row + 1 < nr && grid[row+1][col] == '1') {
                            neighbors.add((row+1) * nc + col);
                            grid[row+1][col] = '0';
                        }
                        if (col - 1 >= 0 && grid[row][col-1] == '1') {
                            neighbors.add(row * nc + col-1);
                            grid[row][col-1] = '0';
                        }
                        if (col + 1 < nc && grid[row][col+1] == '1') {
                            neighbors.add(row * nc + col+1);
                            grid[row][col+1] = '0';
                        }
                    }
                }
            }
        }

        return num_islands;
    }
}

```



#### 并查集

同样地，我们也可以使用并查集代替搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其与相邻四个方向上的 11 在并查集中进行合并。

最终岛屿的数量就是并查集中连通分量的数目。

下面的动画展示了整个算法。

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/41b6ce1794ba80a7a82b31dc4c0642b26ccd280457d254d2fdad37a1f5a73ca6-image.png)

```
class Solution {
    class UnionFind {
        int count;
        int[] parent;
        int[] rank;

        public UnionFind(char[][] grid) {
            count = 0;
            int m = grid.length;
            int n = grid[0].length;
            parent = new int[m * n];
            rank = new int[m * n];
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (grid[i][j] == '1') {
                        parent[i * n + j] = i * n + j;
                        ++count;
                    }
                    rank[i * n + j] = 0;
                }
            }
        }

        public int find(int i) {
            if (parent[i] != i) parent[i] = find(parent[i]);
            return parent[i];
        }

        public void union(int x, int y) {
            int rootx = find(x);
            int rooty = find(y);
            if (rootx != rooty) {
                if (rank[rootx] > rank[rooty]) {
                    parent[rooty] = rootx;
                } else if (rank[rootx] < rank[rooty]) {
                    parent[rootx] = rooty;
                } else {
                    parent[rooty] = rootx;
                    rank[rootx] += 1;
                }
                --count;
            }
        }

        public int getCount() {
            return count;
        }
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        UnionFind uf = new UnionFind(grid);
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') {
                        uf.union(r * nc + c, (r-1) * nc + c);
                    }
                    if (r + 1 < nr && grid[r+1][c] == '1') {
                        uf.union(r * nc + c, (r+1) * nc + c);
                    }
                    if (c - 1 >= 0 && grid[r][c-1] == '1') {
                        uf.union(r * nc + c, r * nc + c - 1);
                    }
                    if (c + 1 < nc && grid[r][c+1] == '1') {
                        uf.union(r * nc + c, r * nc + c + 1);
                    }
                }
            }
        }

        return uf.getCount();
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 返回字符串的所有子字符串（树形）

- 将该问题看成二分类问题，将所有的单个字符元素是否存在看成一个事件，通过对所有的单个字符判读存在情况就可以得出所有子字符串
- 这样可以理解为二叉树的情况，每一层的每个节点下有两个子节点，表示该层对应的字符是否添加进路径中，最后树的所有叶子节点对应的字符串就是所以子字符串
- 我们采用动态生成树的递归方法对树进行动态的遍历。（该树必定为满树）



```java
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/

public class substr {

    public static String str;
    public static StringBuffer sBuffer = new StringBuffer();

    public static void main(String[] args) {
        process("abcd");
    }
    public static void process(String string) {
        if (string == null || string.length() == 0) {
            return;
        }
        substr.str = string;
        process(0);
    }

    private static void process(int index) {
        if (index == str.length()) {
            System.out.println(sBuffer.toString());
            return;
        }
        //含有index位置的字符的子字符串
        sBuffer.append(str.charAt(index));
        process(index + 1);
        //不含有index位置的子字符串
        sBuffer.deleteCharAt(sBuffer.length() - 1);
        process(index + 1);
    }
}

```

### [剑指 Offer II 079. 所有子集](https://leetcode-cn.com/problems/TVdhkn/)

```
class Solution {
    public List<List<Integer>> lists = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        if(n==0){
            return lists;
        }
        process(nums, 0, new ArrayList<Integer>());
        int count = lists.size();
        return lists;
    }
    public void process(int[] nums, int index,List<Integer> list){
            if(index==nums.length){
                lists.add(new ArrayList<>(list));
                return;
            }
            list.add(nums[index]);
            process(nums,index+1,list);
            list.remove(list.size() - 1);
            process(nums,index+1,list);
    }
}
```





## 最小字典序



![image-20220323215237572](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323215237572.png)

假设bcabca，这个字符串，第二个b往前的bca，在半部分都有多余的字符出现，也就是可以保留也可以不保留。因此可以在前半部分选择出一个最小的字符，从它往前的重复字符都舍弃，因为这个字符选择这个位置保存，其他位置的相同字符可以舍弃。然后继续递归剩下的部分，这样每次。都递归出最小的一个字符。拼接出来就是最终的结果

### 递归

```java
public class mindic {
    public static String process(String s) {
        if (s==null||s.length()<2)return s;
        int []map=new int[256];
        for (int i=0;i<s.length();i++){
            map[s.charAt(i)]++;
        }
        int minASCLLIndex=0;
        for (int i=0;i<s.length();i++){
                // 记录前面ASCLL最小的位置
                minASCLLIndex=s.charAt(minASCLLIndex)<s.charAt(i)?minASCLLIndex:i;
            if (--map[s.charAt(i)]==0){// 第一次发生一个字符的最后一次出现
                break;
            }
        }
        // minASCLLIndex后的字符串去掉s.charAt(minASCLLIndex)的字符串向后继续
        return  s.charAt(minASCLLIndex)+process(s.substring(minASCLLIndex+1).replaceAll(String.valueOf(s.charAt(minASCLLIndex)),""));
    }
}

```

### 栈

- 一直入栈，判断peek元素比当前大并且后面还存在和peek相同的字符，那么就从栈中删除栈顶元素。直到比当前遍历的小的，把这个字符放到栈中

```
class Solution {
    public String removeDuplicateLetters(String s) {
        int N = s.length();
        if (N <= 1) return s;
        char[] chars = s.toCharArray();
        Deque<Character> stack = new LinkedList<>();
        int[] lastIndex = new int[26];
        boolean[] isVisited = new boolean[26];
        for (int i = 0; i < N; i++) {
            lastIndex[chars[i] - 'a'] = i;
        }
        for (int i = 0; i < N; i++) {
            if (isVisited[chars[i] - 'a']) continue;
            while (!stack.isEmpty() && stack.peek() > chars[i] && lastIndex[stack.peek() - 'a'] > i) {
                isVisited[stack.pop() - 'a'] = false;
            }
            stack.push(chars[i]);
            isVisited[chars[i] - 'a'] = true;
        }
        StringBuffer stringBuffer = new StringBuffer();
        for (Character ch : stack) {
            stringBuffer.append(ch);
        }
        return stringBuffer.reverse().toString();
    }
}

```







# 递归转动态

## 机器人横向运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**



**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**



```java
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
     public static int[][] dp;
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
   
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20220323224837775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323224837775.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

`dp[i][j]`,i和j表示 从i位置开始走j步能到终点的方式数。basecase：`j==0的时候，只有i==j的时候才是1，其他位置为0，也就是第一行`

递归公式：

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



## 🐎飞棋盘（横向和纵向）

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```



**严格表结构**

`dp[i][j][k]`表示在（i,j）位置经过k步到达终点的路线数。
basecase：k为0的时候，只有i和j都为1的时候是1，其他位置为0，

状态转移方程：每个位置跟空间下一层（步数少一层的那一层）上八个相邻的位置相关。k为最外层循环，一层一层的（每次多一步）的往上计算

```java
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围
        dp[1][1][0] = 1;// 递归结束条件
        for (int k = 1; k <= K; k++) {// 步数
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```



## 纸币组合情况数

问题：**给定数组arr，数据为面值种类，组成res的总值，每种面值可以任意使用，问共有多少种组合方式**

### **暴力递归**

```java
public class Main {
    public static int[] coins;

    public static int process(int[] arr, int res) {
        coins = arr;
        return process(0, res);
    }

    private static int process(int index, int curRes) {
        if (curRes == 0) return 1;
        if (index == coins.length) return 0;
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        return res;
    }
}

```

### **记忆化搜索**

```java
public class Main {
    public static int[] coins;
    public  static int[][] dp;
    public static int process(int[] arr, int res) {
        coins = arr;
        dp=new int[arr.length+1][res+1];
        for (int[] i:dp){
            Arrays.fill(i,-1);
        }
        return process(0, res);
    }

    public static int process(int index, int curRes) {
        if (dp[index][curRes]!=-1)return dp[index][curRes];
        if (curRes == 0) {
            dp[index][curRes]=1;
            return 1;
        }
        if (index == coins.length) {
            dp[index][curRes]=0;
            return 0;
        }
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        dp[index][curRes]=res;
        return res;
    }
}

```

**严格表结构**

```java
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        //有个隐藏的条件，就是当coinindex为超出了硬币数量的范围，也就是coin.length的位置，而res>0的时候，那一列就都是0种可能
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                int ways = 0;
                // coins[coinIndex]硬币使用了thisCoinNum个
                for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curRes; thisCoinNum++) {
                    ways += dp[coinIndex + 1][curRes - thisCoinNum * coins[coinIndex]];
                }
                dp[coinIndex][curRes] = ways;
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```

![image-20220324225634341](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324225634341.png)

```java
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                // 该位置结果就是：
                //          dp[coinIndex+1][curRes] ( coins[coinIndex]硬币使用了0个 )
                //                      +
                //          dp[coinIndex][curRes-coins[coinIndex]] (coins[coinIndex]硬币使用了1个 )
                dp[coinIndex][curRes] = dp[coinIndex + 1][curRes];
                if (curRes - coins[coinIndex] >= 0) {
                    dp[coinIndex][curRes] += dp[coinIndex][curRes - coins[coinIndex]];
                }
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```







## [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

这个不同的顺序也是表示不同的组合，跟上面的不一样，上面的是不同的组合，只要硬币的数量和种类相同就算同一个方法

![image-20220324220240973](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324220240973.png)

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0]=1;
        for(int i=1;i<=target;i++){
            for(int num:nums){
                if(i-num>=0){
                dp[i]+=dp[i-num];
            }
            }
        }
        return dp[target];
    }
}
```



## [剑指 Offer II 081. 允许重复选择元素的组合](https://leetcode-cn.com/problems/Ygoe9J/)

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) 

两个题目是一样的

递归+回溯

```java
class Solution {
    public  List<List<Integer>> res;
    public List<Integer> list;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<List<Integer>>();
        list=new ArrayList<Integer>();
        process(candidates,target,0);
        return res;
    }
    public void process(int[] coins, int target,int index){
        if(target==0){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        if(target<0||index>=coins.length){
            return;
        }
        process(coins,target,index+1);//不选当前银币，直接往下递归,注意index+1
        if(target>=coins[index]){
            list.add(coins[index]);
            process(coins,target-coins[index],index);//选择一个硬币，注意index保持不变，因为只选了一个，下一个递归还可以接着选index位置的银币
            list.remove(list.size()-1);
        } 
       

    }
}
```

## [剑指 Offer II 080. 含有 k 个元素的组合](https://leetcode-cn.com/problems/uUsW3B/)

跟上个题方法类似，但是不允许有重复的数字出现。

这个也可以改成0-1背包的答案

![image-20220324222625396](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324222625396.png)

```java

class Solution {
    public List<List<Integer>> res;
    public List<Integer> tem;
    public List<List<Integer>> combine(int n, int k) {
        res = new ArrayList<List<Integer>>();
        tem = new ArrayList<Integer>();
        dfs(n,k,1);
        return res;
    }
    public void dfs(int n,int k, int index){
          // 剪枝：即使把从th开始的所有数都放入list也凑不齐k个，所以直接返回
        if(n-index+1<k) return;
        if(k==0){
            res.add(new ArrayList<Integer>(tem));
            return;
        }
        // 搜索策略一：组合中有第th个
        tem.add(index);
        dfs(n, k-1,index+1);
        tem.remove(tem.size()-1);
        // 搜索策略二：组合中没有第th个
        dfs(n,k,index+1);

    }
}
```







## 数字转化成字母（树形）

![image-20220322220646143](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322220646143.png)

**递归实现**

- 时间复杂度为指数级

```java
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```



**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
- 时间复杂度为O(N)

```java
public class Main {
	public static int process(String string) {
		if (string == null || string.length() == 0) {
			return 0;
		}
		if (string.length() == 1) {
			return string == "0" ? 0 : 1;
		}
		char[] arr = string.toCharArray();
		int N = arr.length;
		int[] res = new int[arr.length + 1];
		res[N] = 1;//为空的时候默认是1.base case
		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;//0不能作为前缀，只有一个字符的时候是1
		for (int i = N - 2; i >= 0; --i) {
			if (arr[i] == '0') {
				res[i] = 0;//0不能作为前缀
			} else {
				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
					res[i] = res[i + 1];//i不能与i+1组成数字
				} else {
					res[i] = res[i + 1] + res[i + 2];//i能和i+1组合为一个新的数，这时候就是i+2种可能，i单独的时候就是i
				}
			}
		}
		return res[0];
	}
}

```





## 背包问题（树形）

![image-20220324230449495](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324230449495.png)



- 和返回字符串的所有子字符串相似，判断每个物品是否装进了袋子两种选择
- 只需要用递归像树一样遍历所有选择取出最大值即可
- 这样的题可以使用动态规划O(N²),递归O(2^N)

### 暴力递归

```java
public class Main {
    private static int maxBag;
    private static int[] weights;
    private static int[] values;

    public static int process(int[] weights, int[] values, int maxBag) {
        Main.maxBag = maxBag;
        Main.weights = weights;
        Main.values = values;
        return process(maxBag, 0);
    }

    /**
     * @param w 剩余空间
     * @param i 当前已经判断到那个物品了
     * @return 最大价值
     */
    private static int process(int w, int i) {
        if (i == weights.length) return 0;
        if (w < weights[i]) return process(w, i + 1);
        return Math.max(process(w, i + 1), process(w - weights[i], i + 1) + values[i]);
    }
}

```

### **动态规划**

`dp[i][j]`状态：前i件商品，在重量上限为j的时候，能装货物的最大价值

初始值： i为0的时候，表示没有商品。价值只能为0

​				j为0的时候，没法装物品，也只能为0

返回值：`dp[weight.length][maxbag]`

```java
public class Main {
    public static int process(int[] weights, int[] values, int maxBag) {
        int[][] dp = new int[weights.length + 1][maxBag + 1];
        for (int i = 1; i <= weights.length; i++) {
            for (int j = 0; j <= maxBag; j++) {
                if (j < weights[i - 1]) dp[i][j] = dp[i - 1][j];//装不下这个物品
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j] + values[i - 1]);//装得下，装与不装选个最大值
            }
        }
        return dp[weights.length][maxBag];
    }
}

```

空间好像没办法剩压缩



## 整数分裂

![image-20220210091257710](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210091257710.png)

分裂以后必须递增，

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }    //pre是要进行（还没被分出去）进行分裂的值，一般都是从1开始递增。curRes是这个操作之前还没有分裂的数。

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes)
            return 0;//得保证裂开的序列是递增的。所以大于就得停止，没法往下走//
        int ways = 0;        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }
}

```

![image-20220210092404108](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210092404108.png)





**记忆化搜索**

```
import java.util.Arrays;

public class Main {
    public static int[][] dp;

    public static int process(int res) {
        if (res < 1) return 0;
        dp = new int[res + 1][res + 1];
        for (int[] i : dp) {
            Arrays.fill(i, -1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre      
        if (dp[pre][curRes] != -1) return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes] = 1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes] = 0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes] = ways;
        return ways;
    }
}
```

也就是记录一下每次递归的值

![image-20220210093203421](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210093203421.png)



**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件//
            dp[i][0] = 1;
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                for (int i = pre; i <= curRes; i++) {// 所有情况累加
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}
```

![image-20220210094755553](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210094755553.png)

第一列置为1，表示 curRes==0的时候，返回1，表示是一种成功的分裂的结果。

我们只需要对角线以上的部分就行了。因为pre得小于rest。

## 人气值

![image-20220118235953006](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235953006.png)



**错误代码**

- 没有考虑条件结束情况，也就是没有basecase
  ![image-20220119091240024](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119091240024.png)

```
public class Test {
    public static void process1(int start, int x, int y, int z, int end) {
        func(x, y, z, end, start);
    }

    private static int func(int x, int y, int z, int end, int thisNum) {
        if (end == thisNum) {
            return 0;
        }
        int resX = func(x, y, z, end, thisNum + 2) + x;
        int resY = func(x, y, z, end, thisNum * 2) + y;
        int resZ = func(x, y, z, end, thisNum - 2) + z;
        return Math.min(resX, Math.min(resY, resZ));
    }
}
```



**暴力递归**

上面缺少basecase,导致递归无法结束。因此最好的方法

根据题目内容找出一个不是最优解的平凡解作为上限，找出边界条件（比如负值）作为下限，超过这个范围就终止返回错误值。



```java
public class Main {
    public static int x, y, z, target, generalSolution;

    public static int process1(int x, int y, int z, int start, int end) {
        Main.x = x;
        Main.y = y;
        Main.z = z;
        Main.target = end;
        Main.generalSolution = (end - start) / 2 * x;        //自己推出来的平凡解，该解是该题的一个解 不知道是不是最右，但是最优值定少于等于该值        
        return func(start, 0);
    }

    /**
     * @param thisNum 当前人气     * @param coinsNum 当前消费的硬币量     * @return 该路径上所消费的硬币数量
     */
    private static int func(int thisNum, int coinsNum) {
        if (target == thisNum) {
            return coinsNum;
        }
        if (coinsNum > generalSolution) {
            return Integer.MAX_VALUE;
        }
        if (coinsNum < 0) {
            return Integer.MAX_VALUE;
        }
        int resX = func(thisNum + 2, coinsNum + x);
        int resY = func(thisNum * 2, coinsNum + y);
        int resZ = func(thisNum - 2, coinsNum + z);
        return Math.min(resX, Math.min(resY, resZ));
    }
}
```



**动态规划**

```java
public class Main {
    public static int process(int x, int y, int z, int start, int target) {
        int generalSolution = (target - start) / 2 * x;
        //表示每个target对应最大的硬币数，不会超过这个银币数的，        
        /int max = Math.max(x, Math.max(y, z));
        int[][] dp = new int[target + 1][generalSolution + max + 1];//第一维度表示当前的人气值，第二维度表示当前消费的硬币量        
        for (int i = 0; i <= generalSolution; i++) {
            dp[target][i] = i;
        }
        for (int i = generalSolution; i <= generalSolution + max; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for (int coinsConsume = generalSolution; coinsConsume >= 0; coinsConsume--) {
            for (int thisNum = start; thisNum <= target; thisNum++) {
                dp[thisNum][coinsConsume] = Math.min(dp[thisNum + 2][coinsConsume + x], Math.min(dp[thisNum * 2][coinsConsume + y], dp[thisNum - 2][coinsConsume + z]));
            }
        }
        return dp[start][0];
    }
}
```



![image-20220119093939360](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119093939360.png)



## 数组博弈最值



![image-20220324232849864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324232849864.png)

### 递归

```java
public class Main {
    public static int win(int[] arr) {
        return Math.max(f(arr, 0, arr.length - 1), e(arr, 0, arr.length - 1));
    }

    // 先手情况： 当前取值和下一次作为的后手结合的情况取最大值，就剩一个时那么结果直接取走
    public static int f(int[] arr, int l, int r) {
        if (l == r) return arr[l];
        return Math.max(arr[l] + e(arr, l + 1, r), arr[r] + e(arr, l, r - 1));
    }

    // 作为后手进行定是取值最小，剩一个元素就返回0
    public static int e(int[] arr, int l, int r) {
        if (l == r) return 0;
        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));
    }
}

```

**动态规划**

![image-20220324232951952](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324232951952.png)



```
public class Main {
    public static int process(int[] arr) {
        int N = arr.length;
        int[][] front = new int[N][N];
        for (int i = 0; i < N; i++) {
            front[i][i] = arr[i];
        }
        int[][] end = new int[N][N];
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j++) {
                front[i][j] = Math.max(arr[i] + end[i + 1][j], arr[j] + end[i][j - 1]);
                end[i][j] = Math.min(front[i + 1][j], front[i][j - 1]);
            }
        }
        return Math.max(front[0][N - 1], end[0][N - 1]);
    }
}

```



## 纸牌游戏

![image-20220322210430266](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322210430266.png)

i和1傻傻分不清

```java

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/
public class playcards {
    public static void main(String[] args) {
        playcards a = new playcards();
        int[] arr = new int[]{1, 2,3,4};
        System.out.println(a.win1(arr));
    }

    public int win1(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
    }

    public int f(int[] arr, int i, int j) {
        System.out.println("f" + i + ":" + j);
        if (i == j) {
            return arr[i];
        }
        return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
    }

    public int s(int[] arr, int i, int j) {
        System.out.println("s" + i + ":" + j);
        if (i == j) {
            System.out.println(0);
            return 0;
        }
        return Math.min(f(arr, i + 1, j), f(arr, i, j - 1));
    }

//     public static int win2(int[] arr) {
//         if (arr == null || arr.length == 0) {
//             return 0;
//         }
//
//     }
}

```



## 真假情况

![image-20220324233058168](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324233058168.png)



### **递归实现**

```
class Test {
    private static boolean isValid(char[] exp) {
        if ((exp.length & 1) == 0) {
            return false;
        }
        for (int i = 0; i < exp.length; i = i + 2) {
            if ((exp[i] != '1') && (exp[i] != '0')) {
                return false;
            }
        }
        for (int i = 1; i < exp.length; i = i + 2) {
            if ((exp[i] != '&') && (exp[i] != '|') && (exp[i] != '^')) {
                return false;
            }
        }
        return true;
    }

    public static int num1(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        return p(exp, desired, 0, exp.length - 1);
    }

    private static int p(char[] exp, boolean desired, int L, int R) {
        if (L == R) {
            if (exp[L] == '1') {
                return desired ? 1 : 0;
            } else {
                return desired ? 0 : 1;
            }
        }
        int res = 0;
        if (desired) {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                }
            }
        } else {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                }
            }
        }
        return res;
    }
}

```

**动态规划**

```java
class Test {
    public static int num2(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        int[][] t = new int[exp.length][exp.length];
        int[][] f = new int[exp.length][exp.length];
        t[0][0] = exp[0] == '0' ? 0 : 1;
        f[0][0] = exp[0] == '1' ? 0 : 1;
        for (int i = 2; i < exp.length; i += 2) {
            t[i][i] = exp[i] == '0' ? 0 : 1;
            f[i][i] = exp[i] == '1' ? 0 : 1;
            for (int j = i - 2; j >= 0; j -= 2) {
                for (int k = j; k < i; k += 2) {
                    if (exp[k + 1] == '&') {
                        t[j][i] += t[j][k] * t[k + 2][i];
                        f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i];
                    } else if (exp[k + 1] == '|') {
                        t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i];
                    } else {
                        t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i];
                    }
                }
            }
        }
        return desired ? t[0][t.length - 1] : f[0][f.length - 1];
    }
}

```





## 二元运算组合

![image-20220119214113494](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119214113494.png)

相当于给定了数列，我们只能加小括号改变运算的顺序，数字和字符的位置不能变动

![image-20220119215008178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215008178.png)





验证是不是符合要求的字符串

![image-20220119214904682](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119214904682.png)

basecase：L=R的时候，只有一个字符

![image-20220119215346885](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215346885.png)
![image-20220119215724416](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215724416.png)
![image-20220119215802512](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215802512.png)



改成动态规划

一个三维表，三个变量。

或者搞两个表，一个是true表，一个是false表

![image-20220119220612585](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220612585.png)







![image-20220119220735669](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220735669.png)

![image-20220119220808599](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220808599.png)





# 动态规划

## [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

![image-20220323234801080](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323234801080.png)

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length, m = obstacleGrid[0].length;
        int[] f = new int[m];

        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }
        
        return f[m - 1];
    }
}

```







## 类斐波那契数列

先看下数列

![image-20220110232208696](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232208696.png)



![image-20220111091236577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091236577.png)



斐波那契数列第n项的值，根据上面的矩阵得出。

![image-20220111091726036](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091726036.png)



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



可以推广到多项组合的数列



### \01字符串组合

![image-20220110232145674](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232145674.png)





![image-20220111094239894](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094239894.png)



- 第一个为1，第二个为2，的斐波那契数列

  

  ```
  public class Test {    public static int process(int N) {        if (N<=0)return 0;        if (N==1)return 1;        if (N==2)return 2;        int a=1;        int b=2;        int res=0;        while (N-2!=0){            res=a+b;            a=b;            b=res;            N--;        }        return res;    }}
  ```



### 辗转相除

```
public class Main {	public static int process(int a, int b) {		if (b == 0)// 表示上一步的辗转相除结果为0了			return a;		return process(b, a % b);	}}
```

### exp2

![image-20220111094656196](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094656196.png)

就是在N范围中第一项为1，第二项为2的斐波那契数列个数就是可以保留的个数。

“组成三角形的三条边需满足最长的边小于另外两条边之和,最短的边大于另外两条边之差的绝对值。”

说白了就是斐波那契数在前n有几个的问题

```
public class Main {	public static int process(int N) {		if (N <= 3)			return 0;		// num记录小于N的类斐波那契数列中元素个数		int a = 1, b = 2, res = 0, num = 2;		// 递归的斐波那契数列		while (true) {			res = a + b;			if (res > N)				return N - num;			a = b;			b = res;			num++;		}	}}
```







![image-20220111215757638](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111215757638.png)

## 咖啡机问题

![image-20220109172318637](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109172318637.png)

### 递归

```java
public class Main {    public static int sweepAllCup(int[] arr, int N, int a, int b) {                PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));//比较的是哪个咖啡机先生产出下一杯咖啡        for (int i : arr) {            queue.add(new Integer[]{0, i});//o[0]开始做的时间点 o[1]做完咖啡的时间点        }        int[] finishTime = new int[N];        for (int i = 0; i < N; i++) {            Integer[] integers = queue.poll();            integers[0] += integers[1];            finishTime[i] = integers[0];            queue.add(integers);        }        return sweepAllCup(finishTime, a, b, 0, 0);    }    // timePoint清洗机下一次空闲的时间    private static int sweepAllCup(int[] finishTime, int a, int b, int index, int timePoint) {        if (index == finishTime.length - 1) {            //basecase，到最后一杯咖啡时【洗完上一个杯子的时间】和【下一杯咖啡喝完的时间（喝完才能洗）加上洗杯子的时间】取较大的一个，就是洗玩下一个杯子的时间，然后跟喝完下一杯coffee的时间加上自然干净的时间取较小的一个，就是喝完下一杯咖啡并且洗干净杯子的时间。            return Math.min(Math.max(finishTime[index], timePoint) + a, finishTime[index] + b);        }        //咖啡机刷        int sweepTime = Math.max(timePoint, finishTime[index]) + a;        int sweepRestFinish = sweepAllCup(finishTime, a, b, index + 1, sweepTime);        int time1 = Math.max(sweepRestFinish, sweepTime);//刷这个杯子和剩余杯子都完成        //自己干        int dryTime = finishTime[index] + a;        int dryRestFinish = sweepAllCup(finishTime, a, b, index + 1, timePoint);        int time2 = Math.max(dryRestFinish, dryTime);//自干这个杯子和剩余杯子都完成        return Math.min(time1, time2);    }}
```

### **动态规划**

```java
 public class Main {    public static int sweepAllCup(int[] arr, int N, int a, int b) {        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));        for (int i : arr) {            queue.add(new Integer[]{0, i});        }        int[] finishTime = new int[N];        for (int i = 0; i < N; i++) {            Integer[] integers = queue.poll();            integers[0] += integers[1];            finishTime[i] = integers[0];            queue.add(integers);        }        int M = finishTime[N - 1] + b;        int[][] dp = new int[N][M + 1];        for (int i = 0; i <= M; i++) {            dp[N - 1][i] = Math.min(Math.max(i, finishTime[i]) + a, finishTime[i] + b);        }        for (int i = N - 2; i >= 0; i--) {            for (int j = 0; j < M; j++) {                int sweepTime = Math.max(finishTime[i], j) + a;                int time1 = Math.max(sweepTime, dp[i + 1][sweepTime]);                int dryTime = finishTime[i] + b;                int time2 = Math.max(dryTime, dp[i][dryTime]);                dp[i][j] = Math.min(time1, time2);            }        }        return dp[0][0];    }}
```



## mirror数

时间复杂度o(n)空间复杂度o1的遍历二叉树的方式，有点像线索二叉树

风 9:00:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA6222916FD12483540696AE21E31DE4.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/4C27099AE86BCE98E709AC5F9CF2538E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8504DEFFA83DB68111285AED30E18B0E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/EED6FE103117301421F4743445C3373B.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C75EE0D5505A484727EA6512F8E86D92.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/72D1C3B3F2016909613C37B70FC62739.jpg)

风 9:00:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0965229D51ED08FB47C5E19C2C823FAA.jpg)

## [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

https://leetcode-cn.com/problems/longest-valid-parentheses/



![image-20211228091332515](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228091332515.png)







```java
class Solution {    public int longestValidParentheses(String s) {         int maxans = 0;        int[] dp = new int[s.length()];        for(int i=1;i<s.length();i++){            if(s.charAt(i)==')'){                if(s.charAt(i-1)=='('){                    dp[i]=(i >= 2 ? dp[i - 2] : 0) + 2;                }else if(i-dp[i-1]-1>=0&& s.charAt(i - dp[i - 1] - 1) == '('){                     dp[i]=dp[i-1]+((i - dp[i - 1]) -2>= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;                }                maxans=Math.max(dp[i],maxans);            }        }        return maxans;    }}
```



## 数字解码方法

https://leetcode-cn.com/problems/decode-ways/

![image-20211228230339191](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228230339191.png)





**递归实现**

- 时间复杂度为指数级

  ```
  public class Main {	public static int process(String s, int i) {		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))			return 1;		if (s.charAt(i) == '0')			return 0;// 没有0开头匹配的元素		int res = process(s, i + 1);// 一个字符的		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的		return res;// 累加的结果返回就行了	}}
  ```

  **动态规划**

  - 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
  - 时间复杂度为O(N)

  

  - ```java
    public class Main {	public static int process(String string) {		if (string == null || string.length() == 0) {			return 0;		}		if (string.length() == 1) {			return string == "0" ? 0 : 1;		}		char[] arr = string.toCharArray();		int N = arr.length;		int[] res = new int[arr.length + 1];		res[N] = 1;		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;		for (int i = N - 2; i >= 0; --i) {			if (arr[i] == '0') {				res[i] = 0;			} else {				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {					res[i] = res[i + 1];				} else {					res[i] = res[i + 1] + res[i + 2];				}			}		}		return res[0];	}}
    ```

  - 



## 背包问题（树形）



![image-20220111220832926](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111220832926.png)

https://blog.csdn.net/qq_37438740/article/details/105072492

- 和返回字符串的所有子字符串相似，判断每个物品是否装进了袋子两种选择
- 只需要用递归像树一样遍历所有选择取出最大值即可
- 这样的题可以使用动态规划O(N²),递归O(2^N)







## 数组博弈最值

![image-20220119000120936](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119000120936.png)

**递归实现**

```
public class Main {    public static int win(int[] arr) {        return Math.max(f(arr, 0, arr.length - 1), e(arr, 0, arr.length - 1));    }    // 先手情况： 当前取值和下一次作为的后手结合的情况取最大值，就剩一个时那么结果直接取走    public static int f(int[] arr, int l, int r) {        if (l == r) return arr[l];        return Math.max(arr[l] + e(arr, l + 1, r), arr[r] + e(arr, l, r - 1));    }    // 作为后手进行定是取值最小，剩一个元素就返回0    public static int e(int[] arr, int l, int r) {        if (l == r) return 0;        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));    }}
```

**递归实现**

![image-20220119000151111](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119000151111.png)





```
public class Main {    public static int process(int[] arr) {        int N = arr.length;        int[][] front = new int[N][N];        for (int i = 0; i < N; i++) {            front[i][i] = arr[i];        }        int[][] end = new int[N][N];        for (int i = N - 1; i >= 0; i--) {            for (int j = i + 1; j < N; j++) {                front[i][j] = Math.max(arr[i] + end[i + 1][j], arr[j] + end[i][j - 1]);                end[i][j] = Math.min(front[i + 1][j], front[i][j - 1]);            }        }        return Math.max(front[0][N - 1], end[0][N - 1]);    }}
```





## 最长无重复子串

![image-20220119225152149](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119225152149.png)



**看到子串和子数组的问题，直接就选择以每个位置为结尾会怎么怎么样就好了**



```java
public class Main {    public static int process(String s) {        if (s == null || s.length() == 0) {            return 0;        }        char[] array = s.toCharArray();        int[] map = new int[256];//下标表示字符，值表示字符上一次出现的位置下标        Arrays.fill(map, -1);        int left = -1, maxLen = 0;// left表示此时向左延伸的最左位置，不包括array[left],包括array[right]        for (int right = 0; right < array.length; right++) {            left = Math.max(left, map[array[right]]);// 上次最左位置和array[right]上次出现的位置取最右的下标            maxLen = Math.max(maxLen, right - left);// 更新结果            map[array[right]] = right;// 更新上次出现的位置索引        }        return maxLen;    }}
```

## 字符串转换代价问题

![image-20220119230624915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119230624915.png)

- 该题主要是从什么地方下手，我们采用从字符串最后的地方下手，对于每一次决策进行三种选择，取最小值。

一个字符串作为行，一个字符串作为列

![image-20220119231341055](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119231341055.png)

`dp[i][j]`表示str1的前i个转换为str2的前j个字符串的代价是多少，str2为0的时候相当于str1一直删除。str1位0的时候相当于一直插入到str2.

对于`dp[i][j]`的值，有三种操作：

1. 执行一次更改：

​		`1.1 str1[i] == str[j],dp[i][j] = dp[i-1][j-1]`

​		`1.2 str1[i] != str[j],dp[i][j] = dp[i-1][j-1]+1` 更改一次的操作

2. 执行一次删除
   `dp[i][j] = dp[i][j]+1`
3. 执行一次添加
   `dp[i][j] = dp[i][j-1]+1`



**暴力递归**

暴力基本跟动态规划的几种情况差不多

```java
public class Main {    public static char[] str1, str2;    public static int ic, dc, rc;    public static int process(char[] s1, char[] s2, int i, int d, int r) {        str1 = s1;        str2 = s2;        ic = i;        dc = d;        rc = r;        return process(str1.length - 1, str2.length - 1);    }    public static int process(int str1_len, int str2_len) {        if (str1_len == 0 && str2_len == 0) {            return 0;        } else if (str1_len == 0) {            return ic * str2_len;        } else if (str2_len == 0) {            return dc * str1_len;        }        int replace;        if (str1[str1_len - 1] == str2[str2_len - 1]) {            replace = process(str1_len - 1, str2_len - 1);        } else {            replace = process(str1_len - 1, str2_len - 1) + rc;        }        int delete = process(str1_len - 1, str2_len) + dc;        int add = process(str1_len, str2_len - 1) + ic;        return Math.min(Math.min(delete, add), replace);    }}
```

**动态规划**

basecase 第一列，变为空串直接删除就好

```java
public class Main {    public static int process(String str1, String str2, int ic, int dc, int rc) {        if (str1 == null || str2 == null) {            return 0;        }        char[] chs1 = str1.toCharArray();        char[] chs2 = str2.toCharArray();        int row = chs1.length + 1;        int col = chs2.length + 1;        int[][] dp = new int[row][col];        //0个字符变成i个的添加代价        for (int i = 1; i < row; i++) {            dp[i][0] = dc * i;        }        //j个字符变成0个的删除代价        for (int j = 1; j < col; j++) {            dp[0][j] = ic * j;        }        for (int i = 1; i < row; i++) {            for (int j = 1; j < col; j++) {                //替换代价                if (chs1[i - 1] == chs2[j - 1]) {                    dp[i][j] = dp[i - 1][j - 1];                } else {                    dp[i][j] = dp[i - 1][j - 1] + rc;                }                /*                 dp[i][j - 1] + ic：                            i个转化成j-1长度的代价+一个添加代价                                             dp[i - 1][j] + dc：                            i-1个转化成j长度的代价+一个删除代价                 */                                          dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);            }        }        return dp[row - 1][col - 1];    }}
```



## 字符串转换问题



![image-20220121092936819](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121092936819.png)



## 字符串编码

![image-20220121093607212](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093607212.png)



![image-20220121094036917](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121094036917.png)





## 异或和为0的区间个数

网易的题目

![image-20220124231247965](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124231247965.png)

异或，英文为exclusive OR，缩写成xor

如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。

只有在两个比较的位不同时其结果是1，否则结果为0

即“两个输入相同时为0，不同则为1”！

| a    | b    | a⊕b  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

两个相同数异或的结果为0

任何数与0异或，结果都是那个数

![image-20220124232237022](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124232237022.png)

![image-20220124234457717](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124234457717.png)

![image-20220124235901697](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124235901697.png)

### 一般解

- 前序累计异或，根据从左向右的动态规划思想进行最大值的判断和记录。
- 初始值：位置为0的时候，0前面的-1位置默认为dp[-1] = 0
- dp[i]表示，以i位置（包含i位置）结尾的子字符串，最多能有几个异或为0的区间个数。
  对于dp[i]来说，i位置有两种情况：
  1. dp[i] 与前面的数字没有异或成0，因此这个数字相当于废掉的，他如果不为0的话，他就不起作用，单独就不是0.他的值直接等于dp[i-1]， 
  2. dp[i]与前面的数字进行异或构成一个异或为0的子区间。参考**两个相同数异或的结果为0**，因此只需要找这个数字前面最近的异或等于改为数字的区间的起始值就好。假设为j(包含j位置)，则dp[i]这种情况的值为 1+dp[j-1]，
  3. 然后比较两种情况的最大值，就能确定dp[i]位置最好的值
- 因此需要一个map。记录从头往后遍历数字，一直进行异或，记录每个异或以后的结果，key为结果，val为最近一次达到这个值的位置。在进行上面第二步的时候直接查。如果有就直接用来计算第二部，然后更新这个值的最近的位置为i。
- 如果从0位置异或到i位置为1000，如何找到含有i位置的最近的区间异或结果为0的位置？只要找到上一个距离i位置最近的从0异或到j位置的值为1000的j就好，这样从j+1异或到i的值就是0了，因为只有0异或1000的结果才是1000。这样就找到从j+1开始到i位置异或的结果为0，符合上面那个（2）条件了
- 这个就是前缀和，只不过是异或和



```java
public class Main {	public static int process(int[] arr) {		if (arr == null || arr.length == 0) {			return 0;		}		// 存储前面所有元素的累计异或结果		int[] preSum = new int[arr.length];		preSum[0] = arr[0];		// 计算累计异或结果		for (int i = 1; i < preSum.length; i++) {			preSum[i] = preSum[i - 1] ^ arr[i];		}		// 存储每个位置前的最多的亦或者为零的个数		int[] preMaxNum = new int[arr.length];		for (int i = 1; i < arr.length; ++i) {			// 初始化当前结果值			preMaxNum[i] = preSum[i] == 0 ? 1 : 0;			// 后面的值根据前面的更新，需要判断两个累计亦或结果相同，那么这其中异或和定为0			for (int j = i - 1; j >= 0; --j) {				if (preSum[j] == preSum[i]) {//如果preSum[j] == preSum[i]，则说明arr[j+1---i]的异或值为0，因为一个数异或0才等于这个数的值。					// arr[i……j]之间的的数组成一个亦或为0的值然后加上preMaxNum[j]就该结合的结果值					// 这里实际上若preMaxNum[j] + 1大的话可以直接退出该层循环。					preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[j] + 1);				}			}			// 使用arr[i]作为亦或为零的一部分和不用arr[i]的两种情况取最大值			preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[i - 1]);		}		return preMaxNum[preMaxNum.length - 1];	}}
```

### 优化解法

- 上一种解法中提到，当满足preMaxNum[j] + 1 > preMaxNum[i] 时就可以退出循环，说明我们只是找到一个满足更新条件即可

```java
public class Test {    public static int mostEOR(int[] arr) {        if (arr==null||arr.length==0)return 0;        int ans = 0;        int xor = 0;        int[] mosts = new int[arr.length];        HashMap<Integer, Integer> map = new HashMap<>();        map.put(0, -1);//初始值，默认-1位置的值为0，这样跟0位置异或的结果就是0位置的值        for (int i = 0; i < arr.length; i++) {            xor ^= arr[i];            //若存在，说明已经出现，那么之间的数字的异或和为0            //这种方式下就是上次出现该值前的个数+1就是当前个数            if (map.containsKey(xor)) {                int pre = map.get(xor);                mosts[i] = pre == -1 ? 1 : (mosts[pre] + 1);            }            if (i > 0) {                //判断    在次数分割和抛弃改次以上一次的方案哪个为最优解                //为了防止pre...i中出现多个异或和为0的情况                mosts[i] = Math.max(mosts[i - 1], mosts[i]);            }            //更新或添加此时xor的索引            map.put(xor, i);            //ans实际上最后也是mosts的最后一个值，也可以在最后直接返回mosts[mosts.length-1]            ans = Math.max(ans, mosts[i]);        }        return ans;    }}
```



![image-20220125001628190](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125001628190.png)





## 纸币组合情况数

https://leetcode-cn.com/problems/coin-change-2/

```java
class Solution {    public int change(int amount, int[] coins) {        int[] dp = new int[amount+1];        dp[0] = 1;        for(int coin:coins){            for(int i = coin;i<=amount;i++){                dp[i]+=dp[i-coin];            }        }        return dp[amount];    }}
```



问题：**给定数组arr，数据为面值种类，组成res的总值，每种面值可以任意使用，问共有多少种组合方式**

**暴力递归**

```
public class Main {    public static int[] coins;    public static int process(int[] arr, int res) {        coins = arr;        return process(0, res);    }    private static int process(int index, int curRes) {        if (curRes == 0) return 1;//已经找到了一种组合，返回数量1        if (index == coins.length) return 0;//已经到了最后一种面值的货币，没法继续往下递归了，看钱数rest是不是0，如果是返回1，说明组合出一种        int res = 0;        //相当于是01背包问题的变形体，每个位置其实是0-res/arr[i]的背包问题，全排列往下组合就完事        for (int num = 0; num * coins[index] <= curRes; ++num) {            res += process(index + 1, curRes - num * coins[index]);        }        return res;    }}
```



![image-20211217091538083](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211217091538083.png)



**记忆化搜索**

```
public class Main {    public static int[] coins;    public  static int[][] dp;    public static int process(int[] arr, int res) {        coins = arr;        dp=new int[arr.length+1][res+1];        for (int[] i:dp){            Arrays.fill(i,-1);        }        return process(0, res);    }    public static int process(int index, int curRes) {        if (dp[index][curRes]!=-1)return dp[index][curRes];        if (curRes == 0) {            dp[index][curRes]=1;            return 1;        }        if (index == coins.length) {            dp[index][curRes]=0;            return 0;        }        int res = 0;        for (int num = 0; num * coins[index] <= curRes; ++num) {            res += process(index + 1, curRes - num * coins[index]);        }        dp[index][curRes]=res;        return res;    }}
```

**严格表结构**

```
public class Main {    public static int process( int res,int[] coins) {        if (coins == null || coins.length == 0 || res <= 0) return 0;        int[][] dp = new int[coins.length + 1][res + 1];        for (int i = 0; i <= coins.length; i++) {            dp[i][0] = 1;// 递归结束条件        }        // 根据递归形式顺序进行填表        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {            for (int curRes = 0; curRes <= res; curRes++) {                int ways = 0;                // coins[coinIndex]硬币使用了thisCoinNum个                for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curRes; thisCoinNum++) {                    ways += dp[coinIndex + 1][curRes - thisCoinNum * coins[coinIndex]];                }                dp[coinIndex][curRes] = ways;            }        }        // 返回目标值        return dp[0][res];    }}
```

**枚举的斜率优化**

![image-20211214220414721](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220414721.png)



```
public class Main {    public static int process(int[] coins, int res) {        if (coins == null || coins.length == 0 || res <= 0) return 0;        int[][] dp = new int[coins.length + 1][res + 1];        for (int i = 0; i <= coins.length; i++) {            dp[i][0] = 1;// 递归结束条件        }        // 根据递归形式顺序进行填表        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {            for (int curRes = 0; curRes <= res; curRes++) {                // 该位置结果就是：                //          dp[coinIndex+1][curRes] ( coins[coinIndex]硬币使用了0个 )                //                      +                //          dp[coinIndex][curRes-coins[coinIndex]] (coins[coinIndex]硬币使用了1个 )                dp[coinIndex][curRes] = dp[coinIndex + 1][curRes];                if (curRes - coins[coinIndex] >= 0) {                    dp[coinIndex][curRes] += dp[coinIndex][curRes - coins[coinIndex]];                }            }        }        // 返回目标值        return dp[0][res];    }}
```



## 纸币组合最小个数问题

题目：**给定数组arr，里面的每个值表示一种面值，可随意使用，问组成aim所需要的最小张数，并返回**

**递归实现**





```
public class Main {    public static int[] coins;    public static int process(int[] coins, int res) {        if (coins == null || coins.length == 0 || res <= 0) {            return 0;        }        Main.coins = coins;        return process(0, res);    }	// 当前考虑的面值是arr[i]，还剩rest的钱需要找零	// 如果返回-1说明自由使用arr[i..N-1]面值的情况下，无论如何也无法找零rest	// 如果返回不是-1，代表自由使用arr[i..N-1]面值的情况下，找零rest需要的最少张数    private static int process(int coinIndex, int curNum) {    	// base case：		// 已经没有面值能够考虑了		// 如果此时剩余的钱为0，返回0张		// 如果此时剩余的钱不是0，返回-1        if (curNum == 0) {            return 0;        }        if (coinIndex == coins.length) {            return -1;        }		// 最少张数，初始时为-1，因为还没找到有效解        int minNum = -1;		// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过rest        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {			// 使用了k张arr[i]，剩下的钱为rest - k * arr[i]			// 交给剩下的面值去搞定(arr[i+1..N-1])            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);            if (next != -1) {                minNum = minNum == -1 ? next+thisCoinNum : Math.min(next + thisCoinNum, minNum);            }        }        return minNum;    }}
```

**记忆化搜索**



```
public class Main {    public static int[] coins;    public static int[][] dp;    public static int process(int[] coins, int res) {        if (coins == null || coins.length == 0 || res <= 0) {            return 0;        }        Main.coins = coins;        dp = new int[coins.length + 1][res + 1];        for (int[] i : dp) {            Arrays.fill(i, -2);        }        return process(0, res);    }    private static int process(int coinIndex, int curNum) {        if (dp[coinIndex][curNum] != -2) return dp[coinIndex][curNum];        if (curNum == 0) {            dp[coinIndex][curNum] = 0;            return 0;        }        if (coinIndex == coins.length) {            dp[coinIndex][curNum] = -1;            return -1;        }        int minNum = -1;        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);            if (next != -1) {                minNum = minNum == -1 ? next + thisCoinNum : Math.min(next + thisCoinNum, minNum);            }        }        dp[coinIndex][curNum] = minNum;        return minNum;    }}
```



**严格表结构**

```
public class Main {    public static int process(int[] coins, int res) {        if (coins == null || coins.length == 0 || res <= 0) {            return 0;        }        int[][] dp = new int[coins.length + 1][res + 1];        for (int i = 1; i <= res; i++) {            dp[coins.length][i] = -1;        }        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {            for (int curNum = 0; curNum <= res; curNum++) {                dp[coinIndex][curNum] = -1;// 初始化值，若是0.表示0张就可以完成，所以不合理                for (int coinNum = 0; coins[coinIndex] * coinNum <= curNum; coinNum++) {// 对于coins[coinIndex]的硬币进行每个个数的遍历                    int restIndex = curNum - coins[coinIndex] * coinNum;                    if (dp[coinIndex + 1][restIndex] != -1) {// 若该值 dp[coinIndex + 1][restIndex] 不能完成，就直接跳过                        // 取出最小值，注意最小值前要进行判断dp[coinIndex][curNum]是否为-1，表示此前没有方法出现                        dp[coinIndex][curNum] = dp[coinIndex][curNum] == -1 ? dp[coinIndex + 1][restIndex] + coinNum :                                Math.min(dp[coinIndex + 1][restIndex] + coinNum, dp[coinIndex][curNum]);                    }                }            }        }        return dp[0][res];    }}
```

**斜率优化**

```
public class Main {    public static int process(int[] coins, int res) {        if (coins == null || coins.length == 0 || res <= 0) {            return 0;        }        int[][] dp = new int[coins.length + 1][res + 1];        for (int i = 1; i <= res; i++) {            dp[coins.length][i] = -1;        }        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {            for (int curNum = 0; curNum <= res; curNum++) {                // 初始化值,继承第一个，因为定存在coins[coinIndex]一个不用的情况                dp[coinIndex][curNum]=dp[coinIndex+1][curNum];                if (coins[coinIndex]<=curNum){// 若存在可以用>=1个coins[coinIndex]进行计算                    int rest=curNum-coins[coinIndex];                    if (dp[coinIndex][rest]!=-1){// 该情况存在值                        // 取出最小值注意判断当前dp[coinIndex][curNum]是否为-1                        dp[coinIndex][curNum]=dp[coinIndex][curNum]==-1?dp[coinIndex][rest]+1:                        Math.min(dp[coinIndex][rest]+1,dp[coinIndex][curNum]);                    }                }            }        }        return dp[0][res];    }}
```









## 硬币结合动归

![image-20220125222729980](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125222729980.png)



```java
public class Main {    public static int moneyWays(int[] arbitrary, int[] onlyOne, int money) {        int[][] arbDp = getArbDp(arbitrary, money);        int[][] onlyDp = getOnDp(onlyOne, money);        //arbDp和onlyDp第一行就是所想要的情况数        int result = 0;        for (int i = 0; i <= money; i++) {            result += arbDp[0][i] * onlyDp[0][money - i];        }        return result;    }    //01背包问题    private static int[][] getOnDp(int[] onlyOne, int money) {        int[][] dp = new int[onlyOne.length + 1][money + 1];//列表示用的硬币数，行表示组成的金额，单元格表示有几种组合方法。之所以加一是假设最后一行，都为0，相当于没有使用硬币的一行。        //填写第一列，表示凑成总和为0都只有一种方法        for (int i = 0; i < onlyOne.length; i++) {            dp[i][0] = 1;        }        //从下往上，从左往右，依次填写单元格        for (int coinIndex = onlyOne.length - 1; coinIndex >= 0; coinIndex--) {            for (int resMoney = 0; resMoney <= money; resMoney++) {                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];//首先不使用该位置的硬币，也就是相当于这个硬币前面组合的个数。                if (resMoney > onlyOne[coinIndex]) {// 倘若可以挑选当前的一个硬币，钱币数大于当前硬币面额                    dp[coinIndex][resMoney] += dp[coinIndex + 1][resMoney - onlyOne[coinIndex]];//因为每个硬币只能选一次，因此只能等于前一行的硬币的组合                }            }        }        return dp;    }    //动态规划    private static int[][] getArbDp(int[] arbitrary, int money) {        int[][] dp = new int[arbitrary.length + 1][money + 1];        for (int i = 0; i <= arbitrary.length; i++) {            dp[i][0] = 1;        }        for (int coinIndex = arbitrary.length - 1; coinIndex >= 0; coinIndex--) {            for (int resMoney = 0; resMoney <= money; resMoney++) {                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];//不用coinIndex位置的钱币的组合数                if (resMoney > arbitrary[coinIndex]) {// 倘若可以挑选当前的一个硬币                    dp[coinIndex][resMoney] += dp[coinIndex][resMoney - arbitrary[coinIndex]];//因为可以选择多个同面额硬币，因此可以选择同一行的位置                }            }        }        return dp;    }}
```





## 能力蛇最大长度问题![image-20220202161741538](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202161741538.png)

![image-20220202162345377](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202162345377.png)



**递归实现**

```
class Main {	public static int walk1(int[][] matrix) {		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {			return 0;		}		int res = Integer.MIN_VALUE;		for (int i = 0; i < matrix.length; i++) {			int[] ans = process(matrix, i, 0);			res = Math.max(res, Math.max(ans[0], ans[1]));		}		return res;	}	public static int fun(int[][] m) {		int res = Integer.MIN_VALUE;		for (int i = 0; i < m.length; i++) {			int ans = fun(m, i, 0, 0, false);			res = Math.max(res, ans);		}		return res;	}	// 从(i,j)出发一直走到最右侧的旅程中	// 0) 在没有使用过能力的情况下，返回路径最大和	// 1) 在使用过能力的情况下，返回路径最大和	public static int[] process(int[][] m, int i, int j) {		if (j == m[0].length - 1) {			return new int[] { m[i][j], -m[i][j] };		}		int[] restAns = process(m, i, j + 1);		int restUnuse = restAns[0];		int restUse = restAns[1];		if (i - 1 >= 0) {			restAns = process(m, i - 1, j + 1);			restUnuse = Math.max(restUnuse, restAns[0]);			restUse = Math.max(restUse, restAns[1]);		}		if (i + 1 < m.length) {			restAns = process(m, i + 1, j + 1);			restUnuse = Math.max(restUnuse, restAns[0]);			restUse = Math.max(restUse, restAns[1]);		}		int no = m[i][j] + restUnuse;		int yes = Math.max(m[i][j] + restUse, -m[i][j] + restUnuse);		return new int[] { no, yes };	}}
```

**动态规划**

写的有问题，没有判断前一个位置为负数的情况。如果前一个位置为负数，说明游戏结束，下一个位置不应该到达。

```java
class Main {	public static int walk2(int[][] matrix) {		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {			return 0;		}		int[][][] dp = new int[matrix.length][matrix[0].length][2];		for (int i = 0; i < dp.length; i++) {			dp[i][matrix[0].length - 1][0] = matrix[i][matrix[0].length - 1];			dp[i][matrix[0].length - 1][1] = -matrix[i][matrix[0].length - 1];		}		for (int j = matrix[0].length - 2; j >= 0; j--) {			for (int i = 0; i < matrix.length; i++) {				int restUnuse = dp[i][j + 1][0];				int restUse = dp[i][j + 1][1];				if (i - 1 >= 0) {					restUnuse = Math.max(restUnuse, dp[i - 1][j + 1][0]);					restUse = Math.max(restUse, dp[i - 1][j + 1][1]);				}				if (i + 1 < matrix.length) {					restUnuse = Math.max(restUnuse, dp[i + 1][j + 1][0]);					restUse = Math.max(restUse, dp[i + 1][j + 1][0]);				}				dp[i][j][0] = matrix[i][j] + restUnuse;				dp[i][j][1] = Math.max(matrix[i][j] + restUse, -matrix[i][j] + restUnuse);			}		}		int res = Integer.MIN_VALUE;		for (int i = 0; i < matrix.length; i++) {			res = Math.max(res, Math.max(dp[i][0][0], dp[i][0][1]));		}		return res;	}}
```



## 可能性整理

1.从左往右推，也就是dp【i】表示0-i

2，范围尝试模型 也就是dp【i】【j】表示i到j范围上的最优解，以开头和结尾的字符有没有作为分类

## 相同子字符串

![image-20220202184008673](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202184008673.png)

![image-20220204215111322](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204215111322.png)

第一行第一列

![image-20220204220538864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204220538864.png)



然后根据该位置相不相等，相等就左上角的格子值加一，不等就是0

**动态规划**

```
public class Main {	public static String lcst1(String str1, String str2) {		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {			return "";		}		char[] chs1 = str1.toCharArray();		char[] chs2 = str2.toCharArray();		int[][] dp = getdp(chs1, chs2);		int end = 0;		int max = 0;		// 记录最长子串		for (int i = 0; i < chs1.length; i++) {			for (int j = 0; j < chs2.length; j++) {				if (dp[i][j] > max) {					end = i;					max = dp[i][j];				}			}		}		return str1.substring(end - max + 1, end + 1);	}	public static int[][] getdp(char[] str1, char[] str2) {		int[][] dp = new int[str1.length][str2.length];		for (int i = 0; i < str1.length; i++) {			if (str1[i] == str2[0]) {				dp[i][0] = 1;			}		}		for (int j = 1; j < str2.length; j++) {			if (str1[0] == str2[j]) {				dp[0][j] = 1;			}		}		for (int i = 1; i < str1.length; i++) {			for (int j = 1; j < str2.length; j++) {				if (str1[i] == str2[j]) {					dp[i][j] = dp[i - 1][j - 1] + 1;				}			}		}		return dp;	}}
```

**空间压缩**

![image-20220204231051332](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204231051332.png)

因为每个位置只与左上角的值相关，因此可以定义一个变量斜着计算就可以了。

```
class Main {	public static String lcst2(String str1, String str2) {		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {			return "";		}		char[] chs1 = str1.toCharArray();		char[] chs2 = str2.toCharArray();		int row = 0;		int col = chs2.length - 1;		int max = 0;		int end = 0;		while (row < chs1.length) {			int i = row;			int j = col;			int len = 0;			while (i < chs1.length && j < chs2.length) {				if (chs1[i] != chs2[j]) {					len = 0;				} else {					len++;				}				if (len > max) {					end = i;					max = len;				}				i++;				j++;			}			if (col > 0) {				col--;			} else {				row++;			}		}		return str1.substring(end - max + 1, end + 1);	}}
```

## 相同最长子序列



![image-20220205174438624](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205174438624.png)

可能性分类：四种情况，以i/j结尾的情况

![image-20220205191437590](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205191437590.png)

dp数组的状态就是到str的0到i的子字符串和str2的子字符串0到j，最长能构成的相同子序列的长度，

base case，第一行和第一列，因为都只有一个子字符串，因此可以根据两个字符串的第一个位置是否相等，也就是`dp[0][0]` 的值，如果相等，后续都为1，如果不等，就是0，然后往后推。或者扩大一行和一列，也就是第0行和第0列，表示两个字符串的其中一个为0的时候，都为0，按照这个`dp`的逻辑，直接往下走。

```java
public class Main {    public static String lcse(String str1, String str2) {        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {            return "";        }        char[] chs1 = str1.toCharArray();        char[] chs2 = str2.toCharArray();        int[][] dp = getdp(chs1, chs2);        // 根据dp表格还原计算出公共的字符序列        int m = chs1.length - 1;        int n = chs2.length - 1;        char[] res = new char[dp[m][n]];        int index = res.length - 1;        while (index >= 0) {            // dp[m][n]是根据那个值进行推出，是dp[m][n-1],dp[m-1][n]还是dp[m-1][n-1]            if (n > 0 && dp[m][n] == dp[m][n - 1]) {                n--;            } else if (m > 0 && dp[m][n] == dp[m - 1][n]) {                m--;            } else {                res[index--] = chs1[m];                m--;                n--;            }        }        return String.valueOf(res);    }    private static int[][] getdp(char[] str1, char[] str2) {        int[][] dp = new int[str1.length][str2.length];        dp[0][0] = str1[0] == str2[0] ? 1 : 0;        //初始化条件        for (int i = 1; i < str1.length; i++) {            dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);        }        for (int j = 1; j < str2.length; j++) {            dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);        }        //根据str1[0...i]和str2[0...j]比较是三种情况        //				i不当前str1子序列末尾结果，j为str2当前子序列最后元素        //				i在当前str1子序列末尾结果，j不为str2当前子序列最后元素        //				i是当前str1子序列末尾结果，j是str2当前子序列最后元素，存在条件为：str1[i] == str2[j] 成立        for (int i = 1; i < str1.length; i++) {            for (int j = 1; j < str2.length; j++) {                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);                if (str1[i] == str2[j]) {                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);                }            }        }        return dp;    }}
```



## 添加最少字符组成回文串



![image-20220205174605513](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205174605513.png)

状态：`dp[i][j]`状态就是从i到j需要增加多少字符才能构成回文串。对角线上只有一个字符，构成回文串，因此是0。对角线上面一个线，两个字符的时候，相等就是0，不等就是1。一定是根据开头和结尾讨论可能性。也是分四种情况：

1.添加i，也就是等于`dp[i+1][j]`+1

2.添加j，也就是等于`dp[i][j-1]`+1

2.i==j的时候，也就是等于`dp[i+1][j-1]`

然后把这个路径记录下来就可以了





![image-20220206164435092](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206164435092.png)



三种情况选最少的值。basecase就是对角线和对角线上面的那个斜线。

最终的值就是dp【0】【len-1】的值。

先从下往上，从左往右依次填写

![image-20220206164928474](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206164928474.png)

```java
public class PalindromeMinAdd {	public static String getPalindrome1(String str) {		if (str == null || str.length() < 2) {			return str;		}		char[] chas = str.toCharArray();		int[][] dp = getDP(chas);		char[] res = new char[chas.length + dp[0][chas.length - 1]];		int i = 0;		int j = chas.length - 1;		int resl = 0;		int resr = res.length - 1;        //逆着推，三种情况来反推路径		while (i <= j) {			if (chas[i] == chas[j]) {//1左下角				res[resl++] = chas[i++];				res[resr--] = chas[j--];			} else if (dp[i][j - 1] < dp[i + 1][j]) {//下边				res[resl++] = chas[j];				res[resr--] = chas[j--];			} else {//右边				res[resl++] = chas[i];				res[resr--] = chas[i++];			}		}		return String.valueOf(res);	}	public static int[][] getDP(char[] str) {		int[][] dp = new int[str.length][str.length];		for (int j = 1; j < str.length; j++) {			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;			for (int i = j - 2; i > -1; i--) {				if (str[i] == str[j]) {					dp[i][j] = dp[i + 1][j - 1];				} else {					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;				}			}		}		return dp;	}}
```

## 删除元素构成回文方法数量

![image-20220206190530610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206190530610.png)

**范围尝试的dp**

`dp[i][j]`表示【i。。。。j】范围上，有多少种保留的方案，包括必须i或者j位置字符的可能性。这个位置的值有四种情况的和构成。i和j包含不包含的关系，。

但是dp【i】【j-1】等于第3种和第4种的可能之和了，因为反正都没j。

dp【i+1】【j】等于第3种和第2种之和，都没i。相加多了一个三情况。

第1种情况只有`i==j`的时候才存在。当`i==j`的时候,比dp【i+1】【j-1】多了一种情况就是只保留i和j位置的时候，构成一个回文字符串。因此等于dp【i+1】【j-1】+1.i和j不相等，就是0.

![image-20220206192519897](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206192519897.png)

所有的解为：

![image-20220206193217882](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206193217882.png)



例子，全量且互斥

![image-20220206192006705](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206192006705.png)

```
class PalindromeWays {	public static int way1(String str) {		char[] s = str.toCharArray();		int len = s.length;		int[][] dp = new int[len + 1][len + 1];		for (int i = 0; i <= len; i++) {			dp[i][i] = 1;		}		for (int subLen = 2; subLen <= len; subLen++) {			for (int l = 1; l <= len - subLen + 1; l++) {				int r = l + subLen - 1;				dp[l][r] += dp[l + 1][r];				dp[l][r] += dp[l][r - 1];				if (s[l - 1] == s[r - 1])					dp[l][r] += 1;				else					dp[l][r] -= dp[l + 1][r - 1];			}		}		return dp[1][len];	}	public static int way2(String str) {		char[] s = str.toCharArray();		int n = s.length;		int[][] dp = new int[100][100];		for (int i = 0; i < n; i++) {			dp[i][i] = 1;			if (i + 1 < n && s[i] == s[i + 1])				dp[i][i + 1] = 3;			else				dp[i][i + 1] = 2;		}		for (int p = 2; p < n; ++p) {			for (int i = 0, j = p; j < n; ++i, ++j)				if (s[i] == s[j])					dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;				else					dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];		}		return dp[0][n - 1];	}}
```

















## 最长回文子序列

**序列是可以不连续的，只要字符按顺序即可。子串是必须连续的。**

![image-20220205223706137](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223706137.png)

`dp[i][j]`表示i到j范围上的最长回文字符串的值，`dp[0][length-1]`就是最终的结果，

1.对角线表示一个字符串的场景，值都是1.

2.对角线上面那一列表示两个字符的时候，直接看相等不相等就好了

![image-20220205231955441](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205231955441.png)

然后状态转移有四种情况，需要左边，左下和下面三个格子的值。从下往上，从左往右一行一行填写

![image-20220205232344425](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205232344425.png)





- 直接DP。注意上面的四种情况，第一种已经包含在第二种和第三种之间，因此不用考虑第一种。

```java
class PalindromeSubsequence {	public static int maxLen2(String s) {		if (s == null || s.length() == 0) {			return 0;		}		char[] str = s.toCharArray();		int[][] dp = new int[str.length][str.length];		for (int i = 0; i < str.length; i++) {			dp[i][i] = 1;		}		for (int i = 0; i < str.length - 1; i++) {			dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;		}		for (int i = str.length - 2; i >= 0; i--) {			for (int j = i + 2; j < str.length; j++) {				dp[i][j] = Math.max(dp[i][j - 1], dp[i + 1][j]);				if (str[i] == str[j]) {					dp[i][j] = Math.max(dp[i + 1][j - 1] + 2, dp[i][j]);				}			}		}		return dp[0][str.length - 1];	}}
```







- 求逆序串和该串的最长公共子序列,就是该字符串的最长回文子序列，`dp[i][j]`跟上面的概念不一样了。dp数组的状态就是到str1的0到i的子字符串和str2的子字符串0到j，最长能构成的相同子序列的长度。参考上面**相同最长子序列**的解法

```java
class PalindromeSubsequence {	public static int maxLen(String str) {		if (str == null || str.length() == 0) {			return 0;		}		char[] str1 = str.toCharArray();		char[] str2 = reverse(str1);		return lcse(str1, str2);	}	private static char[] reverse(char[] str) {		char[] reverse = new char[str.length];		for (int i = 0; i < reverse.length; i++) {			reverse[i] = str[str.length - 1 - i];		}		return reverse;	}	private static int lcse(char[] str1, char[] str2) {		int[][] dp = new int[str1.length][str2.length];		dp[0][0] = str1[0] == str2[0] ? 1 : 0;		for (int i = 1; i < str1.length; i++) {			dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);		}		for (int j = 1; j < str2.length; j++) {			dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);		}		for (int i = 1; i < str1.length; i++) {			for (int j = 1; j < str2.length; j++) {				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);				if (str1[i] == str2[j]) {					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);				}			}		}		return dp[str1.length - 1][str2.length - 1];	}}
```

## 将字符串分割成最少数量的回文串

从左往右的尝试模型

![image-20220206175152748](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206175152748.png)

`dp[i]`表示 i到最后这段范围内需要几刀。

![image-20220206180256673](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206180256673.png)

递归的解法：

![image-20220206180710661](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206180710661.png)

![image-20220206181802612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206181802612.png)



创建一个dp的表，表示i-j范围上是不是回文。
![image-20220206182119985](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206182119985.png)

![image-20220206184144382](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206184144382.png)

![image-20220206184228611](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206184228611.png)



```java
class Main {	public static int minCut(String str) {		if (str == null || str.equals("")) {			return 0;		}		char[] chas = str.toCharArray();		int len = chas.length;		int[] dp = new int[len + 1];		dp[len] = -1;		boolean[][] p = new boolean[len][len];		for (int i = len - 1; i >= 0; i--) {			dp[i] = Integer.MAX_VALUE;			for (int j = i; j < len; j++) {				if (chas[i] == chas[j] && (j - i < 2 || p[i + 1][j - 1])) {					p[i][j] = true;//判断这个位置是回文子串					dp[i] = Math.min(dp[i], dp[j + 1] + 1);				}			}		}		return dp[0];	}}
```



# 数学计算

## 数组相邻积能被4整除

![image-20220109181842536](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109181842536.png)

![image-20220109182228294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109182228294.png)

## 只有两个键的键盘


![image-20220107000747053](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000747053.png)

https://leetcode-cn.com/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/

两个题目有点像。
如果n是个质数，那么操作数只能是n-1次，也就相当于操作第二步。不然的话，无法凑成n（质数：只有1和自己的因数的的数。）
如果b不是个质数，则把n分解成`x*Y*z*...`等几个质数的乘积，需要的最少操作数就是子质数之和减去质数的个数。
因此可以用动态规划做。
初试条件s已经有了a了，因此dp的边界条件dp[1] = 0.
![image](https://user-images.githubusercontent.com/43565774/147913317-7f29fccd-8cf6-4214-8447-c75ad5465732.png)

![image](https://user-images.githubusercontent.com/43565774/147913626-a29d5f15-e26a-4bc1-bbf9-0185afa2b3e6.png)

```
class Solution {
    public int minSteps(int n) {
        int[] dp=new int[n+1];
        for(int i = 2;i<=n;i++){
            dp[i] = Integer.MAX_VALUE;
            for(int j = 1;j*j<=i;j++){
                if(i%j==0){
                    // 下面两个顺序不能换
                    dp[i]=Math.min(dp[i],dp[j]+i/j);
                dp[i]=Math.min(dp[i],dp[i/j]+j);
                 
            }
            }
        }
        return dp[n];
    }
}


##  判断是不是质数素数
public boolean isPrime(int n)

{undefined

if(n < 2) return false;

for(int i = 2; i < n; ++i)

if(n%i == 0) return false;

return true;

}
```




​    
​    
​    ## 自定义比较器
​    https://blog.csdn.net/whing123/article/details/77851737
​    
​     Comparator
​    class Teacher{  
​        int num;  
​        double salary;  
​    public Teacher(int num, double salary) {  
​        this.num = num;  
​        this.salary = salary;  
​    }  
​    
​    @Override  
​    public String toString() {  
​        return "\r\tnum:"+num+" salary:"+salary+"\r";  
​    }  
​    }  
​    
​    class StudentComparator implements Comparator{  
​    public int compare(Object o1, Object o2) {  
​        Teacher t1 = (Teacher) o1;  
​        Teacher t2 = (Teacher) o2;  
​        int result = t1.num > t2.num ? 1 : (t1.num == t2.num ? 0 : -1);  
​        return result = result == 0 ?(t1.salary<t2.salary ? 1 : -1) : result;  
​    }   
​    }  
Comparable

     import java.util.ArrayList;  
    import java.util.Collections;  
    import java.util.Comparator;  
    import java.util.List;  
    
    public class CompareTest {  
        public static void main(String[] args) {  
            List<Student> list = new ArrayList<Student>(10);  
            list.add(new Student(1,"jj"));  
            list.add(new Student(0,"ww"));  
            list.add(new Student(0,"kk"));  
            list.add(new Student(2,"ll"));  
            Collections.sort(list); // 内部比较器:要排序的类实现Comparable接口,可以对自身进行比较  
            System.out.println(list);  
       List<Teacher> t = new ArrayList<Teacher>(10);  
        t.add(new Teacher(1,12));  
        t.add(new Teacher(0,13));  
        t.add(new Teacher(0,14));  
        t.add(new Teacher(2,15));  
        Collections.sort(t,new StudentComparator()); //外部比较器:通过额外的类来实现Comparator接口  
        System.out.println(t);  
        }  
    }  


​    	
​	class Student implements Comparable {  
​	int num;  
​	String name;  
​	
​	public Student(int num, String name) {  
​	    this.num = num;  
​	    this.name = name;  
​	}  
​	
​	@Override  
​	public String toString() {  
​	    return "\r\tnum:"+num+" name:"+name+"\r";  
​	}  
​	
​	public int compareTo(Object o) {  
​	    Student tmp = (Student) o;  
​	    int result = tmp.num > num ? 1 : (tmp.num==num ? 0 : -1);  
​	    if (result == 0) {  
​	        result = tmp.name.indexOf(0) > name.indexOf(0) ? 1 : -1;  
​	    }  
​	    return result;  
​	    }  
​	}  



# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位

 ![image](https://user-images.githubusercontent.com/43565774/144262216-121ffafc-12ef-4094-a838-e9ef2f034ba4.png)

![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整



## 一致性哈希





## [缓存算法（页面置换算法）-FIFO、LFU、LRU ](https://www.cnblogs.com/dolphin0520/p/3749259.html)



# 并查集

https://www.cnblogs.com/noKing/p/8018609.html

并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。



融合

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8CF8D66817018FBB3E968AB8FACBB42B.jpg)

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C15EF7866196C79D418DCECBC4D33358.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/69490C61145109D46C98A19C56B204BD.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0DAF1C2D9659D76ED8EE873A64431511.jpg)

风 23:46:16
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/AC53BA985C9A6E9E5B79F90A72375321.jpg)





![image-20211202232412841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202232412841.png)



## 杭电ACM-1232-畅通工程

连接：http://acm.hdu.edu.cn/showproblem.php?pid=1232

> 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 

思路：与上面题思路一样，在并查集中进行合并操作，求出最后剩下多少个组(集合)。这些组之间是互相不可达的。假如有M个组，那其实再需要M-1条连线就可以把他们连接起来了。所以组数 - 1 就是最后答案

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/20
 * @Version 1.0
 **/
class UnionFind2 {
    /**
     * 记录并查集对应位置的父亲结点位置
     */
    private int[] parent;
    /**
     * 记录并查集对应结点的重量
     */
    private int[] weight;
    /**
     * 表示并查集的元素个数
     */
    private int size;
    /**
     * 表示并查集中集合的个数(组数)
     */
    private int groups;

    public UnionFind2(int size) {
        this.size = size;
        this.groups = size;
        this.parent = new int[size];
        this.weight = new int[size];
        for (int i = 0; i < size; i++) {
            this.parent[i] = i;
            this.weight[1] = 1;
        }
    }

    public int find(int element) {
        while (element != parent[element]) {
            parent[element] = parent[parent[element]];
            element = parent[element];
        }
        return element;
    }

    public boolean isConneted(int firstElement, int secondElement) {
        return find(firstElement) == find(secondElement);
    }

    public void unionElements(int firstElement, int secondElement) {
        int firstRoot = find(firstElement);
        int secondRoot = find(secondElement);
        if (firstRoot == secondRoot) {
            return;
        }
        if (weight[firstRoot] < weight[secondRoot]) {
            parent[firstRoot] = secondRoot;
            weight[secondRoot] += weight[firstRoot];
        } else {
            parent[secondRoot] = firstRoot;
            weight[firstRoot] += secondRoot;
        }

        this.groups--;
    }

    public int getGroups() {
        return this.groups;
    }
}

public class unionFindPath {
    public static void main(String[] args) {
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        int size = scanner.nextInt();
        while (size != 0) {
            int input = scanner.nextInt();
            UnionFind2 union = new UnionFind2(size);
            for (int i = 0; i < input; i++) {
                //因为测试数据中是从1开始技术。而我们的并查集是从0开始，所以每个输入都减1
                int first = scanner.nextInt() - 1;
                int second = scanner.nextInt() - 1;
                union.unionElements(first, second);
            }
            //最后剩下的组数 - 1 就是最后的答案。因为连接M组的话，需要M-1条连线就可以了
            System.out.println(union.getGroups() - 1);
            size = scanner.nextInt();
        }
    }
}
```

# 并查集 

看一个图是不是联通的？或者看两个不直接相交的节点是不是有关系的？
https://zhuanlan.zhihu.com/p/93647900/ 并查集的介绍
比较麻烦的操作方式
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142766323-aeed57a4-6cc2-4de7-ae11-5d8c58c9033b.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142766335-b428c4cd-4c32-4f7c-b09a-b962d128967b.png)

真正的并查实现方式









# kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)





## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

# 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





# 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算





## 接雨水



### 1.单调栈

```
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 双指针

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
        // 先更新指针的值，再进行计算雨水，再移动指针较小的端的指针。
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











### 最大分段最大值的差

![image-20220107000935422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000935422.png)



找到最大值，然后减去两头的值，哪个小减去哪个。因为两段以后必然包含端点的值。
![image-20220107001615368](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001615368.png)











# 有序表

![image-20211219180032411](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219180032411.png)















# 大数据问题

有限的空间找到几十亿条数据中没有出现的数

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3FDC6603989FCA68399CFD474D160126.jpg)

风 9:00:23
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9E73E41834A98DDD73670482DB8BD9DB.jpg)









# 回溯法

1.确定base case，也就是递归的终止条件或者出口

2.确定递归方法的固定参数和可变参数，以及局部输出结果，也就是下一个节点要走的结果，相当于黑盒子，

3.然后搜集子递归过程，返回给上游，最上游输出的结果就是递归的结果



优化为记忆化搜索的过程：

将子问题的结果记录在一个数组中，别的递归调用到相同的参数 的时候可以重复使用，然后就可以转为记忆化搜索的过程

## 矩阵中的路径
题目 : 请设计请设计一个函数用来判断在矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个位置开始，每部可以在矩阵中的上下左右四个方向移动，如果一条路径已经经过了矩阵的某一个格子，那么该路径就不能够再次进入该格子。

对于每个格子均有可能是起始节点，并且每个路径和其他路径没有太多可利用关系，所以要进行所有的格子作为起始结点来判断。
由于要进行方向定位，像迷宫一样进行递归回缩。

```java 
public class Main {
	public static boolean process(char[][] matrix, char[] str) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0 || str.length == 0) {
			return false;
		}
		int rows = matrix.length;
		int line = matrix[0].length;
		// 用于记录是否走过该路径
		boolean[][] isVisited = new boolean[rows][line];
		int pathLen = 0;
		// 对于每一个元素进行起始的判断
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < line; j++) {
				if (hasSuccessPath(matrix, i, j, str, 0, isVisited)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * @param matrix    元素矩阵
	 * @param row       判断matrix中行位置元素
	 * @param line      判断matrix中列位置元素
	 * @param str       寻找的目标串
	 * @param index     目标串的第几个元素
	 * @param isVisited 记录是否走过的表格
	 * @return			该路径是否可行
	 */
	private static boolean hasSuccessPath(char[][] matrix, int row, int line, char[] str, int index,
			boolean[][] isVisited) {
		// 此时说明index前面的所有元素均已经匹配成功
		if (str.length == index) {
			return true;
		}
		// 不符合条件返回不通行
		if (row >= matrix.length || line == matrix[0].length || row < 0 || line < 0 || isVisited[row][line]
				|| matrix[row][line] != str[index]) {
			return false;
		}
		++index;
		// 标记该路已经走过
		isVisited[row][line] = true;
		// 向四个方向均进行尝试
		boolean hasPath = hasSuccessPath(matrix, row + 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line + 1, str, index, isVisited)
				|| hasSuccessPath(matrix, row - 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line - 1, str, index, isVisited);
		// 若没有成功将isVisited值进行还原避免影响后续判断，若为真那么在该步骤结束时循环，不会对后来的产生影响
		if (!hasPath) {
			isVisited[row][line] = false;
		}
		return hasPath;
	}
}

```


## 机器人的运动范围
题目： 地上有一个M行N列的方格，一个机器人从坐标( 0, 0 )的个格子开始移动，他每次可向左右上下四个方向移动一个格子，但不能进入行坐标和列坐标的各个位数之和大于K值，并且到达每个格子之前必定可以通过其他格子到达该格子。例如： k=18,机器人可以进入（35，37），3+5+3+7=18<=18能进入,（36，38），3+6+3+8=20>18,不能进入。

该题目实际上和上一题本质相同，仅仅是改变了限制条件和起始范围
该题的起始范围已经给定（0，0），只需要向上下左右进行递归回溯，另外在递归时要记录路径个数。

```
public class Main {
	public static int process(int k, int rows, int lines) {
		if (k < 0 || rows <= 0 || lines <= 0) {
			return 0;
		}
		boolean[][] isVisited = new boolean[rows][lines];
		return movingCount(k, rows, lines, 0, 0, isVisited);

	}

	/**
	 * @param k         限制条件k
	 * @param rows      矩阵总行数
	 * @param lines     矩阵总列数
	 * @param i         当前元素行数量
	 * @param j         当前元素列数量
	 * @param isVisited 是否已经访问过
	 * @return 可以选择的个数
	 */
	private static int movingCount(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		int count = 0;
		// 如果满足限制条件就进行标记，并以此为展开进行递归搜索
		if (canVisited(k, rows, lines, i, j, isVisited)) {
			isVisited[rows][lines] = true;
			count += movingCount(k, rows, lines, i + 1, j, isVisited)
					+ movingCount(k, rows, lines, i - 1, j, isVisited)
					+ movingCount(k, rows, lines, i, j + 1, isVisited)
					+ movingCount(k, rows, lines, i, j - 1, isVisited);
		}
		return count;
	}

	private static boolean canVisited(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		if (i >= 0 && i < rows && j >= 0 && j < lines && !isVisited[i][j] && getDigitSum(i) + getDigitSum(j) <= k) {
			return true;
		}
		return false;
	}

	// 计算num和各位数字之和
	private static int getDigitSum(int num) {
		int sum = 0;
		while (num > 0) {// 不能 = 0
			sum += num % 10;
			num /= 10;
		}
		return sum;
	}
}

```

## 机器人到达某个位置的路径数量

## 机器人运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**

**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
    public static int[][] dp;
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20211214220219521](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220219521.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



加个二维数组记录位置的结果，记忆化搜索的优化

![image-20211214091329206](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091329206.png)



![image-20211214091359467](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091359467.png)

改为动态规划的版本：

​	二维数组，行代表在哪个位置，列代表该位置还有几部可以走。
​	首先初始化第一行，也就是basecase，然后分析下一个位置。



![image-20211214092524034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214092524034.png)





## 飞棋盘

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```

**严格表结构**

```
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围 三维分别是 x坐标、y坐标、走了几步
        dp[1][1][0] = 1;// 递归结束条件 起始位置，走0步到1,1的方式有一种
        // 递归的意识是，走了k步到达i,j位置的方式有几种
        for (int k = 1; k <= K; k++) {// 步数 
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```



## 整数分裂

![image-20211214220703594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220703594.png)

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes) return 0;
        int ways = 0;
        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }

}

```

**记忆化搜索**

```
public class Main {
    public static int[][] dp;
    public static int process(int res) {
        if (res < 1) return 0;
        dp=new int[res+1][res+1];
        for (int[]i:dp){
            Arrays.fill(i,-1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (dp[pre][curRes]!=-1)return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes]=1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes]=0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes]=ways;
        return ways;
    }

}

```

**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                for (int i = pre; i <= curRes; i++) {// 所有情况累加
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

**斜率优化**

- 枚举行为推导

![image-20211214220817010](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220817010.png)



```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        dp[res][res]=1;// 根据下一层退出结果，所以要先对最后一层就行添值
        for (int pre = res-1; pre >= 1; pre--) {// 前驱
            for (int curRes = pre ; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                dp[pre][curRes]=dp[pre+1][curRes]+dp[pre][curRes-pre];// 分析的关系
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

## bob活着

题目：**给定范围横向N，纵向M，从（i，j）开始走K步（只能上下左右走，且概率相同）没有超过给定范围那么就是活着，如果在过程中超过了范围则死了，返回活着的概率。**

**递归实现**

```
public class Main {

    public static int N, M;

    public static String process(int n, int m, int i, int j, int k) {
        N = n;
        M = m;
        int live = process(i, j, k);// 活着的情况
        int all = (int) Math.pow(4, k);// 一共存在的情况
        int gcb = gcb(all, live);// 求最大公约数
        return live / gcb + " / " + all / gcb;
    }

    private static int gcb(int m, int n) {
        if (n == 0) return m;
        return gcb(n, m % n);
    }

    // 计算活着的情况数
    public static int process(int i, int j, int K) {
        if (i < 1 || i > N || j < 1 || j > M) return 0;
        if (K == 0) return 1;
        return process(i + 1, j, K - 1) +
                process(i - 1, j, K - 1) +
                process(i, j + 1, K - 1) +
                process(i, j - 1, K - 1);
    }
}

```

**严格表结构**

```
class U {
    public static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    public static String bob2(int N, int M, int i, int j, int K) {
        int[][][] dp = new int[N + 2][M + 2][K + 1];  //x坐标，y坐标，还有几步没走到达
        //如果剩下0步的时候能走到row,col位置就是存活，否则就是死去了。
        for (int row = 1; row <= N; row++) {//初始化数据
            for (int col = 1; col <= M; col++) {
                dp[row][col][0] = 1;
            }
        }
        for (int rest = 1; rest <= K; rest++) {
            for (int row = 1; row <= N; row++) {
                for (int col = 1; col <= M; col++) {
                	//递归依赖
                    dp[row][col][rest] = dp[row - 1][col][rest - 1];
                    dp[row][col][rest] += dp[row + 1][col][rest - 1];
                    dp[row][col][rest] += dp[row][col - 1][rest - 1];
                    dp[row][col][rest] += dp[row][col + 1][rest - 1];
                }
            }
        }
        long all = (long) Math.pow(4, K);
        long live = dp[i + 1][j + 1][K];
        long gcd = gcd(all, live);
        return (live / gcd) + "/" + (all / gcd);
    }
}

```

## 数字转化成字母（树形）

![image-20211214220923610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220923610.png)

**递归实现**

- 时间复杂度为指数级

```
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```

**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。

- 时间复杂度为O(N)

  ```
  public class Main {
  	public static int process(String string) {
  		if (string == null || string.length() == 0) {
  			return 0;
  		}
  		if (string.length() == 1) {
  			return string == "0" ? 0 : 1;
  		}
  		char[] arr = string.toCharArray();
  		int N = arr.length;
  		int[] res = new int[arr.length + 1];
  		res[N] = 1;
  		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
  		for (int i = N - 2; i >= 0; --i) {
  			if (arr[i] == '0') {
  				res[i] = 0;
  			} else {
  				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
  					res[i] = res[i + 1];
  				} else {
  					res[i] = res[i + 1] + res[i + 2];
  				}
  			}
  		}
  		return res[0];
  	}
  }
  
  ```




## 数字转为字符串

![image-20211228093016742](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093016742.png)







## 字符串的全排列

![image-20211228093104568](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093104568.png)

1. 我们通常都思路都是将所有字符依次放在最前面，例如ABC，第一位为A，B,C，然后判断第二位，那么我们如何在字符串中标记该字符已经被我们安排在前面了？

2. 若我们使用下标的方式，那么在每次选择都会产生一个下标，这样会很乱。

3. 于是我们可以通过将欲放在前面的字符就直接放在前面（将字符一次和后面的交换），用一个下标指引我们前面已经定了多少的元素。

4. 但是若我们交换后在后续调用时，数据顺序已经打乱，我们可能会造成重复情况，所以我们在每次运行后再将数据交换变成原来位置。

5. 但是当数据有重复字符时，会出现重复的全排列，这是我们就要判断交换的字符是否和之前交换的相同，若相同，就不用交换

   ```java
   class Main {
   	public static List<String> list = new ArrayList<>();
   
   	public static void process(String string) {
   		char[] chars = string.toCharArray();
   		process(chars, 0);
   	}
   
   	private static void process(char[] chars, int i) {
   		if (i == chars.length) {// 结果
   			list.add(new String(chars));
   			return;
   		}
   		boolean[] isVisited = new boolean[26];// 默认只有大写字母
   		for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
   			if (!isVisited[chars[j] - 'A']) {// 是否重复
   				isVisited[chars[j] - 'A'] = true;
   				swap(chars, i, j);// 交换
   				process(chars, i + 1);// 递归
   				swap(chars, i, j);// 恢复
   			}
   		}
   	}
   
   	private static void swap(char[] chars, int i, int j) {
   		char c = chars[i];
   		chars[i] = chars[j];
   		chars[j] = c;
   	}
   }
   ```

   https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

   ```
   class Solution {
       List<String> res = new LinkedList<>();
       char[] c;
       public String[] permutation(String s) {
           c = s.toCharArray();
           dfs(0);
           return res.toArray(new String[res.size()]);
       }
       void dfs(int x) {
           if(x == c.length - 1) {
               res.add(String.valueOf(c));      // 添加排列方案
               return;
           }
           HashSet<Character> set = new HashSet<>();
           for(int i = x; i < c.length; i++) {
               if(set.contains(c[i])) continue; // 重复，因此剪枝
               set.add(c[i]);
               swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
               dfs(x + 1);                      // 开启固定第 x + 1 位字符
               swap(i, x);                      // 恢复交换
           }
       }
       void swap(int a, int b) {
           char tmp = c[a];
           c[a] = c[b];
           c[b] = tmp;
       }
   }
   ```

   

# 数组和字符串





## 组合硬币

一个硬币面值的组合，求出组合出给定金额最少的硬币数量。（这里的硬币应该不能重复选择）

版本一：

![image-20211214093158864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214093158864.png)





风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/236A5BAB3F15EC1CFE7543BC4AD930F5.jpg)

风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/679EB9A15ABE065485A2F0C6E4BCEB5C.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/F053027ABF6D72F8DA642609570B7F18.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/2652636A6206EFAC6C497FAD064A9C05.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8B8C6B0EC745DD699DDE0AB2F0560E34.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/1CD84ADF351B6BD4CD3B89469CDA68E7.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D764CDCB4B0138B2632C491A539C891.jpg)

风 21:57:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DF7DFA8B5B3FCE158CE3A8FB03048F00.jpg)

风 21:57:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0793EB962C13F0F83AB76AEF75E228A6.jpg)



## 最长递增子序列

![image-20220118225641094](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225641094.png)

- 贪心思想：从左向右的经典贪心，一直寻找对应位置序列前的最优位置。
- 每个位置前的最长子序列根据该位置前的数据的最长子序列得出，这样一来每个数位置对应的最长序列就会都依赖之前的数，也就是可以根据较小的数据个数推出较多数据的结果。



![image-20220118225702034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225702034.png)



![image-20220118225716109](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225716109.png)

![image-20220118225728920](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225728920.png)

### O（N^2）

```
public class Main {
	public static int process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] preMax = new int[arr.length];// 记录下标为i位置前最长序列。
		int resMax = 0;
		for (int i = 0; i < arr.length; i++) {
			int curMax = 0;// 计算当前i位置前序列最长的值，不包括arr[i]
			for (int j = i - 1; j >= 0; --j) {
				if (arr[j] < arr[i]) {
					curMax = Math.max(curMax, preMax[j]);// 更新最大值
				}
			}
			// 记录最大值
			preMax[i] = curMax + 1;
			// 更新整体最长序列
			resMax = Math.max(preMax[i], resMax);
		}
		return resMax;
	}
}

```



### 优化算法O（N*logN）



![image-20220118230704870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118230704870.png)

```java
public class Main {
	/**
	 * 之前我们取的是直接存储某位置之前所存在的最长序列的个数，时间复杂度为O(N^2)
	 * 该种方法，我们可以了解到，当前面的值有存在序列最长值大于等于其他值，并且该值较小
	 * 那么比该值大且前面的子序列个数还较少，这些值就不可能成为我们的最终选的结果。
	 * 
	 * 我们现在选择一种方式，就是抛弃上述过程中存在的这些值，用下标位置索引表示当前的子序列长度。复杂度O(N*logN)
	 * 就像indexIsMaxNumArr[maxNumIndex]表示：
	 * 前面存在最长子序列长度为maxNumIndex时，满足该条件下的最小值为indexIsMaxNumArr[maxNumIndex]
	 */
	public static int process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] indexIsMaxNumArr = new int[arr.length];
		int maxNumIndex = -1;// 存在最长长度索引
		for (int value : arr) {
			if (maxNumIndex == -1 || indexIsMaxNumArr[maxNumIndex] < value) {
				// 之前不存在值或者该值大于之前所有值，此时肯定比之前最长索引大1，所以maxNumIndex加上1
				indexIsMaxNumArr[++maxNumIndex] = value;
			} else {
				// 查找indexIsMaxNumArr[0…………maxNumIndex]范围中，值大于或等于value的最小值索引。
				int index = biggerThanValueLeftestIndex(indexIsMaxNumArr, value, maxNumIndex);
				// 更新该值
				indexIsMaxNumArr[index] = value;
			}
		}
		return maxNumIndex + 1;
	}

	/**
	 * 该函数在查找时总结过
	 * 
	 * @param indexIsMaxNumArr 数组
	 * @param value            目标值
	 * @param right            右端索引
	 * @return 值大于或等于value的最小值索引
	 */
	private static int biggerThanValueLeftestIndex(int[] indexIsMaxNumArr, int value, int right) {
		int left = 0;
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			if (indexIsMaxNumArr[med] == value) {
				return med;
			} else if (indexIsMaxNumArr[med] > value) {
				right = med;
			} else {
				left = med + 1;
			}
		}
		return right;
	}
}

```



## 数组中没有出现的数

![image-20220118234729600](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118234729600.png)





力扣原题

![image-20220118235433067](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235433067.png)













# 贪心算法

## 绳子覆盖问题

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/60e968bcb3e94c07b3d48db38b220c81.png)



#### 定右二分向左查找O(N*logN)

- 最主要还是二分的实现，**详见查找深度探索二分查找**

```java
public class Main {
	public static int process(int[] arr, int L) {
		if (arr == null || arr.length == 0 || L <= 0) {
			return 0;
		}
		int res = 1;
		for (int i = 0; i < arr.length; i++) {
			int index = bRNum(arr, i, arr[i] + L);
			res = Math.max(res, index - i + 1);
		}
		return res;
	}
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```



#### 滑动窗口的解法

```java
两个值，从左往右，一个是开始位置l，一个是右边界r，保证arr[r]-arr[l]>=L，记录下r-l+1的值
```



## 前后缀差点最大值

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/cacd1046d8a0429a996570d3eccc6007.png)

一般思路：数据预处理建立两个从左右两端的最值数组，再遍历求解。
极限贪心思维：直接获取最大值和左右两端的差值
两个最大值数中定存在一个整体的最大值。
在满足将最大值放在一左端，无论怎么选择, 右一半的最大值一定大于等于最右端的元素。所以右侧最值最小只能是最右边的元素。
在满足将最大值放在一右端时同理，只需要这两种情况下取最值即可。

```java 
public class Test {
    public static int num(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        int max=arr[0];
        for (int i = 1;i < arr.length; i++){
            max = Math.max( max, arr[i]);
        }
        return Math.max(max-arr[0],max-arr[arr.length-1]);
    }
}
```



子数组累计和最大值

## magic操作

![image-20211227234337115](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234337115.png)



需要将平均值大的集合里面，拿出去介于两个平均值的值的数字到平均值小的集合里面。
尽量拿靠近平均值小的数字移动。也就是拿最小的

![image-20211227234858672](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234858672.png)
![image-20211227235542296](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235542296.png)

![image-20211227235737178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235737178.png)


因为magic操作会将两个集合的平均值都变大，所以每个可以操作数之前的数可以不用在下一轮选数里面考虑了。

## 括号深度

![image-20211228000346795](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228000346795.png)



遇到（ count++，遇到）count--，count最大的值就是深度。



## 超级洗衣机

https://leetcode-cn.com/problems/super-washing-machines/



![image-20211229085418463](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229085418463.png)



![90f2d42ebf6e4514aa4ea839f36ec099](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/90f2d42ebf6e4514aa4ea839f36ec099.png)



![image-20211229091620577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229091620577.png)



因为每次只能放到相邻的位置，相当于分成两半以后，每次只能通过选定位置传送一件衣服到另一半。

```java
public class Test {
    public static int minPoint(int[] machines) {
        if (machines == null || machines.length == 0) return -1;
        int N = machines.length;
        int allSum = 0;
        for (int i : machines) {
            allSum += i;
        }
        if (allSum % N != 0) return -1;
        int average = allSum / N;
        int leftSum = 0;
        int res = 0;
        for (int i = 0; i < N; i++) {
            int leftRest = leftSum - average * i;
            int rightRest = (allSum - leftSum - machines[i]) - (N - 1 - i) * average;
            if (leftRest < 0 && rightRest < 0) {
                res = Math.max(res, Math.abs(leftRest) + Math.abs(rightRest));
            } else {
                res = Math.max(res, Math.max(Math.abs(leftRest), Math.abs(rightRest)));
            }
            leftSum += machines[i];
        }
        return res;
    }
}

```

## 找工作

![image-20220111230320313](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111230320313.png)



![image-20220111231245062](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111231245062.png)

```java
public class Test {
    public static int[] process(Job[] jobs, int[] ability) {
        Arrays.sort(jobs, (o1, o2) -> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money));
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(jobs[0].hard, jobs[0].money);
        Job j = jobs[0];
        // 将同 hard 情况下 money 最多的进入map
        for (Job job : jobs) {
            if (job.hard != j.hard && job.money > j.money) {
                j = job;
                map.put(j.hard, j.money);
            }
        }
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            // 小于或等于ability[i]的最大键值
            Integer key = map.floorKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }
    static class Job {
    	int hard;
    	int money;
	}
}

```



**java treemap_Java TreeMap floorKey（）方法与示例**

**floorKey()方法**用于返回小于或等于给定键元素(key_ele)的最大键元素(如果存在)，否则，当不存在该键元素时返回null。**floorKey()方法**是一种非静态方法，只能通过类对象访问，如果尝试使用类名称访问该方法，则会收到错误消息。



## 子数组累计和最大值



![image-20220117094756580](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117094756580.png)



![image-20220117213014775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117213014775.png)

```
public class Test {
    public static int maxLenNum(int[] arr){
        int max=Integer.MIN_VALUE;
        int cur=0;
        for (int i : arr) {
            cur+=i;
            max=Math.max(max,cur);
            cur=Math.max(cur, 0);
        }
        return max;
    }
}

```

## 子矩阵累计和最大值(压缩数组)

![image-20220117214128825](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214128825.png)



![image-20220117214111768](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214111768.png)



- 子矩阵往往考虑是否可以转换成字数组的问题，就是将多行转化成一行或者多列转化成多列
- 转化之后思考一维情况下的解决思路，看看是否能应用到矩阵中。
  求出

0-0行 0-1行 0-2行。。0-n行，1-1行1-2行。。。1-n行 ，2-2行。。。。n-n行，将这些区间行对应列的值加在一起成为一行，然后用上面的方法求出最大值，最终的最大值就是子矩阵的最大值

这是**行压缩的方法**

```java
public class Test {
    public static int maxAreaNum(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int cur;
        int[] sumArr;
        for (int i = 0; i != arr.length; i++) {
            sumArr = new int[arr[0].length];
            for (int j = i; j != arr.length; j++) {
                cur = 0;
                for (int k = 0; k != sumArr.length; k++) {
                    sumArr[k] += arr[j][k];
                    cur += sumArr[k];
                    max = Math.max(max, cur);
                    cur = Math.max(cur, 0);
                }
            }
        }
        return max;
    }
}

```

## 安路灯

![image-20220117233125057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117233125057.png)





- 一个简单的贪心思想，将路灯尽量安装在需要安装的第二个位置。

- ```java
  public class Test {
      public static int minNum(String s) {
          char[] arr = s.toCharArray();
          int minNum = 0;
          int index = 0;
          while (index < arr.length) {
              if (arr[index] == 'X') {
               //不点灯
                  index++;
              } else {
                   //这个位置需要点亮，前面都是亮的，因此可以放在这个位置，也可以放在这个位置的下一个。
                  minNum++;
                  if (index + 1 == arr.length) {
                      break;.
                    //下一个是x，就直接去下下一个看
                  } else if (arr[index + 1] == 'X') {
                      index += 2;
                  } else {
                      //下一个不是x，相当于是...或者..*，将灯放在第二个点，然后直接去下下下个位置，这个位置需要点亮，这个位置以前的都是亮的。
                      index += 3;
                  }
              }
          }
          return minNum;
      }
  }
  
  ```

- 



## 排序相邻最大差值

- 构造一个差值范围，使差值在该范围内的所有数据都放弃考虑，从减小了大量的情况。

![image-20220124224846491](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124224846491.png)

- 用分桶的方法，将n个数分到n+1个桶中，每个桶只记录最大值和最小值。用一个boolean数组记录桶里面是否有数字，一个数组记录最大值，一个数组记录最小值

- 然后挨个计算相邻桶的差值（后一个桶的最小值和前一个桶的最大值），求出最大值就是结果

- 尤其要注意看一个数字分去哪个桶的算法。
  n+1个桶，每个桶间隔的数字gap= (max-min)/n。

  数字a应该去哪个桶？ (a-min)/gap =(a-min)*len/(max-min)
  如果a==min,则该去0号桶。
  如果a == max，应该去len号桶，而不是len-1号桶。因此上面的三个数组都要创建(len+1)的长度才能切分。

风 22:47:30
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/21B1F7EE322861D11A11DF35E1C3B291.png)



![image-20220124225001279](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225001279.png)

![image-20220124225029666](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225029666.png)



```java
public class Main {
	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
		// 记录桶中是否存在值
		boolean[] hasNum = new boolean[len + 1];
		int[] maxs = new int[len + 1];
		int[] mins = new int[len + 1];
		int bid = 0;
        // 由于多一个桶，那么其中一个桶定为空，最大差值定比一个桶的范围大
        // 最大差值定比的两个数定在不同的桶中，选出每个桶中的最大值最小值
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max);// 该数应该在桶中的下标
			// 更新桶中的最大最小值
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = maxs[0];

		// 最大差值定存在于不同的桶中
		for (int i = 1; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];// 记录该桶的最大值，用于后续不同桶的最大差值的比较
			}
		}
		return res;
	}
	// 计算桶的下标索引
	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
}

```




![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/04030C2E7169D2A81FE489D649658BA0.png)



## 过河

![image-20220205201539832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205201539832.png)



- 贪心思想：将最小的和较大的放在一条上，若能就放一条上，否则让较大的自己一条。

- ![image-20220205205653104](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205205653104.png)

- ![image-20220205211557507](C:/Program%20Files/Typora/image-20220205211557507.png)

- ![image-20220205212541779](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212541779.png)
  ![image-20220205212639057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212639057.png)
  ![image-20220205223114248](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223114248.png)

- 

  ```java
  public class Main {
  	public static int minBo(int[] arr, int weight) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		Arrays.sort(arr);
  		if (arr[arr.length-1]>weight) {
  			return Integer.MAX_VALUE;
  		}
  		int left = 0;
  		int right = arr.length - 1;
  		int boatNum = 0;
  		while (left <= right) {
  			if (arr[right] + arr[left] <= weight) {
  				++left;
  			}
  			--right;
  			++boatNum;
  		}
  		return boatNum;
  	}
  }
  
  ```

  











# 打表法

- 出现和倍数相关的问题时，可以考虑通过一般方法解题后的结果是否存在某种特殊的规律，通过直观的答案直接进行代码的书写，不需要关注本质含义。

## 整体装袋



![image-20211219220615833](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219220615833.png)

**一般思路**

可以发现，超过6和8的最小公约数以后，构成的差值一直是3/5/1循环，超过24以后，也就是8的倍数，每个rest都可以映射到减去24的某个rest。

如果超过rest超过24以后，就没必要尝试试了，因为24是6和8的最小公倍数

107个苹果

107/8=13

8的包数 	rest	mod6余数  

13				3		3

12				11		5

11				19		1

10				27		3

9					35		5

8					43		1	

```
public class Main {
	public static int num(int apple) {
		if (apple % 8 == 0)
			return apple / 8;
		int n8 = apple / 8;
		int m = apple % 8;
		while (m < 24 && n8 >= 0) {
			if (m % 6 == 0)
				return n8 + m / 6;
			--n8;
			m += 8;
		}
		return -1;
	}
}

```





**打表代码**
![image-20211219232123273](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232123273.png)

- 18前无规律，18后单为-1，双为一个值，每增加8个就增加1

```
public class Main {
	public static int daBiao(int apple) {
		if (apple < 18)
			return apple == 0 ? 0
					: (apple == 6 || apple == 8) ? 1 
						: (apple == 12 || apple == 14 || apple == 16) ? 2 
							: -1;
		if (apple % 2 == 1)
			return -1;
		return (apple - 18) / 8 + 3;
	}
}

```

2*8=16

3*6=18

差值是2，当大于18以后，多的2可以通过这个转换转换为8或者6的袋子，因此奇数肯定不可能凑成，大于18的偶数可以凑成。

## 幂次方吃草

![image-20220324225613294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324225613294.png)

不是看谁吃得多，而是看谁最后吃不了剩下的草算输



```
public class Main {
	public static String winner(int N) {
		if (N <= 4)
			return N == 0 || N == 2 ? "羊羊" : "牛牛";
		int eatTest = 1;
		while (eatTest <= N) {
			if (winner(N - eatTest).equals("羊羊"))
				return "牛牛";
			eatTest *= 4;
		}
		return "羊羊";
	}
}

```

![image-20211219232823835](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232823835.png)

![image-20211219232220642](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232220642.png)



```
public static String win(int N){
    return (N)%5==0||(N)%5==2?"羊羊":"牛牛";
}

```





# 枚举

### 优化枚举方法

- 每次计算时出现重复的动作，我们就将这些操作在计算之前进行直接处理，在我们需要时直接进行数据的获取。



### 最小染色数

![image-20220308140350585](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220308140350585.png)



**枚举**

遍历每一个位置i，从0到length，i位置往右设置为G，i位置往左设置为R，则以i为边界。左边有个G就涂成R，右边有一个R，就涂成G，记录最小涂得数量

```java
public class Main {
	public static int process(String s) {
		char[] arr = s.toCharArray();
		int min = Integer.MAX_VALUE;
		int N = arr.length;
		for (int i = 0; i <= N; i++) {
			int num = 0;
			for (int j = 0; j < i; ++j) {
				if (arr[j] == 'G') {
					++num;
				}
			}
			for (int j = i; j < N; ++j) {
				if (arr[j] == 'R') {
					++num;
				}
			}
			min = Math.min(min, num);
		}
		return min;
	}
}

```

**优化枚举**

- 在我们枚举所有情况时发现：对于每次计算单方向上的G，R的个数均可以在之前的操作中部分求出，但是尽管我们之前已经部分求出，在每次计算的时候并没有得到充分应用，只是重复的计算单方向上R，G的个数，正式因为这些重复的计算，造成我们时间效率上有巨大的提升空间。

leftSum 记录每个位置（包含）左边有几个G，

rightSum 记录每个位置（包含）右边有几个R

```java
public class Main {
	public static int process(String s) {
		char[] arr = s.toCharArray();
		int N = arr.length;
		int[] leftSum = new int[N];
		leftSum[0] = arr[0] == 'G' ? 1 : 0;
		// 左累加
		for (int i = 1; i < N; i++) {
			leftSum[i] = leftSum[i - 1] + (arr[i] == 'G' ? 1 : 0);
		}
		int[] rightSum = new int[N];
		// 右累加
		rightSum[N - 1] = arr[N - 1] == 'R' ? 1 : 0;
		for (int i = N - 2; i >= 0; i--) {
			rightSum[i] = rightSum[i + 1] + (arr[i] == 'R' ? 1 : 0);
		}
		// 根据累加计算最小值，注意这时代交错相加。也就是把所有的都涂成R或者G时候需要涂几个
		int min = Math.min(leftSum[N - 1], rightSum[0]);
		for (int i = 1; i < N; i++) {
			min = Math.min(min, leftSum[i - 1] + rightSum[i]);
		}
		return min;
	}
}

```









### 矩阵最大正方形

![image-20211221215153594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211221215153594.png)

- 还是若我们直接对于单个起始位置寻找，对于每个其实位置进行判断的话时间复杂度就会比较高
- 由此我们要单向记录连续1的个数

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(maxLen(new int[][]{
        		{0, 1, 1, 1, 1, 1},
                {0, 1, 0, 0, 1, 1},
                {0, 1, 0, 0, 1, 0},
                {1, 1, 1, 1, 1, 1},
                {0, 1, 0, 1, 1, 1}}));
    }

    public static void show(int[][] a) {
        for (int[] aa : a) {
            System.out.println(Arrays.toString(aa));
        }
        System.out.println();
    }

    public static int maxLen(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        show(arr);
        
        //*******************生成向横向的累计连续数值******************
        int[][] rightArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = arr[0].length - 1; j >= 0; j--) {
                rightArr[i][j] = arr[i][j] == 0 ? 0 : j == arr[0].length - 1 ? 1 : rightArr[i][j + 1] + 1;
            }
        }
        show(rightArr);

        //*******************生成向纵向的累计连续数值******************
        int[][] downArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < arr[0].length; i++) {
            for (int j = arr.length - 1; j >= 0; j--) {
                downArr[j][i] = arr[j][i] == 0 ? 0 : j == arr.length - 1 ? 1 : downArr[j + 1][i] + 1;
            }
        }
        show(downArr);

        //*************************从小到大看看多大的正方形存在**************************8
        for (int size = Math.min(arr.length, arr[0].length); size != 0; size--) {
            if (hasSizeOfBorder(size, rightArr, downArr)) {
                return size;
            }
        }
        return 0;
    }

    private static boolean hasSizeOfBorder(int size, int[][] rightArr, int[][] downArr) {
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = 0; j < rightArr[0].length; j++) {
                if (rightArr[i][j] >= size && downArr[i][j + size - 1] >= size &&
                        downArr[i][j] >= size && rightArr[i + size - 1][j] >= size)
                    return true;
            }
        }
        return false;
    }
}

```

![image-20220310231519666](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220310231519666.png)







### 括号字符

![image-20211227233419037](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233419037.png)

![image-20211227233649531](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233649531.png)





### 差值为k的去重数字对

![image-20211227233908870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233908870.png)



使用hashset记录每个元素，然后遍历arr，找个一个数，加上k看这个值在不在hashset里面，在的话就加1。











# 业务题

## 被3整除的数的个数

![image-20220118233659667](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118233659667.png)





```

```

# 查找

## 深度探索二分查找

- **注意med的取法和R或L的调整方式**

### 经典二分查找



```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```

### 查找大于该值的最小值

```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med;
			}
		}
		return L;
	}
}

```

### 查找大于等于目标值的最右值

```
public class Main {
	// 返回大于等于target的最右元素
    private int rightest(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] == target) left = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

### 查找小于该值的最大值

````
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

````

### 查找小于等于目标值的最左值

```
class Main {
	// 返回小于等于target最左元素
    private int leftest(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

## 查找极小值

题目：
极值定义该值比左右的值都小，如果是在数组两侧则只比较一点即可。
在无序数组中找到该极小值。

```
public class Main {
	private static Integer process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int N = arr.length;
		if (N == 1) {
			return arr[0];
		}
		// 最左侧
		if (arr[0] < arr[1]) {
			return arr[0];
		}
		// 最右侧
		if (arr[N - 1] < arr[N - 2]) {
			return arr[N - 1];
		}
		int left = 1;
		int right = N - 2;
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			// right=med+1和left=med这种情况是在判断条件为arr[med]>arr[med-1]时
			if (arr[med] < arr[med + 1]) {
				right = med;
			} else {
				left = med + 1;
			}
		}
		return arr[left];
	}
}

```



## 无序数组中第k大的值



类似的题目

[剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode-cn.com/problems/xx4gT2/)

bfprt

![image-20220209092642502](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209092642502.png)





![image-20220209094413363](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094413363.png)





![image-20220209094455765](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094455765.png)

![image-20220209094748264](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094748264.png)
![image-20220209094913219](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094913219.png)






## 两个有序数组寻找第k大的值

![image-20220125233334064](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125233334064.png)





### 归并排序子过程O(logk)

### 二分判定O(log(m)*log(n))

### O(log(min{n,m}))

```
public class Test {
    public static int findKthNum(int[] arr1, int[] arr2, int kth) {
        if (arr1 == null || arr2 == null) {
            throw new RuntimeException("Your arr is invalid!");
        }
        if (kth < 1 || kth > arr1.length + arr2.length) {
            throw new RuntimeException("K is invalid!");
        }
        int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
        int[] shorts = arr1.length < arr2.length ? arr1 : arr2;
        int l = longs.length;
        int s = shorts.length;
        if (kth <= s) {
            return getUpMedian(shorts, 0, kth - 1, longs, 0, kth - 1);
        }
        if (kth > l) {
            if (shorts[kth - l - 1] >= longs[l - 1]) {
                return shorts[kth - l - 1];
            }
            if (longs[kth - s - 1] >= shorts[s - 1]) {
                return longs[kth - s - 1];
            }
            return getUpMedian(shorts, kth - l, s - 1, longs, kth - s, l - 1);
        }
        if (longs[kth - s - 1] >= shorts[s - 1]) {
            return longs[kth - s - 1];
        }
        return getUpMedian(shorts, 0, s - 1, longs, kth - s, kth - 1);
    }

    public static int getUpMedian(int[] a1, int s1, int e1, int[] a2, int s2,
                                  int e2) {
        int mid1 = 0;
        int mid2 = 0;
        int offset = 0;
        while (s1 < e1) {
            mid1 = (s1 + e1) / 2;
            mid2 = (s2 + e2) / 2;
            offset = ((e1 - s1 + 1) & 1) ^ 1;
            if (a1[mid1] > a2[mid2]) {
                e1 = mid1;
                s2 = mid2 + offset;
            } else if (a1[mid1] < a2[mid2]) {
                s1 = mid1 + offset;
                e2 = mid2;
            } else {
                return a1[mid1];
            }
        }
        return Math.min(a1[s1], a2[s2]);
    }
}

```



# 其他

## 1 比较器

```
  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }
```



你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 2 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2



## 求解最小公倍数





## 二分法

查找一个数组元素的下标。
二分法适用于已经排好序的数组，定义两个变量，一个low,一个high,则mid=(low+high)/2

算法核心：
如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;

如果 value<arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;

如果 value>arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;

```
import java.util.Arrays;
 
/**
 * 测试二分法查找
 * 二分法适用于已经排好序的数组
 * @author Administrator
 *
 */
public class TestBinarySearch {
	public static void main(String[] args) {
		int[] arr= {30,20,50,10,80,9,7,12,100,40,8};
		Arrays.sort(arr);
		System.out.println(Arrays.toString(arr));
		System.out.println(myBinarySearch(arr,40));
		}
	
	public static int myBinarySearch(int[] arr,int value) {
		int low=0;
		int high=arr.length-1;
		while(low<=high) {
			int mid=(low+high)/2;
			if(value==arr[mid]) {
				return mid;
				}
			if(value>arr[mid]) {
				low=mid+1;	
			}
			if(value<arr[mid]) {
				high=mid-1;
			}
			
		}
		return -1;//没有找到返回-1
	}
	
}
```

## [关于二分法 查找的边界问题，大于等于目标值的最小值，小于等于目标值的最大值。](https://www.cnblogs.com/welen/articles/9984058.html)

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/12
 * @Version 1.0
 **/
public class binary {
    public static void main(String[] args) {
        int a[]={1,3,5,7,9,12,43,56,67,78};
        System.out.println(binary_search_upperbound(a,10,3));
        System.out.println(binary_search_lowerbound(a,10,56));
    }
    static int binary_search_upperbound(int a[], int n, int key){

        if(key>=a[n-1]) return -1;//如果是大于等于key的第一个值，则此处改为>

        int low,high,mid;
        low=0;
        high=n-1;
        mid=(low+high)/2;
        while(low<high){
            if(key<a[mid])//如果是大于等于key的第一个值，则此处改为<=
                high=mid;
            else
                low=mid+1;
            mid=(low+high)/2;
        }
        System.out.println(mid==high? "YES":"No");// mid是等于high的
        return a[mid];
    }

    // 查找小于key的第一个值
    static int binary_search_lowerbound(int a[], int n, int key){
        if(key<=a[0]) return -1;//如果是大于等于key的第一个值，则此处改为<
        int low,high,mid;
        low=0;
        high=n-1;
        mid=(low+high+1)/2;
        while(low<high){
            if(key>a[mid])//如果是大于等于key的第一个值，则此处改为>=
                low=mid;
            else
                high=mid-1;
            mid=(low+high+1)/2; //如果不加1，会有死循环
        }
        System.out.println((mid==low? "YES":"No"));
        return a[mid];
    }
}

```





```java
int a[10] = { 1, 4, 5, 3, 2, 1, 2, 3, 4, 2 };
sort(a, a + 10);
//sort(a,a+10,cmp);
int x;
 
 
 
while (scanf("%d", &x) != EOF)
{
     
    for (int i = 0; i<10; i++)
        printf("%d ", i);
    printf("\n");
    for (int i = 0; i<10; i++)
        printf("%d ", a[i]);
    printf("\n");
    int flag = 1;
    int less_last_mid = -1;
    int low = 0, high = 9, mid;
 
    while (low <= high)//循环必须包括等于，因为只有包括等于，才会把low,high数据都访问一遍。
    {
     
            //在查找指定目标值时，可能漏掉
            //例如，倒数第二步时，low, high=low+1；mid取floor((low+high)/2)=low，只把low访问到了，可能漏掉high没有访问到，下次就是(mid偏小，漏掉)<br>                //low=mid+1或者(mid偏大)high=mid-1(high<low);即
 
            //high<-mid->low
            //low  high
            //如果只是查找目标值，只需要比较等于即可。
 
            //如果要查找到大于等于目标值的最小值，应该就是high的最后位置，因为high一开始就是大于等于目标值，直到high向左移动的最后的位置，如果high最终的位置比目标值还要小，
            //则查找不到。
 
            //同样地，如果查找小于等于目标值的最大值，应该就是low的最后位置，如果low的最终位置比目标值还要大，则查找不到。<br>
            //如果要找到小于x的最大值，则
            //最后一步,flag=0时，flag=1时的最后一次mid，即less_last_mid为x最终的值
            //如果flag = 1时， 保存最后一次mid即可,即data[less_last_mid]
            //另外就是越界，找不到
        mid = (low + high) / 2;
        if (a[mid] < x)//如果1：要找的是小x的最大值;
 
        {//如果2：要找的是小于等于x的最大值; if (a[mid] <= x)
 
            less_last_mid = mid;
            low = mid + 1;
            flag = 1;//假设最后一步，走在这里，变成了low>high这个无理的条件，这是因为Low的变化造成的，所以low的值已无法使用
        }
 
        else
        {
            high = mid - 1;
            flag = 0;//假设最后一步，走在这里，变成了low>high这个无理的条件，这是因为high的变化造成的，所以high的值已无法使用
        }
    }
    if (flag)
    {//肯定存在
        printf("flag=0:%d\n", a[less_last_mid]);
    }
    else//可能不存在,调整high左移
    {
        if (high >= 0)
        {
            printf("flag=0:%d\n", a[less_last_mid]);
        }
        else
        {
            printf("不存在\n");
        }
    }
}
```



## 快速排序





## 利用二分法寻找最某个值或者最大于某个值的最小值



```
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
```



## 判定数字某位二进制的值是不是1



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



## 自定义大顶堆&小顶堆





大顶堆

```
  PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });


```

插入元素  `  pq.offer(new int[]{nums[i], i});`

查看堆顶元素 `pq.peek()[1] <= i - k`

弹出堆顶元素 `pq.poll()`



***（优先队列）***:默认是小顶堆

```
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        heap.add(3);
        heap.add(2);
        heap.add(5);
        while (!heap.isEmpty()){
            System.out.println(heap.poll());
        }
        
2
3
5

```







## 双端队列

定义：`Deque<Integer> deque = new LinkedList<Integer>();`

当队列使用：
				尾部弹出 ` deque.pollLast();`

​		查看尾部元素`deque.peekLast()`	

​		查看头部元素 `deque.peekFirst()`

​		尾部插入 ` deque.offerLast(i);`





## 二分法查找值大于或等于value的最小值索引

```
	/**
	 * 该函数在查找时总结过
	 * 
	 * @param indexIsMaxNumArr 数组
	 * @param value            目标值
	 * @param right            右端索引
	 * @return 值大于或等于value的最小值索引
	 */
	private static int biggerThanValueLeftestIndex(int[] indexIsMaxNumArr, int value,int left, int right) {
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			if (indexIsMaxNumArr[med] == value) {
				return med;
			} else if (indexIsMaxNumArr[med] > value) {
				right = med;//这里不能等于med-1，因为有可能med-1的位置就小于value的值了，只要等于med就行。普通的二分法可以这么做
			} else {
				left = med + 1;
			}
		}
		return right;
	}
```

## Long的范围

Long.MIN_VALUE;

```
public class test {
    public static void main(String[] args) {
        System.out.println(1);
        long a = 1L;
        int b =2;
        long c = b;
        System.out.println(c);
        System.out.println(a+b);
    }
}
```



 double inorder = -Double.MAX_VALUE;



# 整体思想

### [ 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)



### 旋转字符串

![image-20220107001832841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001832841.png)

- 一般思路：尝试所有的情况，看是否存在相同的
- 优化思路：见代码

```
public class Test {
    public static boolean isRoa(String s,String r){
        if (s.length()!=r.length())return false;
        String ss= s + s;
        return ss.contains(r);
    }
}

```





### zigzag方式打印矩阵

![image-20211229093821968](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229093821968.png)

- 只关注单趟循环，分离宏观控制和循环过程

- ```java
  public class Main {
  	public static void print(int[][] arr) {
  		int N = arr.length - 1;
  		int M = arr[0].length - 1;
  		int firstRow = 0, firstLine = 0, secondRow = 0, secondLine = 0;
  		boolean flag = false; // 控制打印方向
  		while (secondLine != M + 1) {
  			print(arr, firstRow, firstLine, secondRow, secondLine, flag);
  			if (firstLine != M)
  				firstLine++;
  			else
  				firstRow++;
  			if (secondRow != N)
  				secondRow++;
  			else
  				secondLine++;
  			flag = !flag;
  		}
  	}
  
  	private static void print(int[][] arr, int firstRow, int firstLine, int secondRow, int secondLine, boolean flag) {
  		if (flag) {
  			while (firstLine >= secondLine) {
  				System.out.print(arr[firstRow++][firstLine--] + " ");
  			}
  		} else {
  			while (secondLine <= firstLine) {
  				System.out.print(arr[secondRow--][secondLine++] + " ");
  			}
  		}
  	}
  }
  
  ```

  ### 

  ### 



### 90度旋转

https://leetcode-cn.com/problems/rotate-matrix-lcci/submissions/



![image-20211230000012145](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230000012145.png)

1.先水平翻转，再根据主对角线翻转得到：

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

。
```

2.原地旋转

一组四个对角转一下，借助一个临时变量就够了



```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}

```

https://pic.leetcode-cn.com/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif

![194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif)

3.暴力方法

`对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。`

![image-20211230001116999](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230001116999.png)

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] matrix_new = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
    }
}

```







# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623



# git time out 问题

取消代理

```

取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy

```

 OpenSSL SSL_read: Connection was reset, errno 10054



ipconfig /flushdns cmd中执行一下再试试

执行完再打开git就好了

