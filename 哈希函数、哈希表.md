



# 位运算

## ^运算符理解

- ^ 可理解为不进位相加

- a^a=0

- a^0=a

  ```
  public static void sway(int[] arr,int i,int j){
  	if(i!=j){
  		//不能两个值指向同一地址
  	    arr[i]=arr[i]^arr[j];
  	    arr[j]=arr[i]^arr[j];//就是arr[i]^arr[j]^arr[j]就表示a
  	    arr[i]=arr[i]^arr[j];//表示arr[i]^arr[j]^arr[i]^arr[j]^arr[j]就是b
      }
  }
  
  ```

  ## 寻找出现双中的单数

  题目：一组数只有一个数出现一次，其他出现两次，找出这个出现一次的数

```
public class Main {
	private static int process(int[] arr) {
		int res = 0;
		for (int i : arr) {
			res ^= i;
		}
		return res;
	}
}

```

## 取出一个数最右边1的位置



```
int mostRightOne = pos & (~pos + 1); 
// mostRightOne值在二进制位上的位次就是pos得最右第一个1的位置

```

60 = 0011 1**1**00

-61 = 1100 0011

-60+1 = 1100 0100

60&(-60+1)=0000 0**1**00
得出答案



下表列出了位运算符的基本运算，假设整数变量 A 的值为 60 和变量 B 的值为 13：

| 操作符 | 描述                                                         | 例子                           |
| :----- | :----------------------------------------------------------- | :----------------------------- |
| ＆     | 如果相对应位都是1，则结果为1，否则为0                        | （A＆B），得到12，即0000 1100  |
| \|     | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011 1101 |
| ^      | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011 0001  |
| 〜     | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         | （〜A）得到-61，即1100 0011    |
| <<     | 按位左移运算符。左操作数按位左移右操作数指定的位数。         | A << 2得到240，即 1111 0000    |
| >>     | 按位右移运算符。左操作数按位右移右操作数指定的位数。         | A >> 2得到15即 1111            |
| >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 | A>>>2得到15即0000 1111         |

```
public class Test {
  public static void main(String[] args) {
     int a = 60; /* 60 = 0011 1100 */ 
     int b = 13; /* 13 = 0000 1101 */
     int c = 0;
     c = a & b;       /* 12 = 0000 1100 */
     System.out.println("a & b = " + c );
 
     c = a | b;       /* 61 = 0011 1101 */
     System.out.println("a | b = " + c );
 
     c = a ^ b;       /* 49 = 0011 0001 */
     System.out.println("a ^ b = " + c );
 
     c = ~a;          /*-61 = 1100 0011 */
     System.out.println("~a = " + c );
 
     c = a << 2;     /* 240 = 1111 0000 */
     System.out.println("a << 2 = " + c );
 
     c = a >> 2;     /* 15 = 1111 */
     System.out.println("a >> 2  = " + c );
  
     c = a >>> 2;     /* 15 = 0000 1111 */
     System.out.println("a >>> 2 = " + c );
  }
} 
```

以上实例编译运行结果如下：

```
a & b = 12
a | b = 61
a ^ b = 49
~a = -61
a << 2 = 240
a >> 2  = 15
a >>> 2 = 15
```

### [java运算符 与（&）、非（~）、或（|）、异或（^）](https://www.cnblogs.com/jpfss/p/11014780.html)

1.十进制转二进制

原理：给定的数循环除以2，直到商为0或者1为止。将每一步除的结果的余数记录下来，然后反过来就得到相应的二进制了。

比如8转二进制，第一次除以2等于4（余数0），第二次除以2等于2（余数0），第三次除以2等于1（余数0），最后余数1，得到的余数依次是0 0 0 1 ，

反过来就是1000，计算机内部表示数的字节长度是固定的，比如8位，16位，32位。所以在高位补齐，java中字节码是8位的，所以高位补齐就是00001000.

写法位（8）10=（00001000）2；

```
package sourceCode.hashMap;

public class mapHashCodeTest {
    public static void main(String[] args) {
        String str = toBinary(8);
        System.out.println(str);
    }

    static String toBinary(int num) {
        String str = "";
        while (num != 0) {
            str = num % 2 + str;
            num = num / 2;
        }
        return str;
    }

}
```

运行结果：1000

2.二进制转十进制

计算也很简单，比如8的二进制表示位00001000，去掉补齐的高位就是1000.此时从个位开始计算2的幂（个位是0，依次往后推）乘以对应位数上的数，然后得到的值想加

于是有了，（2的0次幂）*0+（2的1次幂）*0+（2的2次幂）*0+（2的3次幂）*1 = 8

代码实现，直接调用Integer.parseInt("",2);

```
1 System.out.println(Integer.parseInt("1000",2));
```

运行结果：8

3.位异或运算（^）

运算规则是：两个数转为二进制，然后从高位开始比较，如果相同则为0，不相同则为1。

比如：8^11.

8转为二进制是1000，11转为二进制是1011.从高位开始比较得到的是：0011.然后二进制转为十进制，就是Integer.parseInt("0011",2)=3;

 

延伸：

4.位与运算符（&）

运算规则：两个数都转为二进制，然后从高位开始比较，如果两个数都为1则为1，否则为0。

比如：129&128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000000，即128.

 

5.位或运算符（|）

运算规则：两个数都转为二进制，然后从高位开始比较，两个数只要有一个为1则为1，否则就为0。

比如：129|128.

129转换成二进制就是10000001，128转换成二进制就是10000000。从高位开始比较得到，得到10000001，即129.

 

**6.位非运算符（~）**

运算规则：如果位为0，结果是1，如果位为1，结果是0.

比如：~37

在Java中，所有数据的表示方法都是以补码的形式表示，如果没有特殊说明，Java中的数据类型默认是int,int数据类型的长度是8位，一位是四个字节，就是32字节，32bit.

8转为二进制是100101.

补码后为： 00000000 00000000 00000000 00100101

取反为：  11111111 11111111 11111111 11011010

因为高位是1，所以原码为负数，负数的补码是其绝对值的原码取反，末尾再加1。

因此，我们可将这个二进制数的补码进行还原： 首先，末尾减1得反码：11111111 11111111 11111111 11011001 其次，将各位取反得原码：

00000000 00000000 00000000 00100110，此时二进制转原码为38

所以~37 = -38. 



## 找所有双出现中的两个单数

题目：一组数只有两个数出现一次，其他出现两次，找出这两个数：

- 因为两个值不同，所以两个值定存在二进制某一位定不同，用这两个值的异或结果二进制中的1，从而将数字分成两组，该位为1和不为1

```java
public class Main {
	private static void process(int[] arr) {
		int med = 0;
		for (int a : arr) {
			med ^= a;// 两个不同的单数^最后得到med
		}
		int rightOne = med & (~med + 1);// 取出med中二进制为1的位值（必存在，因为不同值）
		int med1 = 0;
		for (int a : arr) {
			// 对应位为1的值取出进行^最后的到两个单数对应位为1的
			// (a&rightOne)== 0得到对应位为0
			if ((a & rightOne) == rightOne) {
				med1 ^= a;
			}
		}
		System.out.println(med1);// 两个单数其中一个值
		System.out.println(med ^ med1);// 两个单数令一个值
	}
}

```

## 整数二进制奇数位偶数位交换

题目 : 例如：010110—>101001

```
public class Main {
	private static int process(int pos) {
		int pre = 0xAAAAAAAA; // 1010 1010 1010 1010 1010 1010 1010 1010 
		int post = 0x55555555; // 0101 0101 0101 0101 0101 0101 0101 0101 
		pre &= pos;
		post &= pos;
		pre >>= 1;
		post <<= 1;
		return pos + post;
	}
}

```



## 数组中全部出现k次返回出现一次的数

题目：给定一个整数数组，只有一个数出现了一次，其他数字均出现了三次，输出这一个只出现一次的数。

- 只看出现三次到数字，那么对于这些值的二进制位的累加和定能被3整除。
- 现在出现了一个只出现一次的数，由于该数的存在，所有二进制位累加和除以3的余数就是该值的对应二进制位数。
- 除了3，主要是大于等于2都可以这样做。

```
public class Main {
	public static int twoSingleNum(int[] arr) {
		int[] bit = new int[32];// 每一位求和
		for (int a : arr) {
			int b = 1;
			for (int i = 31; i >= 0; --i) {
				if ((a & b) != 0) {// 为1就累加
					++bit[i];
				}
				b <<= 1;// 换位
			}
		}
		int res = 0;
		for (int i = 0; i < 32; ++i) {
			res = res << 1;
			res += (bit[i] % 3);// 取余数
		}
		return res;
	}
}

```





# 链表

## 判读链表元素是否回文

### 利用栈结构

- 先遍历后全部入栈，然后再遍历和栈中元素依次比较。

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Stack<Node> stack = new Stack<>();
		Node tail = header;
		while (tail != null) {
			stack.push(tail);
			tail = tail.next;
		}
		tail = header;
		while (tail != null) {
			if (stack.pop().value != tail.value) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```

### 利用栈结构和快慢指针

- 先用快慢指针定位中间位置，然后继续运动慢指针依次和栈中元素进行比较。需要注意链表整体的个数是双是单。

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Node slow = header;
		Node quick = header;
		Stack<Node> stack = new Stack<>();
		while (quick.next != null && quick.next.next != null) {
			stack.push(slow);
			slow = slow.next;
			quick = quick.next.next;
		}
		// 此时若整个链表为双数，slow指向上一半的最后一个，需要入栈slow
		// 若为单数，指向中间元素，不需要入栈slow
		// 单双数的判断由quick的终止条件确定
		if (quick.next!=null) {
			stack.push(slow);
		}
		slow = slow.next;
		while (!stack.isEmpty()) {
			if (slow.value != stack.pop().value) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```



### 快慢指针和链表反向

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return false;
		}
		Node slow = header;
		Node quick = header;
		while (quick.next != null && quick.next.next != null) {
			slow = slow.next;
			quick = quick.next.next;
		}
		slow=slow.next;
		Node preNode=null;
		Node postNode=null;
		// 后半段反转
		while (slow!=null) {
			preNode=slow.next;
			slow.next=postNode;
			postNode=slow;
			slow=preNode;
		}
		Node tailLeft=header;
		Node tailRight=postNode;
		boolean flag=true;
		// 两边向中间判断
		while (tailRight!=null) {
			if (tailLeft.value!=tailRight.value) {
				flag=false;
				break;
			}
			tailLeft=tailLeft.next;
			tailRight=tailRight.next;
		}
		Node tailNode=null;
		// 后半段链表恢复
		while (postNode!=null) {
			preNode=postNode.next;
			postNode.next=tailNode;
			tailNode=postNode;
			postNode=preNode;
		}
		return flag;
	}

	public static class Node {
		int value;
		Node next;
	}
}

```







空间复杂度为o(1)
快慢指针,从终点开始，将后半段翻转，然后用头尾节点遍历开始比对

```
node node1 = head;
node node2 = head;
while(node2.next!=null&&node2.next.next!=null){
  node1=node1.next;
  node2=node2.next.next;
}

```

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142095356-102e2456-154b-4a69-8741-8297cc0df337.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142095813-184c2d8a-b460-4225-94a6-03832ea7fa52.png)



## 三分链表

给定一个值，将比该值小的节点放左边，大的放右边

借助六个变量。分别是小于基准节点的子链表头尾节点、大于的头尾、等于的头尾。然后合并小于和等于的部分。然后分别对两个子链表递归执行以上操作。返回以后就合并两个子链表。基本跟快拍的操作一致。

- 该题并不是思维上难点，主要是注意边界条件

```java
class SEL{
    public static Node sEL(Node header,int pivot){
        Node head_1=null;
        Node tail_1=null;
        Node head_2=null;
        Node tail_2=null;
        Node head_3=null;
        Node tail_3=null;
        Node nextNode=null;
        while (header!=null){
            nextNode=header.next;
            header.next=null;
            if (header.num<pivot){
                if (head_1==null){
                    head_1=header;
                    tail_1=header;
                }else { 
                    tail_1.next=header;
                    tail_1=tail_1.next;
                }
            }else if (header.num==pivot){
                if (head_2==null){
                    head_2=header;
                    tail_2=header;
                }else {
                    tail_2.next=header;
                    tail_2=tail_2.next;
                }
            }else {
                if (head_3==null){
                    head_3=header;
                    tail_3=header;
                }else {
                    tail_3.next=header;
                    tail_3=tail_3.next;
                }
            }
            header=nextNode;
        }
        if (tail_1==null){
            if (tail_2==null){
                return head_3;
            }else {
                tail_2.next=head_3;
                return head_2;
            }
        }else {
            if (tail_2==null){
                tail_1.next=head_3;
            }else {
                tail_1.next=head_2;
                tail_2.next=head_3;
            }
            return head_1;
        }
    }
	public static class Node {
		int value;
		Node next;
	}
}

```







## 用快排的思想实现单链表的排序



## 复制带rand指针的单链表，要求空间复杂度01





![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204359-3b6bd820-aa26-421d-8915-1c57cb0e0c44.png)

将复制的节点直接连在原来节点的后面，然后执行复制节点的rand节点的指向操作。然后去掉老节点就是新的复制的链表，
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204315-a050c13c-f9b3-4507-b91d-96454758b0c9.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142203370-5b7792a7-ff35-498e-8c26-ffbb7177ca83.png)



## 判断单链表是否有环

判断链表是否有环，若有返回第一个入环节点

流程：一开始快慢指针都在开始节点处。快指针走两步，慢指针走一步。然后一直走。如果相遇，快指针回到开始节点处，开始走一步，慢指针也走一步，下一次相遇的时候就是环的入口。

慢:1 快:2
若慢:1快3：
都入环时相差奇数步，且环节点数量为偶数则永不相交,都入环时相差奇数步说明每次差值减少2步，定在第一轮反超，此时差 环节点个数-1，若该值仍为奇数，那么第二轮也反超，故永不相遇

流程：一开始快慢指针都在开始节点处。快指针走两步，慢指针走一步。然后一直走。如果相遇，快指针回到开始节点处，开始走一步，慢指针也走一步，下一次相遇的时候就是环的入口。
 通过计算a和b走的位置可以推导出来。

```
    private static Node hasCircle(Node header){
        if (header==null)return null;
        boolean flag=false;
        Node slow=header;
        Node quick=header;
        //
        // 有环肯定会相遇
        while (quick.next!=null&&quick.next.next!=null){
            slow=slow.next;
            quick=quick.next.next;
            if (slow==quick){//判断是否却有环
                flag=true;
                break;
            }
        }
        if (!flag)return null;
        quick=header;
        while (quick!=slow){//相遇时将其中一个指针指向header走相同的步数定在入环节点相遇
            quick=quick.next;
            slow=slow.next;
        }
        return quick;
    }
```





## 链表环问题	







 ![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142207642-041fc64c-815b-4c76-9b94-c4006bf3a1fc.png)










## 两个单链表相交的问题

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142204613-79d522e5-27e2-4b7d-8835-b3b9a72f6109.png)

1.先根据上面的方法判断两个链表有没有环。
2如果两个链表都没有环的话，则说明两个单链表要么没有相交，要么尾部的一小段是公共部分。
 这个时候就分别遍历两个链表，记录长度和尾结点，看一下尾结点的内存地址是不是同一个，如果不是同一个，则肯定不想交。
 如果是同一个，就根据两个链表的长度，长的先走到剩余长度一致的节点，然后一起遍历，直到找到内存地址一样的节点，这个就是相交部分第一个节点。

3.如果一个有环一个无环，则不可能相交的。
4.如果两个都有环：
  ![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142335167-abff9244-c9d5-4aac-9c56-c5a22e371a70.png)
  通过上面的方法我们可以拿到两个环的入环位置。如果相等，则变成了2的方法找相交部分。
  如果不相等，就要区分一下图中1和3两种情况：
 让loop1继续往下走，直到转了一圈。
     - 如果能遇到loop2就是3的情况，相交，返回loop1或者loop2都可以，都算相交的节点。
          - 如果遇不到loop2就是1的情况。 不想交


![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142336010-5d834c73-3d6a-476f-808f-f1582a387e9c.png)







```java
class List{
    /*
    有环：
            1.同环：
                - 入环节点相同  返回相交节点
                - 入环节点不同  返回其中一个入环节点
            2.不同环：
                - 返回null
     无环：
            1.相交：
                - 返回相交节点
            2.不相交：
                - 返回null
     */
    public static Node getIntersectNode(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node loop1 = hasCircle(head1);
        Node loop2 = hasCircle(head2);
        if (loop1 == null && loop2 == null) {
            return noLoop(head1, head2);//无环，判断是否为链式相交或不相交
        }
        if (loop1 != null && loop2 != null) {
            return bothLoop(head1, loop1, head2, loop2);//有环，返回相交节点
        }
        return null;//一有环，一无环必定不相交
    }


    private static Node hasCircle(Node header){
        if (header==null)return null;
        boolean flag=false;
        Node slow=header;
        Node quick=header;
        while (quick.next!=null&&quick.next.next!=null){
            slow=slow.next;
            quick=quick.next.next;
            if (slow==quick){//判断是否却有环
                flag=true;
                break;
            }
        }
        if (!flag)return null;
        quick=header;
        while (quick!=slow){//相遇时将其中一个指针指向header走相同的步数定在入环节点相遇
            quick=quick.next;
            slow=slow.next;
        }
        return quick;
    }

    private static Node noLoop(Node head1, Node head2) {
        if (head1 == null || head2 == null) {
            return null;
        }
        Node cur1 = head1;
        Node cur2 = head2;
        int n = 0;
        //计算链表差值
        while (cur1.next != null) {
            n++;
            cur1 = cur1.next;
        }
        while (cur2.next != null) {
            n--;
            cur2 = cur2.next;
        }
        if (cur1 != cur2) {
            return null;
        }
        cur1 = n > 0 ? head1 : head2;
        cur2 = cur1 == head1 ? head2 : head1;
        n = Math.abs(n);
        //长的走到和短的长度同位置
        while (n != 0) {
            n--;
            cur1 = cur1.next;
        }
        //判断是否有相同节点，若无就会走到最后返回null
        while (cur1 != cur2) {
            cur1 = cur1.next;
            cur2 = cur2.next;
        }
        return cur1;
    }

    private static Node bothLoop(Node head1, Node loop1, Node head2, Node loop2) {
        Node cur1 = null;
        Node cur2 = null;
        if (loop1 == loop2) {
            cur1 = head1;
            cur2 = head2;
            int n = 0;
            while (cur1 != loop1) {
                n++;
                cur1 = cur1.next;
            }
            while (cur2 != loop2) {
                n--;
                cur2 = cur2.next;
            }
            cur1 = n > 0 ? head1 : head2;
            cur2 = cur1 == head1 ? head2 : head1;
            n = Math.abs(n);
            while (n != 0) {
                n--;
                cur1 = cur1.next;
            }
            while (cur1 != cur2) {
                cur1 = cur1.next;
                cur2 = cur2.next;
            }
            return cur1;
        } else {
            cur1 = loop1.next;
            while (cur1 != loop1) {
                if (cur1 == loop2) {
                    return loop1;//环内相交
                }
                cur1 = cur1.next;
            }
            return null;//两个有环链表环不是同一个
        }
    }
    public class Node{
	    int value;
	    Node next;
	}
}

```





### 

# 二叉树

## 一套拳法👊刷掉n个遍历树的问题

https://leetcode-cn.com/problems/convert-bst-to-greater-tree/solution/yi-tao-quan-fa-shua-diao-nge-bian-li-shu-de-wen-5/



## 递归遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142337278-120e5275-fd69-415a-8cc1-31a7a2dcb965.png)

## 非递归遍历

自己进行压栈的操作。

### 先序遍历：

- 新建一个stack
- 1.先放入头结点，
  2 再弹一个出来头结点。
  栈弹出一个头节点弹出，然后打印，然后右节点加入栈中，左节点加入栈中。周而复始直到栈中元素为空。
  注意先压右节点再压左节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142418160-c72f1041-1001-4b4b-9d8a-830208e8a8d0.png)

### 中序遍历


左子树一溜烟儿进栈，相当于找到最左子节点，然后弹出，打印。然后右节点进栈，右节点的左子节点跟着一溜烟儿进栈。然后返回开始周而复始。直到栈中元素为空。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142419929-989b9ca9-3c3c-49d7-8a69-b9ece28decd9.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142420645-4a4cd13f-3eed-4925-9534-616ff213b190.png)

```java
class Solution {
     List<Integer> lists=new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
      
      Stack<TreeNode> st=new Stack<>();
      if(root==null) return lists;
      while(root!=null||!st.isEmpty()){
          while(root!=null){
              st.push(root);
              root=root.left;
          }
          root=st.pop();
          lists.add(root.val);
          root=root.right;
      }
    return lists;
    }
}
```







### 后续遍历

借助一个辅助的栈，按照先序遍历的方法压栈，改成弹出一个节点以后放入到辅助栈中，然后先压右边再压左边子节点的思路。最后压栈为空的时候，挨个弹出辅助栈，就成了后续遍历了。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142418738-d23990ea-809d-4c7c-8846-88d565339640.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142419498-75ea6f21-e8d5-4138-b107-4ee68a101585.png)



```
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> postorderTraversal(TreeNode root) {
          if (root == null){
              return res;
          }
        Stack<TreeNode> s1 = new Stack<>();
        Stack<TreeNode> s2 = new Stack<>();
        s1.push(root);
        while(!s1.isEmpty()){
        root = s1.pop();
        s2.push(root);
        if(root.left!=null){
             s1.add(root.left);
        }
            if(root.right!=null){
            s1.add(root.right);
        }   
        }
        while(!s2.isEmpty()){
            res.add(s2.pop().val);
        }
        return res;

    }
}
```



```
public class Main {
	public static void postOrder(Node header) {
		if (header == null) {
			return;
		}
		Stack<Node> stack = new Stack<>();
		Stack<Node> postStack = new Stack<>();
		stack.push(header);
		while (!stack.isEmpty()) {
			// 先右后左的先序遍历的反向就是先左后右的后序遍历
			Node popNode = stack.pop();
			postStack.push(popNode);
			if (popNode.leftNode != null) {
				stack.push(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				stack.push(popNode.rightNode);
			}
		}
		while (!postStack.isEmpty()) {
			System.out.println(postStack.pop().value);
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



方法2

```
public class Main {
	public static void postOrder(Node header) {
		if (header == null) {
			return;
		}
		Stack<Node> stack = new Stack<Node>();
		stack.push(header);
		Node tail = null;
		while (!stack.isEmpty()) {
			tail = stack.peek();
			if (tail.leftNode != null && header != tail.leftNode && header != tail.rightNode) {
				stack.push(tail.leftNode);
			} else if (tail.rightNode != null && header != tail.rightNode) {
				stack.push(tail.rightNode);
			} else {
				System.out.print(stack.pop().value + " ");
				header = tail;
			}
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



### 层次遍历



```java
public class Main {
	public static void wedthOrder(Node header) {
		if (header == null) {
			return;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		deque.add(header);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			System.out.println(popNode.value);
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
			}
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 求二叉树的宽度

层次遍历，统计栈的长度。
或者搞一个队列，搞一个hashmap，key为node，value为层数。然后按照层次遍历，统计每一层的数量。
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142424040-fe0736b0-dda3-4f43-b2da-d90960f143b3.png)

如果就是用一个队列的话，可以搞两个变量，一个记录当前层最后一个node，一个记录下一层最后一个node。当前遍历的节点不是当前层最后一个node，在将左右孩子加入到队列的时候，就更新下一层最后一个node。如果等于当前层最后一个node，则将左右孩子入队列以后，当前最后一个node指向下一层最后一个node，下一层最后一个node志为空。同时在这个过程中记录节点的个数，更新最大宽度。

- 这里对于每层来说就是一个层次，所以显然就是基于横向遍历。
- 在横向遍历时我们要随机记录每个节点所在层数，以便判断该层是否已经结束，进入了下一层。有两种方式进行层数的记录：
  - map空间记录，比较耗空间
  - 用指针记录每一层结束节点的位置

**map实现**

```
public class Main {
	public static int floorMaxNodeNum(Node header) {
		if (header == null) {
			return 0;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		int thisFloorNum = 0;// 该层节点个数记录
		int thisFloor = 1;// 这是第几层
		int max = Integer.MIN_VALUE;
		HashMap<Node, Integer> map = new HashMap<>();
		deque.add(header);
		map.put(header, thisFloor);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			if (map.get(popNode) == thisFloor) {// 若是该层元素
				++thisFloorNum;
			} else {// 若已经进入下一层中的节点
				max = Math.max(max, thisFloorNum);
				++thisFloor;
				thisFloorNum = 1;
			}
			// 每次添加都要在map中记录节点层数
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
				map.put(popNode.leftNode, thisFloor + 1);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
				map.put(popNode.rightNode, thisFloor + 1);
			}
		}
		// 这一这里还是取最大值，最后一层没有和max比较过
		return Math.max(max, thisFloorNum);
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



**指针实现**

```
public class Main {
	public static int floorMaxNodeNum(Node header) {
		if (header == null) {
			return 0;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		int thisFloorNum = 0;// 该层节点个数记录
		int max = Integer.MIN_VALUE;
		Node thisFloorLastNode = header;// 该层最后一个节点，只能继承nextFloorLastNode
		Node nextFloorLastNode = null;// 下一层最后一个节点，用于更新thisFloorLastNode
		deque.add(header);
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			thisFloorNum++;
			// 入队就要更新nextFloorLastNode
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
				nextFloorLastNode = popNode.leftNode;
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
				nextFloorLastNode = popNode.rightNode;
			}
			// 若该层结束
			if (popNode == thisFloorLastNode) {
				max = Math.max(max, thisFloorNum);
				thisFloorLastNode = nextFloorLastNode;
				nextFloorLastNode = null;
				thisFloorNum = 0;
			}
		}
		return max;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 看一个二叉树是不是搜索二叉树

https://leetcode-cn.com/problems/legal-binary-search-tree-lcci/

中序遍历是升序的就是搜索二叉树。设置一个全局变量，表示上一个遍历的节点的值，如果当前节点是空，返回TRUE。递归左子树。如果左子树返回FALSE，就返回FALSE，如果左子树返回TRUE，看当前节点的值是否大于全局变量，如果小于，则返回FALSE。如果大于，设置全局变量为当前节点的值，递归右子树，看右子树是不是。

**中序遍历实现**

![image-20220311225822382](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220311225822382.png)

### 递归实现

```
class Solution {
    public boolean isValidBST(TreeNode root) {
        return isValidBST(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    public boolean isValidBST(TreeNode node, long lower, long upper) {
        if (node == null) {
            return true;
        }
        if (node.val <= lower || node.val >= upper) {
            return false;
        }
        return isValidBST(node.left, lower, node.val) && isValidBST(node.right, node.val, upper);
    }
}
```





```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        return pastOrder(root).valid;
    }
    public Tem pastOrder(TreeNode root){
        if(root==null){
            return new Tem(Long.MIN_VALUE,Long.MAX_VALUE, true);
        }
        Tem leftData=pastOrder(root.left);
        Tem rightData = pastOrder(root.right);
       boolean flag =leftData.valid&&rightData.valid &&leftData.maxV < root.val && rightData.minV > root.val;
		return new Tem( Math.max(rightData.maxV, root.val), Math.min(leftData.minV,root.val),flag);
    }
    public static class Tem{
        long maxV;
        long minV;
        boolean valid;
        Tem(long maxV, long minV, boolean valid) {
         this.maxV = maxV;
          this.minV = minV;
         this.valid = valid;
    }
    }
}
```



### 中序遍历实现



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public static long preValue = Long.MIN_VALUE;
    public boolean isValidBST(TreeNode root) {
        preValue = Long.MIN_VALUE;
          if (root==null){
            return true;
        }
        if(root.left==null&&root.right==null){
            return true;
        }
       return help(root);
    }
     public boolean help(TreeNode root) {
        if (root==null){
            return true;
        }
        if(root.left!=null){
            if(!help(root.left)){
                 System.out.println(3);
                return false;
            }
        }
 
        if(preValue>=root.val){
            System.out.println(preValue);
            System.out.println(1);
            return false;
        }
        preValue = root.val;
        if(root.right!=null){
            if(!help(root.right)){
                System.out.println(2);
                return false;
            }
        }
        return true;
    }
}
```



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public boolean isValidBST(TreeNode root) {
        Deque<TreeNode> stack = new LinkedList<TreeNode>();
        double inorder = -Double.MAX_VALUE;

        while (!stack.isEmpty() || root != null) {
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            root = stack.pop();
              // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
            if (root.val <= inorder) {
                return false;
            }
            inorder = root.val;
            root = root.right;
        }
        return true;
    }
}


```




## 判断一颗二叉树是否是完全二叉树

二叉树按宽度来遍历，如果有右子树没有左子树，直接返回FALSE
如果有一个孩子左右两个孩子不双全，则下一层所有的节点都应该是叶子节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142552913-816c0a18-a18a-4709-b68c-8fbcc35c3acc.png)





```java
public class Main {
	public static boolean isBST(Node header) {
		if (header == null) {
			return true;
		}
		ArrayDeque<Node> deque = new ArrayDeque<>();
		deque.add(header);
		boolean flag = false;
		while (!deque.isEmpty()) {
			Node popNode = deque.poll();
			if ((popNode.leftNode == null && popNode.rightNode != null)// 左无节点有右节点定不是完全二叉树
					|| (flag && (popNode.leftNode != null || popNode.rightNode != null))) {// 标记后左右存在节点
				return false;
			}
			if (popNode.leftNode != null) {
				deque.add(popNode.leftNode);
			}
			if (popNode.rightNode != null) {
				deque.add(popNode.rightNode);
			}
			// 此后不该有子节点，应该放在最后判断，因为判断结果flag不能对此次结果有影响
			// 去掉popNode.leftNode == null不影响
			if (popNode.leftNode == null || popNode.rightNode == null) {
				flag = true;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 判断一个树是不是平衡二叉树

左右子树高度差不超过1，每个节点都适用

https://leetcode-cn.com/problems/balanced-binary-tree/



套路是开始条件+最终放回值+左右信息递归



![image-20220312003552669](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220312003552669.png)



```
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = isAVLTree(header);
		return data.isAVL;
	}

	private static TransformData isAVLTree(Node header) {
		if (header == null) {
			return new TransformData(true, 0);
		}
		TransformData lData = isAVLTree(header.leftNode);
		TransformData rData = isAVLTree(header.rightNode);
		return new TransformData(lData.isAVL && rData.isAVL && Math.abs(lData.height - rData.height) <= 1,
				Math.max(lData.height, rData.height) + 1);

	}

	public static class TransformData {
		boolean isAVL;
		int height;
		public TransformData(boolean flag, int h) {
			this.isAVL = flag;
			this.height = h;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isBalanced(TreeNode root) {
        if (root==null){
            return true;
        }
        return height(root)>=0;
    } 
     public int height(TreeNode root){
        if(root==null) return 0;
        int leftHeight = height(root.left);
        int rightHeight = height(root.right);
        if(leftHeight ==-1||rightHeight == -1|| Math.abs(leftHeight-rightHeight)>1){
            return -1;
        }else{
            return Math.max(leftHeight,rightHeight)+1;
        }
     }

}
```



## 判断一个树是不是满二叉树

思路是看一下这个树的节点的总数是不是高度的二的次方加一。
子节点返回自己的高度和节点的个数。

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142629204-75121bf2-53ad-41ee-a030-8f2e1847ef90.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142629079-02ef35ea-496f-40a4-9fcd-22d237a8dc95.png)

## 求两个节点的最近公共祖先

https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/



### 借助hashmap

方法一：遍历所有的节点，然后将每个节点的子节点作为hashmap的key，自己作为v放入一个hashmap中。然后从给定的节点开始查hashmap，相当于把根节点到自己的路径放入到一个set中。第二个节点用同样的方法找父节点的链路，每次都看在不在上个节点的set中，在的话就是最近的公共父节点，直接返回。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        HashMap<TreeNode, TreeNode> map = new HashMap<>();
        process(root,map);
        HashSet<TreeNode> set = new HashSet<>();
        while(p!=null){
            set.add(p);
            p = map.get(p);
        }
        while(q!=null){
            if(set.contains(q)){
                return q;
            }
            q = map.get(q);
        }
        return null;
        

        
    }
    public void process(TreeNode root, HashMap map){
        if(root==null) return;
        if(root.left!=null){
            map.put(root.left, root);
            process(root.left,map);
        }
        if(root.right!=null){
            map.put(root.right, root);
            process(root.right,map);
        }
    }
}
```



### 递归

两种情况：

- 01和02一个是另一个的祖先。
- o1和02一个不是另一个的祖先。
  两种情况都走一下代码就能理解了。

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null||root == p || root == q){
            return root;
        }
        TreeNode left = lowestCommonAncestor(root.left,p,q);
        TreeNode right = lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null){
            return root;
        }
        return left==null?right:left;
        
    }
}
```

```
public class Main {
	/**
	 * @param header 根节点
	 * @param o1     节点一
	 * @param o2     节点二
	 * @return 最近共父节点
	 * 
	 */
	public static Node ancestor(Node header, Node o1, Node o2) {
		if (header == null || o1 == header || o2 == header)
			return header;
		Node lNode = ancestor(header.leftNode, o1, o2);
		Node rNode = ancestor(header.rightNode, o1, o2);

		// 该条件只会成功一次，返回的header就是我们所要找的节点
		// 当该条件成立时，header结果就找到了，我们接下来的目的就是向上传递直至结束该递归调用
		// 由于我们不知道这个header节点是它的父节点的左还是右
		// 但是我们知道成功进入该条件后的所有递归中只能出现一边为null，另一边为header节点
		// 所以 返回： lNode != null ? lNode : rNode
		// 另外这句话也会在找到目标节点前将o1或o2传到上一个递归中，代表着这个路径上存在o1或o2
		// 当路径上没有o1或o2时，lNode和rNode均为空，随便返回一个
		if (lNode != null && rNode != null)
			return header;
		return lNode != null ? lNode : rNode;
	}

	static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

## [ 完全二叉树的节点个数](https://leetcode-cn.com/problems/count-complete-tree-nodes/)

![image-20220312222216582](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220312222216582.png)

因此对于最大层数为 hh 的完全二叉树，节点个数一定在 `[2^h，2^(h+1)-1]` 的范围内，可以在该范围内通过二分查找的方式得到完全二叉树的节点个数。



如何判断第 k 个节点是否存在呢？如果第 k 个节点位于第 hh 层，则 k 的二进制表示包含 h+1位，其中最高位是 1，其余各位从高到低表示从根节点到第 kk个节点的路径，0表示移动到左子节点，1表示移动到右子节点。通过位运算得到第 k 个节点对应的路径，判断该路径对应的节点是否存在，即可判断第 kk 个节点是否存在。

层数从0开始，

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int countNodes(TreeNode root) {
        if (root==null) return 0;
        int height = 0;//根节点算是第0层
        TreeNode lchild = root;
        while(lchild.left !=null){
            height++;
            lchild=lchild.left;
        }
        int less = 1<<height;//根节点编号从1开始。
        int most= (1<<(height+1))-1;
        while(less<most){
            int mid = less+(most-less+1)/2;
            if(existNode( root, mid,height)){
                less=mid;
            }
            else{
                most=mid-1;
            }

        }
        return less;


    }
    public boolean existNode(TreeNode root, int mid, int level){
        int binNum = 1<<(level-1);//除了第一位1，第二位开始
        TreeNode tem=root;
        while(binNum>0&&tem!=null){
            //1往右，0往左
            if((binNum&mid)==0){
                tem=tem.left;

            }else{
                tem =tem.right;
            }
           binNum>>=1;
        }
        return tem!=null;
    }
}
```



## 子搜索二叉树的节点个数（套路题）

找到一棵二叉树中，最大的搜索二叉子树，返回最大搜索二叉子树的节点个数。.

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {

			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;
		int childMaxBSTNodeNum;
		int maxValue;
		int minValue;
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 找到二叉树的后继节点

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142754947-ef41d590-bd86-4087-8aaa-e44d837ebba4.png)

node节点的下一个有三种情况：
1.node有右子树，则就是右子树的最左最下节点
2.node节点没有右子树：

node节点没有父节点，那也就是根节点，由于没有右子树，这时候没有下一个节点，parent也是null

node节点是父节点的左子树，那下一个节点就是父节点

node节点是父节点的右子树，那下一个节点就是一直往上找，直到找到一个节点，node在这个节点的左子树上




```
public class Main {
	public static Node process(Node header) {
		if (header == null) {
			return null;
		}
		if (header.rightNode != null) {
			return lastLeftNode(header.rightNode);
		}
		Node parent = header.parentNode;
		while (parent != null && parent.leftNode != header) {
			header = parent;
			parent = parent.parentNode;
		}
		return parent;
	}
	private static Node lastLeftNode(Node rightNode) {
		while (rightNode.leftNode != null) {
			rightNode = rightNode.leftNode;
		}
		return rightNode;
	}
	static class Node {
		int value;
		Node leftNode;
		Node rightNode;
		Node parentNode;
	}
}

```



https://leetcode-cn.com/problems/successor-lcci/solution/100liang-chong-qing-kuang-zhi-xu-yao-yi-ghpai/

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {
        TreeNode pre = null;//记录最近一次左转的头结点
        while(root.val!=p.val){
            //右边
            if(p.val > root.val){          
                root = root.right;
            }
            //左边
            else{   
                pre = root;
                root = root.left;
            }
        }
        //假如没有右子树
        if(root.right==null){
            return pre;
        } 
        else{
            root = root.right;
            while(root.left!=null){
                root = root.left;
            }
            return root;
        }  
    }
}
```



## 二叉树的序列化和反序列化

https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof/

https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/submissions/

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756102-75b789e5-e277-4cde-8627-213fa40205f9.png)


![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756247-068974c6-5e8a-4013-a0d7-817756339d4b.png)

递归的方式：



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
        if (root == null) return "null,";
        String res = root.val+",";
        res += serialize(root.left);
        res += serialize(root.right);
        return res;
        
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
        String[] values = data.split(",");
        Queue<String> queue= new LinkedList<>();
        for(int i=0;i<values.length;i++){
            queue.add(values[i]);
        }
        
        return reconPreOrder(queue);
    }

    public static TreeNode reconPreOrder(Queue<String> queue){
        String val = queue.poll();
        if(val.equals("null")){
            return null;
        }
        TreeNode head = new TreeNode(Integer.valueOf(val));
        head.left=reconPreOrder(queue);
        head.right=reconPreOrder(queue);
        return head;
    }
}

// Your Codec object will be instantiated and called as such:
// Codec codec = new Codec();
// codec.deserialize(codec.serialize(root));
```

非递归的方式

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
public class Codec {

    // Encodes a tree to a single string.
    public String serialize(TreeNode root) {
          if(root == null) return "[]";
        StringBuilder res = new StringBuilder("[");
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(node != null) {
                res.append(node.val + ",");
                queue.add(node.left);
                queue.add(node.right);
            }
            else res.append("null,");
        }
        res.deleteCharAt(res.length() - 1);
        res.append("]");
        return res.toString();
    }

    // Decodes your encoded data to tree.
    public TreeNode deserialize(String data) {
          if(data.equals("[]")) return null;
        String[] vals = data.substring(1, data.length() - 1).split(",");
        TreeNode root = new TreeNode(Integer.parseInt(vals[0]));
        Queue<TreeNode> queue = new LinkedList<>() {{ add(root); }};
        int i = 1;
        while(!queue.isEmpty()) {
            TreeNode node = queue.poll();
            if(!vals[i].equals("null")) {
                node.left = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.left);
            }
            i++;
            if(!vals[i].equals("null")) {
                node.right = new TreeNode(Integer.parseInt(vals[i]));
                queue.add(node.right);
            }
            i++;
        }
        return root;

    }
}

```

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756826-89cdd006-6b38-4c4c-bfc6-a9146fc92b15.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142756841-53102096-a643-4c93-9c4f-0fdaf98fc261.png)
中序遍历就是 纸条显示的内容  



## [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

### 递归

```
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null ){
            return true;
        }
        return valid(root.left,root.right);
    }
    public boolean valid(TreeNode left, TreeNode right){
        if (left==null&&right==null){
            return true;
        }
        if(left==null||right==null){
            return false;
        }
        return left.val==right.val&&valid(left.right,right.left)&&valid(left.left,right.right);
    }
}
```



### 迭代

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        if(root==null ){
            return true;
        }
        return valid(root,root);
    }
    public boolean valid(TreeNode u, TreeNode v){
        Queue<TreeNode> q = new LinkedList<>();
        q.offer(u);
        q.offer(v);
        while(!q.isEmpty()){
            u = q.poll();
            v = q.poll();
            if (u == null && v == null) {
                continue;
            }
            if ((u == null || v == null) || (u.val != v.val)) {
                return false;
            }
            q.offer(u.left);
            q.offer(v.right);
            q.offer(v.left);
            q.offer(u.right);

        }
        return true;
    }
}
```



## [538. 把二叉搜索树转换为累加树](https://leetcode-cn.com/problems/convert-bst-to-greater-tree/)

### 递归

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int count = 0;
    public TreeNode convertBST(TreeNode root) {
        reInOreder(root);
        return root;
    }
    public void reInOreder(TreeNode root){
        if(root == null) return;
        reInOreder(root.right);
        count += root.val;
        root.val = count;
        reInOreder(root.left);
    }
    
}
```



```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    int sum = 0;

    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
}

```

### 方法二：Morris 遍历

![image-20220316212053354](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220316212053354.png)

```java
class Solution {
    public TreeNode convertBST(TreeNode root) {
        int sum = 0;
        TreeNode node = root;

        while (node != null) {
            if (node.right == null) {
                sum += node.val;
                node.val = sum;
                node = node.left;
            } else {
                TreeNode succ = getSuccessor(node);
                if (succ.left == null) {
                    succ.left = node;
                    node = node.right;
                } else {
                    succ.left = null;
                    sum += node.val;
                    node.val = sum;
                    node = node.left;
                }
            }
        }

        return root;
    }

    public TreeNode getSuccessor(TreeNode node) {
        TreeNode succ = node.right;
        while (succ.left != null && succ.left != node) {
            succ = succ.left;
        }
        return succ;
    }
}
```

## [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

我自己的解法

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int res = 0;
    public int diameterOfBinaryTree(TreeNode root) {
         if(root==null){
            return 0;
        }
        dfs(root);
        return res-1;
        


    }
    public int dfs(TreeNode root){
        if(root==null){
            return 0;
        }
        int left=dfs(root.left);
        int right=dfs(root.right);
        res = Math.max(res,left+right+1);
        return Math.max(left,right)+1;
    }
}
```



## 哈夫曼最小代价问题

**哈夫曼树相关的几个名词**

路径：在一棵树中，一个结点到另一个结点之间的通路，称为路径。图 1 中，从根结点到结点 a 之间的通路就是一条路径。

路径长度：在一条路径中，每经过一个结点，路径长度都要加 1 。例如在一棵树中，规定根结点所在层数为1层，那么从根结点到第 i 层结点的路径长度为 i - 1 。图 1 中从根结点到结点 c 的路径长度为 3。

结点的权：给每一个结点赋予一个新的数值，被称为这个结点的权。例如，图 1 中结点 a 的权为 7，结点 b 的权为 5。

结点的带权路径长度：指的是从根结点到该结点之间的路径长度与该结点的权的乘积。例如，图 1 中结点 b 的带权路径长度为 2 * 5 = 10 。

树的带权路径长度为树中所有叶子结点的带权路径长度之和。通常记作 “WPL” 。例如图 1 中所示的这颗树的带权路径长度为：

> WPL = 7 * 1 + 5 * 2 + 2 * 3 + 4 * 3

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/09563Tb0-0.png)







**什么是哈夫曼树**

当用 n 个结点（都做叶子结点且都有各自的权值）试图构建一棵树时，如果构建的这棵树的带权路径长度最小，称这棵树为“最优二叉树”，有时也叫“赫夫曼树”或者“哈夫曼树”。

在构建哈弗曼树时，要使树的带权路径长度最小，只需要遵循一个原则，那就是：权重越大的结点离树根越近。在图 1 中，因为结点 a 的权值最大，所以理应直接作为根结点的孩子结点。

**构建哈夫曼树的过程**

对于给定的有各自权值的 n 个结点，构建哈夫曼树有一个行之有效的办法：

1. 在 n 个权值中选出两个最小的权值，对应的两个结点组成一个新的二叉树，且新二叉树的根结点的权值为左右孩子权值的和；
2. 在原有的 n 个权值中删除那两个最小的权值，同时将新的权值加入到 n–2 个权值的行列中，以此类推；
3. 重复 1 和 2 ，直到所以的结点构建成了一棵二叉树为止，这棵树就是哈夫曼树。

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/09563QS5-1.png)

图 2 哈夫曼树的构建过程


图 2 中，（A）给定了四个结点a，b，c，d，权值分别为7，5，2，4；第一步如（B）所示，找出现有权值中最小的两个，2 和 4 ，相应的结点 c 和 d 构建一个新的二叉树，树根的权值为 2 + 4 = 6，同时将原有权值中的 2 和 4 删掉，将新的权值 6 加入；进入（C），重复之前的步骤。直到（D）中，所有的结点构建成了一个全新的二叉树，这就是哈夫曼树。







### 金条切割问题

<img src="%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220318230316327.png" alt="image-20220318230316327" style="zoom:60%;" />



```java
public class Main {
	public static int lessConsumer(int[] arr) {
		if (arr.length == 1)
			return arr[0];
		PriorityQueue<Integer> queue = new PriorityQueue<>();// 内部元素为堆结构（优先队列：默认是小顶堆，有小到大排列）
		for (int i : arr)
			queue.add(i);
		int sum = 0;
		while (queue.size() > 1) {
			// 构建赫夫曼树
			int num1 = queue.poll();
			int num2 = queue.poll();
			sum += (num1 + num2);
			queue.add(num1 + num2);
		}
		return sum;
	}
}

```





# 树形dp

![sdfsdfdssd](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D95FBD3D6DD4FF2CBDAA5A9011CCC7E.jpg)



风 9:11:52
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8137EC9804C17A0400E254509CD5AD74.jpg)

风 9:11:53
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/759C819ADFCB16E2CA56D2AEED307D6A.jpg)

## 树节点最远距离



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3D9B73ED255C5D81E3CC844F11CB856B.jpg)




![image-20220313150713372](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313150713372.png)



***递归套路：***

- 根据子树最大深度计算出经过当前节点的最长距离
- 向上传递子树和经过当前节点最长距离 的最大值
- 最长距离需要子树深度
- 所以递归数据包括最大距离和最大深度



最大深度表示当前子树的最大深度。最大距离表示当前子树包含的最大距离，有可能经过子节点，也有可能不经过子节点。

```
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 员工的快乐值



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/513BBF7364AF9B669F89CB5E33521B1C.jpg)


![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/36AEC04043D12E4DD4B9DD9B070B6BE8.jpg)

***递归套路：***

- 最大值和每个节点是否去有关，就是取 **当前节点不去（0）+子节点去或不去的最大值** 和 **当前节点去（happy）+子节点不去的最大值**
- 每个节点的去和不去都会直接影响父类节点，间接影响祖宗节点。
- 只要递归传递该节点去和不去的最大值信息即可。

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxHappy(header);
		return Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
	}

	private static TransformData maxHappy(Node header) {
		if (header.nexts == null) {
			return new TransformData(0, header.happyNum);
		}
		int dontWent = 0;
		int went = 0;
		for (Node nextNode : header.nexts) {
			TransformData data = maxHappy(nextNode);
			went += data.thisNodeDontWentSumHappy;
			dontWent += Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
		}
		return new TransformData(dontWent, went);
	}

	public static class TransformData {
		int thisNodeDontWentSumHappy;
		int thisNodeWentSumHappy;
		public TransformData(int thisNodeDontWentSumHappy, int thisNodeWentSumHappy) {
			this.thisNodeDontWentSumHappy = thisNodeDontWentSumHappy;
			this.thisNodeWentSumHappy = thisNodeWentSumHappy;
		}

	}

	public static class Node {
		int happyNum;
		Node[] nexts;
	}
}

```

## [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

跟上个题类似，只不过是二叉树

递归的解法

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int rob(TreeNode root) {
        if(root==null) return 0;
        nodeMaxV res =  dfs(root);
        return Math.max(res.have,res.donehave);

    }
    public nodeMaxV dfs(TreeNode root){
        if(root == null){
            return new nodeMaxV(0,0);
        }
        nodeMaxV left = dfs(root.left);
        nodeMaxV right = dfs(root.right);

        return new nodeMaxV(left.donehave+right.donehave+root.val,
                            Math.max(left.have,left.donehave)+Math.max(right.have,right.donehave)
                            );
    }
    public static class nodeMaxV{
        int have;
        int donehave;
        public nodeMaxV(int have,int donehave){
            this.have = have;
            this.donehave = donehave;
        }
    }
}
```



换成不用定义类的解法，用int代替类

```
class Solution {
    public int rob(TreeNode root) {
        int[] rootStatus = dfs(root);
        return Math.max(rootStatus[0], rootStatus[1]);
    }

    public int[] dfs(TreeNode node) {
        if (node == null) {
            return new int[]{0, 0};
        }
        int[] l = dfs(node.left);
        int[] r = dfs(node.right);
        int selected = node.val + l[1] + r[1];
        int notSelected = Math.max(l[0], l[1]) + Math.max(r[0], r[1]);
        return new int[]{selected, notSelected};
    }
}

```




## 树结构转成链表（套路题）

![image-20220313152313422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313152313422.png)

- 将左右子树构建好的结果通过本节点链接，就是递归对数据就是链接起始和结束节点。

中序遍历



```java
public class Main {
    public static Data process(Node x) {
        if (x == null) {
            return new Data(null, null);
        }
        // 将x作为中间节点，x.leftNode为创建x的前面的链表，x.rightNode为创建后面的链表。
        Data leftData = process(x.leftNode);
        Data rightData = process(x.rightNode);
        // 前后创建的链表和中间节点x链接，因为是双向链表，所以要有四句链接
        if (leftData.end != null) {
            leftData.end.rightNode = x;
        }
        x.leftNode = leftData.end;
        if (rightData.start != null) {
            rightData.start.leftNode = x;
        }
        x.rightNode = rightData.start;
        // 创建好后重新分装返回起始节点和尾节点
        return new Data(leftData.start != null ? leftData.start : x,
                rightData.end != null ? rightData.end : x);
    }

    static class Data {
        Node start;
        Node end;
        public Data(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/



```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    public Node treeToDoublyList(Node root) {
             if (root == null) return null;
        Stack<Node> stack=new Stack<>();
        Node pre=null;
        Node p=root;
        boolean isFirst=true;
        while (p!=null||!stack.isEmpty()){
            while (p!=null){//寻找子树的最左节点
                stack.push(p);
                p=p.left;
            }
            p=stack.pop();
            if (isFirst){//处理第一个节点，第一个节点没有前置节点
                root=p;
                pre=root;
                isFirst=false;
            }else {pre.right=p;//相当于遍历当前节点，因为不是第一个了，修改他之前节点的指向
            p.left=pre;
            pre=p;

            }
            p=p.right;//中序遍历，遍历下一个节点

        }
        root.left=pre;
        pre.right=root;
        return  root;
    }
}
```

递归的方式

```java
/*
// Definition for a Node.
class Node {
    public int val;
    public Node left;
    public Node right;

    public Node() {}

    public Node(int _val) {
        val = _val;
    }

    public Node(int _val,Node _left,Node _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
    Node pre,head;
    public Node treeToDoublyList(Node root) {
        if(root==null)return null;
           dfs(root);
        head.left = pre;
        pre.right = head;
        return head;
    }
    public void dfs(Node root){
        if(root == null) return;
        dfs(root.left);
        if(pre!=null){
            pre.right=root;
        }else{
            head=root;
        }
        root.left=pre;
        pre=root;
        dfs(root.right);

    }
}
```

## [114. 二叉树展开为链表](https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list/)

我个人的解法：

```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    TreeNode pre;
    public void flatten(TreeNode root) {
         if(root==null) return;
        if(pre!=null){
            pre.right=root;
            pre.left=null;
        }
       TreeNode right=root.right;
        pre = root;
        flatten(root.left);
        flatten(right);
    }
   
} 
```







## 二叉树的个数

https://leetcode-cn.com/problems/unique-binary-search-trees/solution/

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/adea57019f814883a17071344d4f5f96.png)

### 递归

```java
public class Main {
	public static int process(int N) {
		if (N == 0 || N == 1) {
			return 1;
		}
		int res = 0;
		for (int i = 0; i < N; i++) {
			res += process(i) * process(N - i - 1);
		}
		return res;
	}
}

```

![image-20211227231055343](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227231055343.png)

### 动态规划

```java
public static int num(int n) {
    if (n < 2) {
        return 1;
    }
    int[] dp = new int (n + 1);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];

}
```

### **数学公式**

![image-20220314232245177](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220314232245177.png)

```
class Solution {
    public int numTrees(int n) {
        // 提示：我们在这里需要用 long 类型防止计算过程中的溢出
        long C = 1;
        for (int i = 0; i < n; ++i) {
            C = C * 2 * (2 * i + 1) / (i + 2);
        }
        return (int) C;
    }
}
```



## 判断是搜索二叉树（套路题）

**中序遍历实现**

中序遍历是有小到大的

```
public class Main {
	public static int lastNum=Integer.MIN_VALUE;
	public static boolean isBST(Node header) {
		if (header.leftNode!=null) {
			if (!isBST(header.leftNode)) {
				return false;
			}
		}
		if (lastNum>header.value) {
			return false;
		}
		lastNum=header.value;
		if (header.rightNode!=null) {
			if (!isBST(header.rightNode)) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

**递归套路实现**

![image-20220117092658302](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092658302.png)



```
public class Main {
	public static TransformData isBST(Node header) {
		if (header == null) {
			return new TransformData(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = isBST(header.leftNode);
		TransformData rightData = isBST(header.rightNode);
		boolean flag = leftData.max < header.value && rightData.min > header.value;
		return new TransformData(flag, Math.max(rightData.max, header.value), Math.min(leftData.min, header.value));
	}

	private static class TransformData {
		boolean sucess;
		int max;
		int min;
		public TransformData(boolean sucess, int max, int min) {
			this.sucess = sucess;
			this.max = max;
			this.min = min;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 子搜索二叉树的节点个数（套路题）

![image-20220117092722704](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092722704.png) 





![image-20220117093905556](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117093905556.png)

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
	//basecase 如果是空节点，也希望传递个上层节点已有能将递归进行下去，所以给最大值和最小值。 	
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		//递归左右子节点获取信息
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		//判断加上目前节点是不是构成一颗二叉搜索树，该节点的值应该大于左子树最大值，小于右子树最小值
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {
			//可能性1，该节点与左右子树构成一颗新的二叉搜索树，左右都得是二叉搜索树
			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
        // 可能性2 ，该节点与左右子树构不成二叉搜索树，就给maxValue赋值最小，minValue赋值最大，保证上层节点无法构成二叉搜索树。然后比较左右子树哪个节点多就返回哪个
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;//以该节点为根节点的子树是不是二叉搜索树
		int childMaxBSTNodeNum;//不管是或者不是，这颗子树拥有的最大的搜索二叉树的节点个数
		int maxValue;// 构成搜索二叉树的最大的值
		int minValue;//构成搜索二叉树最小的值
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```









## 前中序推后序遍历

![image-20220117235316030](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235316030.png)

- 关注在前中后序遍历之间的元素相对位置关系。
- ![image-20220117235951620](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235951620.png)

```java
public class Test {
    public static void main(String[] args) {
        int[] post = genPost(new int[]{1, 2, 4, 5, 3, 6, 7}, new int[]{4, 2, 5, 1, 6, 3, 7});
        System.out.println(Arrays.toString(post));
    }

    public static int[] genPost(int[] pre, int[] in) {
        int[] post = new int[pre.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        genPost(pre, 0, pre.length - 1, in, 0, in.length - 1, post, 0, post.length - 1, map);
        return post;
    }

    private static void genPost(int[] pre, int preStart, int preEnd,
                                int[] in, int medStart, int medEnd,
                                int[] post, int postStart, int postEnd,
                                HashMap<Integer, Integer> map) {
        if (preStart > preEnd) {
            return;
        }
        if (postStart == postEnd) {
            post[postStart] = pre[preStart];
            return;
        }
        //每一轮的前序第一个元素就是后序最后一个元素，在后续的genPost中不能再包含其他元素
        post[postEnd] = pre[preStart];

        //此时寻找pre[preStart]在med中的索引indexStart，那么最后的 indexStart - medStart 就是中间元素个数
        int indexStart = map.get(pre[preStart]);
        
        //以pre中preStart位置的元素为左右分割点,根据 indexStart 确定pre,in,post中的数据范围
        genPost(pre, preStart + 1, preStart + indexStart - medStart,
                in, medStart, indexStart - 1,
                post, postStart, postStart + indexStart - medStart - 1,
                map);
        genPost(pre, preStart + indexStart - medStart + 1, preEnd,
                in, indexStart + 1, medEnd,
                post, postStart + indexStart - medStart, postEnd - 1,
                map);
    }
}

```

https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/



```
class Solution {
    private Map<Integer, Integer> indexMap;

    public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
        if (preorder_left > preorder_right) {
            return null;
        }

        // 前序遍历中的第一个节点就是根节点
        int preorder_root = preorder_left;
        // 在中序遍历中定位根节点
        int inorder_root = indexMap.get(preorder[preorder_root]);
        
        // 先把根节点建立出来
        TreeNode root = new TreeNode(preorder[preorder_root]);
        // 得到左子树中的节点数目
        int size_left_subtree = inorder_root - inorder_left;
        // 递归地构造左子树，并连接到根节点
        // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
        root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
        // 递归地构造右子树，并连接到根节点
        // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
        root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
        return root;
    }

    public TreeNode buildTree(int[] preorder, int[] inorder) {
        int n = preorder.length;
        // 构造哈希映射，帮助我们快速定位根节点
        indexMap = new HashMap<Integer, Integer>();
        for (int i = 0; i < n; i++) {
            indexMap.put(inorder[i], i);
        }
        return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
    }
}

```



## 求完全二叉树的节点的个数

​	

![image-20220118092613612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092613612.png)

![image-20220118093215169](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093215169.png)

求完全二叉树的深度的方法。

![image-20220118092804821](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092804821.png)



![image-20220118093156008](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093156008.png)

![image-20220118093510245](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093510245.png)

看右子树的深度是不是与当前最深度相等，是的，那左子树肯定是满二叉树，如果不是的话，那这个右子树肯定是满二叉树。确定了满二叉树的个数，就可以递归计算另外一个不是满二叉树的子二叉树的个数。base是空或者到了最后一层，肯定没有子树了，返回1。



## [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

![image-20220313221616601](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220313221616601.png)

```
class Solution {
    int maxSum = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        maxGain(root);
        return maxSum;
    }

    public int maxGain(TreeNode node) {
        if (node == null) {
            return 0;
        }
        
        // 递归计算左右子节点的最大贡献值
        // 只有在最大贡献值大于 0 时，才会选取对应子节点
        int leftGain = Math.max(maxGain(node.left), 0);
        int rightGain = Math.max(maxGain(node.right), 0);

        // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
        int priceNewpath = node.val + leftGain + rightGain;

        // 更新答案
        maxSum = Math.max(maxSum, priceNewpath);

        // 返回节点的最大贡献值
        return node.val + Math.max(leftGain, rightGain);
    }
}

```







## [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)



递归



```
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null) return null;
        TreeNode left = invertTree(root.left);
        TreeNode right = invertTree(root.right);
        root.left=right;
        root.right=left;
        return root;

    }
}
```



```
   /**
     * 层序遍历方式反转
     */
    public TreeNode invertTreeByQueue(TreeNode root) {
        if (root == null) {
            return null;
        }
        Queue<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            TreeNode temp = node.left;
            node.left = node.right;
            node.right = temp;
            if (node.left != null) {
                queue.offer(node.left);
            }
            if (node.right != null) {
                queue.offer(node.right);
            }
        }
        return root;
    }

    /**
     * 深度优先遍历的方式反转
     */
    private TreeNode invertTreeByStack(TreeNode root) {
        if (root == null) {
            return null;
        }
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            int size = stack.size();
            for (int i = 0; i < size; i++) {
                TreeNode cur = stack.pop();
                TreeNode temp = cur.left;
                cur.left = cur.right;
                cur.right = temp;
                if (cur.right != null) {
                    stack.push(cur.right);
                }
                if (cur.left != null) {
                    stack.push(cur.left);
                }
            }
        }
        return root;
    }
```

## [617. 合并二叉树](https://leetcode-cn.com/problems/merge-two-binary-trees/)

### 我的解法

就是深度优先搜索

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {
        if(root1==null && root2==null){
            return null;
        }
        if(root1==null){
            root1=root2;
        }else if(root2!=null){
            root1.val+=root2.val;
            root1.left = mergeTrees(root1.left,root2.left);
            root1.right = mergeTrees(root1.right,root2.right);
        }
        return root1;
    }
}
```

### 官方的深度优先搜索

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        merged.left = mergeTrees(t1.left, t2.left);
        merged.right = mergeTrees(t1.right, t2.right);
        return merged;
    }
}
```



### 广度优先搜索

![image-20220316222307002](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220316222307002.png)



其实就是层次遍历,借助三个队列

```java
class Solution {
    public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {
        if (t1 == null) {
            return t2;
        }
        if (t2 == null) {
            return t1;
        }
        TreeNode merged = new TreeNode(t1.val + t2.val);
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        Queue<TreeNode> queue1 = new LinkedList<TreeNode>();
        Queue<TreeNode> queue2 = new LinkedList<TreeNode>();
        queue.offer(merged);
        queue1.offer(t1);
        queue2.offer(t2);
        while (!queue1.isEmpty() && !queue2.isEmpty()) {
            TreeNode node = queue.poll(), node1 = queue1.poll(), node2 = queue2.poll();
            TreeNode left1 = node1.left, left2 = node2.left, right1 = node1.right, right2 = node2.right;
            if (left1 != null || left2 != null) {
                if (left1 != null && left2 != null) {
                    TreeNode left = new TreeNode(left1.val + left2.val);
                    node.left = left;
                    queue.offer(left);
                    queue1.offer(left1);
                    queue2.offer(left2);
                } else if (left1 != null) {
                    node.left = left1;
                } else if (left2 != null) {
                    node.left = left2;
                }
            }
            if (right1 != null || right2 != null) {
                if (right1 != null && right2 != null) {
                    TreeNode right = new TreeNode(right1.val + right2.val);
                    node.right = right;
                    queue.offer(right);
                    queue1.offer(right1);
                    queue2.offer(right2);
                } else if (right1 != null) {
                    node.right = right1;
                } else {
                    node.right = right2;
                }
            }
        }
        return merged;
    }
}

```



## 折纸凹凸问题

![image-20220318230102031](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220318230102031.png)

- 上次每个折痕都有两个子折痕，上凹下凸，也就是二叉树节点都有一个凹左节点一个凸右节点。这些折痕的顺序就是二叉树的中序遍历。

```
public class Main {
	/**
	 * @param N 折N次
	 */
	public static void pre(int N) {
		pre(N, true);
	}

	private static void pre(int num, boolean down) {
		if (num == 0)
			return;
		pre(num - 1, true);// true表示凹，false表示凸
		System.out.print(down ? "down " : "up ");
		pre(num - 1, false);
	}
}

```

# 字典树



## [208. 实现 Trie (前缀树)](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

![image-20220321215557982](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220321215557982.png)

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/21
 * @Version 1.0
 **/
class Trie {
    private TrieNode root = new TrieNode('/');

    class TrieNode {
        public char data;
        public TrieNode[] children = new TrieNode[26];
        public boolean isEndingChar = false;

        public TrieNode(char data) {
            this.data = data;
        }
    }


    public void insert(String word) {
        TrieNode p = root;
        for (int i = 0; i < word.length(); ++i) {
            int index = word.charAt(i) - 'a';
            if (p.children[index] == null) {
                TrieNode newNode = new TrieNode(word.charAt(i));
                p.children[index] = newNode;
            }
            p = p.children[index];
        }
        p.isEndingChar = true;
    }

    public boolean search(String word) {
        TrieNode p = root;//上一个单词找完到结尾了，从root开始找
        for (int i = 0; i < word.length(); i++) {//i以前的单词都被找完了。
            int index = word.charAt(i) - 'a';
            if (p.children[index] == null) {
                return false;
            }
            p = p.children[index];
        }
        if (p.isEndingChar == true) {
            return true;
        }
        return false;


    }

    public boolean startsWith(String prefix) {
        TrieNode p = root;//上一个单词找完到结尾了，从root开始找
        for (int i = 0; i < prefix.length(); i++) {//i以前的单词都被找完了。
            int index = prefix.charAt(i) - 'a';
            if (p.children[index] == null) {
                return false;
            }
            p = p.children[index];
        }
        return true;
    }
}

/**
 * Your Trie object will be instantiated and called as such:
 * Trie obj = new Trie();
 * obj.insert(word);
 * boolean param_2 = obj.search(word);
 * boolean param_3 = obj.startsWith(prefix);
 */
```

官方的解法

```java
class Trie {
    private Trie[] children;
    private boolean isEnd;

    public Trie() {
        children = new Trie[26];
        isEnd = false;
    }
    
    public void insert(String word) {
        Trie node = this;
        for (int i = 0; i < word.length(); i++) {
            char ch = word.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                node.children[index] = new Trie();
            }
            node = node.children[index];
        }
        node.isEnd = true;
    }
    
    public boolean search(String word) {
        Trie node = searchPrefix(word);
        return node != null && node.isEnd;
    }
    
    public boolean startsWith(String prefix) {
        return searchPrefix(prefix) != null;
    }

    private Trie searchPrefix(String prefix) {
        Trie node = this;
        for (int i = 0; i < prefix.length(); i++) {
            char ch = prefix.charAt(i);
            int index = ch - 'a';
            if (node.children[index] == null) {
                return null;
            }
            node = node.children[index];
        }
        return node;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/implement-trie-prefix-tree/solution/shi-xian-trie-qian-zhui-shu-by-leetcode-ti500/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







## [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

### 字典树

```java
import java.util.List;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/20
 * @Version 1.0
 **/
public class wordBreak {
    // 1ms
    public boolean wordBreak(String s, List<String> wordDict) {
        Trie trie = new Trie();

        for (String word : wordDict)
            trie.insert(word.toCharArray());

        return trie.find(s, 0);
    }

    class TrieNode {
        public char data;
        public TrieNode[] children = new TrieNode[26];
        public boolean isEndingChar = false;

        public TrieNode(char data) {
            this.data = data;
        }
    }

    class Trie {
        private TrieNode root = new TrieNode('/');
        boolean[] failed = new boolean[301]; // s.length <= 300

        public void insert(char[] text) {
            TrieNode p = root;
            for (int i = 0; i < text.length; ++i) {
                int index = text[i] - 'a';
                if (p.children[index] == null) {
                    TrieNode newNode = new TrieNode(text[i]);
                    p.children[index] = newNode;
                }
                p = p.children[index];
            }
            p.isEndingChar = true;
        }

        public boolean find(String s, int i) {
            if (failed[i])//说明从i+1往后找s[i+1:...]往后的匹配，后续找不到了。
                return false;

            if (i >= s.length())//匹配完成
                return true;
            TrieNode p = root;//上一个单词找完到结尾了，从root开始找
            for (; i < s.length(); i++) {//i以前的单词都被找完了。
                int index = s.charAt(i) - 'a';
                if (p.children[index] == null) {
                    return false;
                }
                p = p.children[index];
                if (p.isEndingChar) {//找到了i才能走到这一步

                    if (find(s, i + 1))//，相当于是每次如果p位置是一个单词的结尾就先往下递归。相当于先匹配较短的单词
                        return true;
                    failed[i + 1] = true;//走到这一步，说明从i+1往后找s[i+1:...]往后的字符串失败了，后续找不到了。后面就不用从i位置找了。
                }
            }
            return false;//默认返回false，走到这一步，
        }
    }
}
```



最后之所以要return false，说明i没有走到匹配的一个单词的完整部分。例如这个，最终走到的是一个字母a，没有 走完一个完整单词

![image-20220321010020897](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220321010020897.png)



### 动态规划

s.substring(j,i) 从0位置开始计算，包含j不包含i位置的字符。

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        HashSet<String> set = new HashSet<>(wordDict);
        boolean[] dp = new boolean[s.length()+1];
        dp[0] =true;
        for(int i = 1;i<=s.length();i++){
            for(int j = 0;j<i;j++){
                if(dp[j]&&set.contains(s.substring(j,i))){
                    dp[i]=true;
                    break;
                }
            }
        }

    return dp[s.length()];

    }
}
```







## [437. 路径总和 III](https://leetcode-cn.com/problems/path-sum-iii/)

递归

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        if(root==null) return 0;
        int res=0;
        res+=rootSum(root,targetSum);
        res+=pathSum(root.left,targetSum);
        res+=pathSum(root.right,targetSum);
        return res;

    }
    public int rootSum(TreeNode root, int targetSum) {
        if(root==null){
            return 0;
        }
        
        int ret=0;
        if(targetSum==root.val){
            ret++;
        }
        ret+=rootSum(root.left,targetSum-root.val);
        ret+=rootSum(root.right,targetSum-root.val);
        return ret;

    }
}
```

前缀和

看这个地方来理解。

https://leetcode-cn.com/problems/path-sum-iii/solution/dui-qian-zhui-he-jie-fa-de-yi-dian-jie-s-dey6/

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public int pathSum(TreeNode root, int targetSum) {
        //HashMap的key是前缀和， value是该前缀和的节点数量，记录数量是因为有出现复数路径的可能。
        HashMap<Long, Integer> map=new HashMap<>();
        map.put(0L,1);
        
        return dfs(root,map,0,targetSum);

    }
    public int dfs(TreeNode root,HashMap<Long, Integer> prefix,long cur,int targetSum){
        if(root==null)  return 0;
        cur +=root.val;
        int res = prefix.getOrDefault(cur-targetSum,0);
          prefix.put(cur, prefix.getOrDefault(cur, 0) + 1);
        res+=dfs(root.left,prefix,cur,targetSum);
        res+=dfs(root.right,prefix,cur,targetSum);
        prefix.put(cur,prefix.getOrDefault(cur,0)-1);
        return res;




    }
}
```







## 文件夹结构



![image-20220111233804077](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111233804077.png)

![image-20220112000055179](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000055179.png)

然后深度优先遍历

![image-20220112000201818](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000201818.png)

![image-20220112003108883](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112003108883.png)



# 图

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142758750-d7ee486b-38b2-4b2b-958d-0399c5511f58.png)

表达图的一种方式
表示node的描述
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759443-88012d8e-dd5b-43f0-a2f3-bc297580ce16.png)
从上到下，分别是

- 值
- 入度
- 出度
- 由这个点指向的点的集合
- 指向这个点的集合

表示边的描述
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759537-dba9a3aa-e7ef-4716-a095-6d902dd50a39.png)

- 权值
- 从哪个点起
- 指向哪个点

图的表示，边集和点集

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759679-95421d22-2b96-4681-9b32-d3a4753945b6.png)

根据二维矩阵构建上面的图的代码
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759766-81df64fe-81ae-4ee2-b917-8d0b186511b6.png)

## 图的宽度优先遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759860-a07c5d09-3996-41a9-b7f5-9650028eee9c.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142759911-078d0e38-bda0-49aa-8b4f-9f91c181d2b7.png)





## 图的广度优先遍历

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142760807-8415810b-d085-452f-8411-4cb220a1270c.png)
栈里面的每个节点都是访问过的，因此下次只是弹出来寻找深度下一个节点，如果找到了，就把这两个都加入到栈中，然后访问下一个节点，将下一个节点保存到set中。set的作用就是保存已经访问过的节点。

## 拓扑排序

在一个有向图中，对所有的节点进行排序，要求没有一个节点指向它前面的节点。

先统计所有节点的入度，对于入度为0的节点就可以分离出来，然后把这个节点指向的节点的入度减一。

一直做改操作，直到所有的节点都被分离出来。

如果最后不存在入度为0的节点，那就说明有环，不存在拓扑排序，也就是很多题目的无解的情况。

下面是算法的演示过程。

![image-20220319231051717](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220319231051717.png)





![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142765102-871b3421-eca8-4dfd-87c4-9cabaf885886.png)

## 最小生成树

1、什么是最小生成树
现在假设有一个很实际的问题：我们要在n个城市中建立一个通信网络，则连通这n个城市需要布置n-1一条通信线路，这个时候我们需要考虑如何在成本最低的情况下建立这个通信网？
于是我们就可以引入连通图来解决我们遇到的问题，n个城市就是图上的n个顶点，然后，边表示两个城市的通信线路，每条边上的权重就是我们搭建这条线路所需要的成本，所以现在我们有n个顶点的连通网可以建立不同的生成树，每一颗生成树都可以作为一个通信网，当我们构造这个连通网所花的成本最小时，搭建该连通网的生成树，就称为最小生成树。

构造最小生成树有很多算法，但是他们都是利用了最小生成树的同一种性质：MST性质（假设N=(V,{E})是一个连通网，U是顶点集V的一个非空子集，如果（u，v）是一条具有最小权值的边，其中u属于U，v属于V-U，则必定存在一颗包含边（u，v）的最小生成树），下面就介绍两种使用MST性质生成最小生成树的算法：普里姆算法和克鲁斯卡尔算法。

#### 普里姆算法—Prim算法

算法思路：
首先就是从图中的一个起点a开始，把a加入U集合，然后，寻找从与a有关联的边中，权重最小的那条边并且该边的终点b在顶点集合：（V-U）中，我们也把b加入到集合U中，并且输出边（a，b）的信息，这样我们的集合U就有：{a,b}，然后，我们寻找与a关联和b关联的边中，权重最小的那条边并且该边的终点在集合：（V-U）中，我们把c加入到集合U中，并且输出对应的那条边的信息，这样我们的集合U就有：{a,b,c}这三个元素了，一次类推，直到所有顶点都加入到了集合U。

下面我们对下面这幅图求其最小生成树：

p算法:
加边，for循环使为了避免森林的问题
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142767395-d89aa4a6-bcb7-41ff-864d-c22f8d464456.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142767572-6ccb7b09-4da9-4f6e-9400-93ecfc21b498.png)
这个有时间再回来看吧，后边学了并查集可以替代这个算法。



p算法和k算法，要求最小生成树,以及要求无向图

#### 克鲁斯卡算法

算法思路：
（1）将图中的所有边都去掉。
（2）将边按权值从小到大的顺序添加到图中，保证添加的过程中不会形成环
（3）重复上一步直到连接所有顶点，此时就生成了最小生成树。这是一种贪心策略。

这里同样我们给出一个和Prim算法讲解中同样的例子，模拟克鲁斯卡算法生成最小生成树的详细的过程：



k算法;
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142766500-43e8c50e-8913-4ed3-bed8-4232da9dc2d5.png)

定义一个比较器，然后按从小打大的顺序排列边，刚开始的时候每个节点是一个集合。然后一条一条的取出将边的两个节点加入到一个集合中，如果边的两个节点在一个集合中，就放弃这个边。直到只剩一个集合，也就是所有的节点已经联通了，同时使用到的边就是使集合联通的最小的权重。
用到的优先队列就是堆排序。



## 迪杰斯特拉算法

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768080-4cf6efd9-a5c4-4189-823b-9e9d2e63f60e.png)

规定了起点和终点，来算最短的路径
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768094-838451a3-d4dd-4e28-9359-3da6e5e989c8.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/142768230-963b952f-f4a1-4ffd-b760-9e45a1adf66d.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144153411-dac2e1b5-5a65-41ec-bedf-e718171fb0e6.png)
![Screenshot_2021-11-29-13-04-31-099_tv danmaku bil](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144153422-cc3c5bef-fce4-49b7-8101-d3a073755fd8.jpg)







# 暴力递归

## 递归实现字符串求值计算

可以用栈做，但是很麻烦。

不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。

![image-20220202172047991](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202172047991.png)

![image-20220202171131832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202171131832.png)



遇见括号就进行递归，让递归计算完括号内的部分，然后返回计算的值和计算到的位置，然后继续往下计算。



```java
public class StrToNum {
	public static void main(String[] args) {
		int a = value("4-(1+2)*3+1");
		System.out.println(a);
	}

	public static int value(String string) {
		if (string == null || string.length() == 0) {
			return 0;
		}
		return value(string.toCharArray(), 0)[0];
	}
    
//请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止
//返回两个值，长度为2的数组
	// 0)负责的这-段的结果是多少
	// 1) 负责的这- -段计算到了哪个位置
	private static int[] value(char[] str, int i) {
		LinkedList<String> list = new LinkedList<>();//双端队列，当成栈使用
		int num = 0;
		int[] bra = null;
		while (i < str.length && str[i] != ')') {
			if (str[i] >= '0' && str[i] <= '9') {
				num = num * 10 + str[i++] - '0';
			} else if (str[i] != '(') {
				addNum(list, num);
				list.addLast(String.valueOf(str[i++]));
				num = 0;
			} else {
				bra = value(str, i + 1);
				num = bra[0];
				i = bra[1] + 1;
			}

		}
		addNum(list, num);
		return new int[] { getNum(list), i };
	}
//不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。
	private static void addNum(LinkedList<String> list, int num) {
		if (!list.isEmpty()) {
			int cur = 0;
			String top = list.pollLast();
			if (top.equals("+") || top.equals("-")) {
				list.addLast(top);
			} else {
				cur = Integer.valueOf(list.pollLast());
				num = top.equals("*") ? (cur * num) : (cur / num);
			}
		}
		list.addLast(String.valueOf(num));

	}

	private static int getNum(LinkedList<String> list) {
		int res = 0;
		boolean add = true;
		String curString = null;
		int num = 0;
		while (!list.isEmpty()) {
			curString = list.pollFirst();
			if (curString.equals("+")) {
				add = true;
			} else if (curString.equals("-")) {
				add = false;
			} else {
				num = Integer.valueOf(curString);
				res += add ? num : (-num);
			}
		}
		return res;
	}
}

```



## [ 汉诺塔问题](https://leetcode-cn.com/problems/hanota-lcci/)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/143888259-7d85ba99-28c5-4d52-9597-930321814669.png)


采用递归的思路
三要素如下：
递归结束条件：只剩下最后一个盘子需要移动
递归函数主功能：
1.首先将 n-1 个盘子，从第一个柱子移动到第二个柱子
2.然后将最后一个盘子移动到第三个柱子上
3.最后将第二个柱子上的 n-1 个盘子，移动到第三个柱子上
函数的等价关系式：
f(n,A,B,C) 表示将n个盘子从A移动到C
f(n,A,B,C)=f(n-1,A,C,B)+f(1,A,B,C)+f(n-1,B,A,C)

```
class Solution {
    public void hanota(List<Integer> A, List<Integer> B, List<Integer> C) {
        movePlant(A.size(),A,B,C);
    }
    public void movePlant(int size, List<Integer> from, List<Integer> in, List<Integer> to){
        if(size==1){
            to.add(from.remove(from.size()-1));
            return;
        }
        movePlant(size-1,from,to,in);
         to.add(from.remove(from.size()-1));
         movePlant(size-1,in,from,to);
    }
}
```





## 不借助额外空间把栈逆序

![image-20220322214134780](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322214134780.png)

```java
import javax.swing.*;
import java.util.Stack;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/
public class reservestack {
    public static void main(String[] args) {
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < 10; i++) {
            stack.push(i);
        }
        reverse(stack);
        while (!stack.isEmpty()) {
            System.out.println(stack.pop());
        }

    }

    public static void reverse(Stack<Integer> stack) {
        if (stack.isEmpty()) {
            return;
        }
        //f 返回最下面的值,剩下的按照原来的排列
        int i = f(stack);
        //反转栈中剩下元素
        reverse(stack);
        //放入最后一个元素
        stack.push(i);

    }

    //返回栈中最下面的元素
    public static int f(Stack<Integer> stack) {
        int i = stack.pop();
        //如果拿到这个就直接返回给上层，不需要放进去了
        if (stack.isEmpty()) {
            return i;
        }
        //不是最后一个元素就继续递归
        int j = f(stack);
        //把这个放进去，顺序还是不变
        stack.push(i);
        return j;
    }
}

```



## ?-N皇后（最優解法）

![image-20220323223431345](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323223431345.png)

```java
class Main {
    public static int num(int num) {
        if (num < 1 || num > 32) return 0;
        //limit用于限制在所有数据运算过程中保证除后num位的所有位数据均为零，来判断结束和标志结束
        int limit = num == 32 ? -1 : (1 << num) - 1;
        return process(limit, 0, 0, 0);
    }

    /**
     * @param limit    限制数据在一定的位运算范围内
     * @param coLim    该步前所有皇后纵向上已经存在皇后
     * @param leftLim  该步前所有皇后在k=-1的方向上对于我们该步皇后存在的限制
     * @param rightLim 该步前所有皇后在k=1的方向上对于我们该步皇后存在的限制
     * @return 该路径上存在的的情况，只会在成功时返回1
     * coLim/leftLim/rightLim三者的限制均是在位上为1的时候表示存在皇后
     */
    private static int process(int limit, int coLim, int leftLim, int rightLim) {
        if (limit == coLim) return 1;

        //(coLim | leftLim | rightLim)结果表示所有位上为1的位置均存在皇后，不能存放。
        //~后表示1的地方没有限制，可以存放皇后（但是，在32位的前32-num位上也为1，我们知道这是不合理的，因为不存在那么多的皇后）
        //limit&    表示将除num位的值变成0，这样就保证所有为1的元素均为空缺位置。
        int pos = limit & (~(coLim | leftLim | rightLim));
        int res = 0, mostRightOne;
        while (pos != 0) {//pos为0.说明不存在空缺位置
            mostRightOne = pos & (~pos + 1);//此时在后num位存在1，就将最右端的1取出。
            res += process(limit, coLim | mostRightOne  // 该mostRightOne位的皇后对于下一皇后纵向上的影响
                    , (leftLim | mostRightOne) << 1     // mostRightOne对于k=-1方向的影响
                    , (rightLim | mostRightOne) >> 1);  //mostRightOne对于k=1方向的影响
            pos = pos - mostRightOne;//更新pos，将取出的1减掉，表明mostRightOne中1所对应的位存在了，不能放了。
        }
        return res;
    }
}

```



![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154459-ca341852-9d1f-40ad-8a27-d5bfc8b0fb8f.png)
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154742-1b451761-2ed2-4e48-bc5c-d71f75a5061e.png)

优化：
![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144154985-54ea35d8-11a6-481b-a243-8dd8c4dfe2b3.png)

![image](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/144155019-15c3e157-96eb-4b1e-b848-30d9a34cba2a.png)


回头再学习这一部分



## [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

![image-20220322223900565](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322223900565.png)

#### 深度优先搜索

```java
class Main {
    private static int[][] arr;
    private static int N;
    private static int M;
    public static int process(int[][] arr){
        PB.arr=arr;
        PB.N=arr.length;
        PB.M=arr[0].length;
        int res=0;//记录结果
        for (int i=0;i<N;i++){
            for (int j=0;j<M;j++){
                if (arr[i][j]==1){//有1且为被感染
                    res++;
                    infect(i,j);//感染
                }
            }
        }
        
        return res;
    }
    // 感染函数
    private static void infect(int i, int j) {
        if (i<0||i>=N||j<0||j>=M||arr[i][j]!=1)return;
        arr[i][j]=2;
        infect(i-1,j);
        infect(i+1,j);
        infect(i,j-1);
        infect(i,j+1);
    }
}






```



#### 方法二：广度优先搜索



```java
class Solution {
    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;

        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    grid[r][c] = '0';
                    Queue<Integer> neighbors = new LinkedList<>();
                    //这么计算，可以反向得出r和c，这样只用存一个
                    neighbors.add(r * nc + c);
                    while (!neighbors.isEmpty()) {
                        int id = neighbors.remove();
                        int row = id / nc;
                        int col = id % nc;
                        //相当于是上面的递归的过程，把相邻的四个位置设置成0，如果有1就放入栈中继续
                        if (row - 1 >= 0 && grid[row-1][col] == '1') {
                            neighbors.add((row-1) * nc + col);
                            grid[row-1][col] = '0';
                        }
                        if (row + 1 < nr && grid[row+1][col] == '1') {
                            neighbors.add((row+1) * nc + col);
                            grid[row+1][col] = '0';
                        }
                        if (col - 1 >= 0 && grid[row][col-1] == '1') {
                            neighbors.add(row * nc + col-1);
                            grid[row][col-1] = '0';
                        }
                        if (col + 1 < nc && grid[row][col+1] == '1') {
                            neighbors.add(row * nc + col+1);
                            grid[row][col+1] = '0';
                        }
                    }
                }
            }
        }

        return num_islands;
    }
}

```



#### 并查集

同样地，我们也可以使用并查集代替搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其与相邻四个方向上的 11 在并查集中进行合并。

最终岛屿的数量就是并查集中连通分量的数目。

下面的动画展示了整个算法。

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/41b6ce1794ba80a7a82b31dc4c0642b26ccd280457d254d2fdad37a1f5a73ca6-image.png)

```
class Solution {
    class UnionFind {
        int count;
        int[] parent;
        int[] rank;

        public UnionFind(char[][] grid) {
            count = 0;
            int m = grid.length;
            int n = grid[0].length;
            parent = new int[m * n];
            rank = new int[m * n];
            for (int i = 0; i < m; ++i) {
                for (int j = 0; j < n; ++j) {
                    if (grid[i][j] == '1') {
                        parent[i * n + j] = i * n + j;
                        ++count;
                    }
                    rank[i * n + j] = 0;
                }
            }
        }

        public int find(int i) {
            if (parent[i] != i) parent[i] = find(parent[i]);
            return parent[i];
        }

        public void union(int x, int y) {
            int rootx = find(x);
            int rooty = find(y);
            if (rootx != rooty) {
                if (rank[rootx] > rank[rooty]) {
                    parent[rooty] = rootx;
                } else if (rank[rootx] < rank[rooty]) {
                    parent[rootx] = rooty;
                } else {
                    parent[rooty] = rootx;
                    rank[rootx] += 1;
                }
                --count;
            }
        }

        public int getCount() {
            return count;
        }
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        UnionFind uf = new UnionFind(grid);
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    grid[r][c] = '0';
                    if (r - 1 >= 0 && grid[r-1][c] == '1') {
                        uf.union(r * nc + c, (r-1) * nc + c);
                    }
                    if (r + 1 < nr && grid[r+1][c] == '1') {
                        uf.union(r * nc + c, (r+1) * nc + c);
                    }
                    if (c - 1 >= 0 && grid[r][c-1] == '1') {
                        uf.union(r * nc + c, r * nc + c - 1);
                    }
                    if (c + 1 < nc && grid[r][c+1] == '1') {
                        uf.union(r * nc + c, r * nc + c + 1);
                    }
                }
            }
        }

        return uf.getCount();
    }
}

作者：LeetCode
链接：https://leetcode-cn.com/problems/number-of-islands/solution/dao-yu-shu-liang-by-leetcode/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## 返回字符串的所有子字符串（树形）

- 将该问题看成二分类问题，将所有的单个字符元素是否存在看成一个事件，通过对所有的单个字符判读存在情况就可以得出所有子字符串
- 这样可以理解为二叉树的情况，每一层的每个节点下有两个子节点，表示该层对应的字符是否添加进路径中，最后树的所有叶子节点对应的字符串就是所以子字符串
- 我们采用动态生成树的递归方法对树进行动态的遍历。（该树必定为满树）



```java
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/

public class substr {

    public static String str;
    public static StringBuffer sBuffer = new StringBuffer();

    public static void main(String[] args) {
        process("abcd");
    }
    public static void process(String string) {
        if (string == null || string.length() == 0) {
            return;
        }
        substr.str = string;
        process(0);
    }

    private static void process(int index) {
        if (index == str.length()) {
            System.out.println(sBuffer.toString());
            return;
        }
        //含有index位置的字符的子字符串
        sBuffer.append(str.charAt(index));
        process(index + 1);
        //不含有index位置的子字符串
        sBuffer.deleteCharAt(sBuffer.length() - 1);
        process(index + 1);
    }
}

```

### [剑指 Offer II 079. 所有子集](https://leetcode-cn.com/problems/TVdhkn/)

```
class Solution {
    public List<List<Integer>> lists = new ArrayList<>();
    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        if(n==0){
            return lists;
        }
        process(nums, 0, new ArrayList<Integer>());
        int count = lists.size();
        return lists;
    }
    public void process(int[] nums, int index,List<Integer> list){
            if(index==nums.length){
                lists.add(new ArrayList<>(list));
                return;
            }
            list.add(nums[index]);
            process(nums,index+1,list);
            list.remove(list.size() - 1);
            process(nums,index+1,list);
    }
}
```





## 最小字典序



![image-20220323215237572](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323215237572.png)

假设bcabca，这个字符串，第二个b往前的bca，在半部分都有多余的字符出现，也就是可以保留也可以不保留。因此可以在前半部分选择出一个最小的字符，从它往前的重复字符都舍弃，因为这个字符选择这个位置保存，其他位置的相同字符可以舍弃。然后继续递归剩下的部分，这样每次。都递归出最小的一个字符。拼接出来就是最终的结果

### 递归

```java
public class mindic {
    public static String process(String s) {
        if (s==null||s.length()<2)return s;
        int []map=new int[256];
        for (int i=0;i<s.length();i++){
            map[s.charAt(i)]++;
        }
        int minASCLLIndex=0;
        for (int i=0;i<s.length();i++){
                // 记录前面ASCLL最小的位置
                minASCLLIndex=s.charAt(minASCLLIndex)<s.charAt(i)?minASCLLIndex:i;
            if (--map[s.charAt(i)]==0){// 第一次发生一个字符的最后一次出现
                break;
            }
        }
        // minASCLLIndex后的字符串去掉s.charAt(minASCLLIndex)的字符串向后继续
        return  s.charAt(minASCLLIndex)+process(s.substring(minASCLLIndex+1).replaceAll(String.valueOf(s.charAt(minASCLLIndex)),""));
    }
}

```

### 栈

- 一直入栈，判断peek元素比当前大并且后面还存在和peek相同的字符，那么就从栈中删除栈顶元素。直到比当前遍历的小的，把这个字符放到栈中

```
class Solution {
    public String removeDuplicateLetters(String s) {
        int N = s.length();
        if (N <= 1) return s;
        char[] chars = s.toCharArray();
        Deque<Character> stack = new LinkedList<>();
        int[] lastIndex = new int[26];
        boolean[] isVisited = new boolean[26];
        for (int i = 0; i < N; i++) {
            lastIndex[chars[i] - 'a'] = i;
        }
        for (int i = 0; i < N; i++) {
            if (isVisited[chars[i] - 'a']) continue;
            while (!stack.isEmpty() && stack.peek() > chars[i] && lastIndex[stack.peek() - 'a'] > i) {
                isVisited[stack.pop() - 'a'] = false;
            }
            stack.push(chars[i]);
            isVisited[chars[i] - 'a'] = true;
        }
        StringBuffer stringBuffer = new StringBuffer();
        for (Character ch : stack) {
            stringBuffer.append(ch);
        }
        return stringBuffer.reverse().toString();
    }
}

```







# 递归转动态

## 机器人横向运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**



**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**



```java
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
     public static int[][] dp;
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
   
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20220323224837775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323224837775.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

`dp[i][j]`,i和j表示 从i位置开始走j步能到终点的方式数。basecase：`j==0的时候，只有i==j的时候才是1，其他位置为0，也就是第一行`

递归公式：

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



## 🐎飞棋盘（横向和纵向）

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```



**严格表结构**

`dp[i][j][k]`表示在（i,j）位置经过k步到达终点的路线数。
basecase：k为0的时候，只有i和j都为1的时候是1，其他位置为0，

状态转移方程：每个位置跟空间下一层（步数少一层的那一层）上八个相邻的位置相关。k为最外层循环，一层一层的（每次多一步）的往上计算

```java
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围
        dp[1][1][0] = 1;// 递归结束条件
        for (int k = 1; k <= K; k++) {// 步数
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```







## [377. 组合总和 Ⅳ](https://leetcode-cn.com/problems/combination-sum-iv/)

这个不同的顺序也是表示不同的组合，跟上面的不一样，上面的是不同的组合，只要硬币的数量和种类相同就算同一个方法

![image-20220324220240973](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324220240973.png)

```java
class Solution {
    public int combinationSum4(int[] nums, int target) {
        int[] dp = new int[target+1];
        dp[0]=1;
        for(int i=1;i<=target;i++){
            for(int num:nums){
                if(i-num>=0){
                dp[i]+=dp[i-num];
            }
            }
        }
        return dp[target];
    }
}
```



## [剑指 Offer II 081. 允许重复选择元素的组合](https://leetcode-cn.com/problems/Ygoe9J/)

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/) 

两个题目是一样的

递归+回溯

```java
class Solution {
    public  List<List<Integer>> res;
    public List<Integer> list;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        res = new ArrayList<List<Integer>>();
        list=new ArrayList<Integer>();
        process(candidates,target,0);
        return res;
    }
    public void process(int[] coins, int target,int index){
        if(target==0){
            res.add(new ArrayList<Integer>(list));
            return;
        }
        if(target<0||index>=coins.length){
            return;
        }
        process(coins,target,index+1);//不选当前银币，直接往下递归,注意index+1
        if(target>=coins[index]){
            list.add(coins[index]);
            process(coins,target-coins[index],index);//选择一个硬币，注意index保持不变，因为只选了一个，下一个递归还可以接着选index位置的银币
            list.remove(list.size()-1);
        } 
       

    }
}
```

## [剑指 Offer II 080. 含有 k 个元素的组合](https://leetcode-cn.com/problems/uUsW3B/)

跟上个题方法类似，但是不允许有重复的数字出现。

这个也可以改成0-1背包的答案

![image-20220324222625396](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324222625396.png)

```java

class Solution {
    public List<List<Integer>> res;
    public List<Integer> tem;
    public List<List<Integer>> combine(int n, int k) {
        res = new ArrayList<List<Integer>>();
        tem = new ArrayList<Integer>();
        dfs(n,k,1);
        return res;
    }
    public void dfs(int n,int k, int index){
          // 剪枝：即使把从th开始的所有数都放入list也凑不齐k个，所以直接返回
        if(n-index+1<k) return;
        if(k==0){
            res.add(new ArrayList<Integer>(tem));
            return;
        }
        // 搜索策略一：组合中有第th个
        tem.add(index);
        dfs(n, k-1,index+1);
        tem.remove(tem.size()-1);
        // 搜索策略二：组合中没有第th个
        dfs(n,k,index+1);

    }
}
```







## 数字转化成字母（树形）

![image-20220322220646143](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220322220646143.png)

**递归实现**

- 时间复杂度为指数级

```java
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```



**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
- 时间复杂度为O(N)

```java
public class Main {
	public static int process(String string) {
		if (string == null || string.length() == 0) {
			return 0;
		}
		if (string.length() == 1) {
			return string == "0" ? 0 : 1;
		}
		char[] arr = string.toCharArray();
		int N = arr.length;
		int[] res = new int[arr.length + 1];
		res[N] = 1;//为空的时候默认是1.base case
		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;//0不能作为前缀，只有一个字符的时候是1
		for (int i = N - 2; i >= 0; --i) {
			if (arr[i] == '0') {
				res[i] = 0;//0不能作为前缀
			} else {
				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
					res[i] = res[i + 1];//i不能与i+1组成数字
				} else {
					res[i] = res[i + 1] + res[i + 2];//i能和i+1组合为一个新的数，这时候就是i+2种可能，i单独的时候就是i
				}
			}
		}
		return res[0];
	}
}

```





## 背包问题（树形）

![image-20220324230449495](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324230449495.png)



- 和返回字符串的所有子字符串相似，判断每个物品是否装进了袋子两种选择
- 只需要用递归像树一样遍历所有选择取出最大值即可
- 这样的题可以使用动态规划O(N²),递归O(2^N)

### 暴力递归

```java
public class Main {
    private static int maxBag;
    private static int[] weights;
    private static int[] values;

    public static int process(int[] weights, int[] values, int maxBag) {
        Main.maxBag = maxBag;
        Main.weights = weights;
        Main.values = values;
        return process(maxBag, 0);
    }

    /**
     * @param w 剩余空间
     * @param i 当前已经判断到那个物品了
     * @return 最大价值
     */
    private static int process(int w, int i) {
        if (i == weights.length) return 0;
        if (w < weights[i]) return process(w, i + 1);
        return Math.max(process(w, i + 1), process(w - weights[i], i + 1) + values[i]);
    }
}

```

### **动态规划**

`dp[i][j]`状态：前i件商品，在重量上限为j的时候，能装货物的最大价值

初始值： i为0的时候，表示没有商品。价值只能为0

​				j为0的时候，没法装物品，也只能为0

返回值：`dp[weight.length][maxbag]`

```java
public class Main {
    public static int process(int[] weights, int[] values, int maxBag) {
        int[][] dp = new int[weights.length + 1][maxBag + 1];
        for (int i = 1; i <= weights.length; i++) {
            for (int j = 0; j <= maxBag; j++) {
                if (j < weights[i - 1]) dp[i][j] = dp[i - 1][j];//装不下这个物品
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j] + values[i - 1]);//装得下，装与不装选个最大值
            }
        }
        return dp[weights.length][maxBag];
    }
}

```

空间好像没办法剩压缩



## 整数分裂

![image-20220210091257710](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210091257710.png)

分裂以后必须递增，

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }    //pre是要进行（还没被分出去）进行分裂的值，一般都是从1开始递增。curRes是这个操作之前还没有分裂的数。

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes)
            return 0;//得保证裂开的序列是递增的。所以大于就得停止，没法往下走//
        int ways = 0;        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }
}

```

![image-20220210092404108](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210092404108.png)





**记忆化搜索**

```
import java.util.Arrays;

public class Main {
    public static int[][] dp;

    public static int process(int res) {
        if (res < 1) return 0;
        dp = new int[res + 1][res + 1];
        for (int[] i : dp) {
            Arrays.fill(i, -1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre      
        if (dp[pre][curRes] != -1) return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes] = 1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes] = 0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes] = ways;
        return ways;
    }
}
```

也就是记录一下每次递归的值

![image-20220210093203421](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210093203421.png)



**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];// dp[i][j]表示，第一个值是pre，剩下j（还没有分出去pre）有多少种组合
        for (int i = 0; i <= res; i++) {// 递归结束条件//
            dp[i][0] = 1;//0表示分配i个，但是目前剩余0个分配，只能有一种，就是不分配，空
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱，剩余值表示目前可以进行分配的值，还没有分配pre。
                for (int i = pre; i <= curRes; i++) {// 所有情况累加，
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}
```

![image-20220210094755553](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220210094755553.png)

第一列置为1，表示 curRes==0的时候，返回1，表示是一种成功的分裂的结果。

我们只需要对角线以上的部分就行了。因为pre得小于rest。



**斜率优化**

![image-20220326214737296](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220326214737296.png)



```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        dp[res][res]=1;// 根据下一层退出结果，所以要先对最后一层就行添值
        for (int pre = res-1; pre >= 1; pre--) {// 前驱
            for (int curRes = pre ; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                dp[pre][curRes]=dp[pre+1][curRes]+dp[pre][curRes-pre];// 分析的关系
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```



## 人气值

![image-20220118235953006](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235953006.png)



**错误代码**

- 没有考虑条件结束情况，也就是没有basecase
  ![image-20220119091240024](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119091240024.png)

```
public class Test {
    public static void process1(int start, int x, int y, int z, int end) {
        func(x, y, z, end, start);
    }

    private static int func(int x, int y, int z, int end, int thisNum) {
        if (end == thisNum) {
            return 0;
        }
        int resX = func(x, y, z, end, thisNum + 2) + x;
        int resY = func(x, y, z, end, thisNum * 2) + y;
        int resZ = func(x, y, z, end, thisNum - 2) + z;
        return Math.min(resX, Math.min(resY, resZ));
    }
}
```



**暴力递归**

上面缺少basecase,导致递归无法结束。因此最好的方法

根据题目内容找出一个不是最优解的平凡解作为上限，找出边界条件（比如负值）作为下限，超过这个范围就终止返回错误值。



```java
public class Main {
    public static int x, y, z, target, generalSolution;

    public static int process1(int x, int y, int z, int start, int end) {
        Main.x = x;
        Main.y = y;
        Main.z = z;
        Main.target = end;
        Main.generalSolution = (end - start) / 2 * x;        //自己推出来的平凡解，该解是该题的一个解 不知道是不是最右，但是最优值定少于等于该值        
        return func(start, 0);
    }

    /**
     * @param thisNum 当前人气     * @param coinsNum 当前消费的硬币量     * @return 该路径上所消费的硬币数量
     */
    private static int func(int thisNum, int coinsNum) {
        if (target == thisNum) {
            return coinsNum;
        }
        if (coinsNum > generalSolution) {
            return Integer.MAX_VALUE;
        }
        if (coinsNum < 0) {
            return Integer.MAX_VALUE;
        }
        int resX = func(thisNum + 2, coinsNum + x);
        int resY = func(thisNum * 2, coinsNum + y);
        int resZ = func(thisNum - 2, coinsNum + z);
        return Math.min(resX, Math.min(resY, resZ));
    }
}
```



**动态规划**

```java
public class Main {
    public static int process(int x, int y, int z, int start, int target) {
        int generalSolution = (target - start) / 2 * x;
        //表示每个target对应最大的硬币数，不会超过这个银币数的，        
        /int max = Math.max(x, Math.max(y, z));
        int[][] dp = new int[target + 1][generalSolution + max + 1];//第一维度表示当前的人气值，第二维度表示当前消费的硬币量        
        for (int i = 0; i <= generalSolution; i++) {
            dp[target][i] = i;
        }
        for (int i = generalSolution; i <= generalSolution + max; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for (int coinsConsume = generalSolution; coinsConsume >= 0; coinsConsume--) {
            for (int thisNum = start; thisNum <= target; thisNum++) {
                dp[thisNum][coinsConsume] = Math.min(dp[thisNum + 2][coinsConsume + x], Math.min(dp[thisNum * 2][coinsConsume + y], dp[thisNum - 2][coinsConsume + z]));
            }
        }
        return dp[start][0];
    }
}
```



![image-20220119093939360](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119093939360.png)



## 数组博弈最值



![image-20220324232849864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324232849864.png)

### 递归

```java
public class Main {
    public static int win(int[] arr) {
        return Math.max(f(arr, 0, arr.length - 1), e(arr, 0, arr.length - 1));
    }

    // 先手情况： 当前取值和下一次作为的后手结合的情况取最大值，就剩一个时那么结果直接取走
    public static int f(int[] arr, int l, int r) {
        if (l == r) return arr[l];
        return Math.max(arr[l] + e(arr, l + 1, r), arr[r] + e(arr, l, r - 1));
    }

    // 作为后手进行定是取值最小，剩一个元素就返回0
    public static int e(int[] arr, int l, int r) {
        if (l == r) return 0;
        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));
    }
}

```

### **动态规划**

![image-20220324232951952](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324232951952.png)



```
public class Main {
    public static int process(int[] arr) {
        int N = arr.length;
        int[][] front = new int[N][N];
        for (int i = 0; i < N; i++) {
            front[i][i] = arr[i];
        }
        int[][] end = new int[N][N];
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j++) {
                front[i][j] = Math.max(arr[i] + end[i + 1][j], arr[j] + end[i][j - 1]);
                end[i][j] = Math.min(front[i + 1][j], front[i][j - 1]);
            }
        }
        return Math.max(front[0][N - 1], end[0][N - 1]);
    }
}

```



### 测试

i和1傻傻分不清

```java

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/22
 * @Version 1.0
 **/
public class playcards {
    public static void main(String[] args) {
        playcards a = new playcards();
        int[] arr = new int[]{1, 2,3,4};
        System.out.println(a.win1(arr));
    }

    public int win1(int[] arr) {
        if (arr == null || arr.length == 0) {
            return 0;
        }
        return Math.max(f(arr, 0, arr.length - 1), s(arr, 0, arr.length - 1));
    }

    public int f(int[] arr, int i, int j) {
        System.out.println("f" + i + ":" + j);
        if (i == j) {
            return arr[i];
        }
        return Math.max(arr[i] + s(arr, i + 1, j), arr[j] + s(arr, i, j - 1));
    }

    public int s(int[] arr, int i, int j) {
        System.out.println("s" + i + ":" + j);
        if (i == j) {
            System.out.println(0);
            return 0;
        }
        return Math.min(f(arr, i + 1, j), f(arr, i, j - 1));
    }

//     public static int win2(int[] arr) {
//         if (arr == null || arr.length == 0) {
//             return 0;
//         }
//
//     }
}

```







## 真假情况

![image-20220324233058168](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324233058168.png)



相当于给定了数列，我们只能加小括号改变运算的顺序，数字和字符的位置不能变动





### **递归实现**

```
class Test {

	
	//函数入口
    public static int num1(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        return p(exp, desired, 0, exp.length - 1);
    }




    private static int p(char[] exp, boolean desired, int L, int R) {
    	//basecase：L=R的时候，只有一个字符,是desired的话就返回1表示这个是符合的一种方法，否则返回0
        if (L == R) {
            if (exp[L] == '1') {
                return desired ? 1 : 0;
            } else {
                return desired ? 0 : 1;
            }
        }
        
        int res = 0;
        
        if (desired) {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        break;
                }
            }
        } else {
            for (int i = L + 1; i < R; i += 2) {
                switch (exp[i]) {
                    case '&':
                        res += p(exp, false, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, true, L, i - 1) * p(exp, false, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '|':
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                    case '^':
                        res += p(exp, true, L, i - 1) * p(exp, true, i + 1, R);
                        res += p(exp, false, L, i - 1) * p(exp, false, i + 1, R);
                        break;
                }
            }
        }
        return res;
    }
    	//验证是不是符合要求的字符串
    private static boolean isValid(char[] exp) {
    	//长度必须是奇数
        if ((exp.length & 1) == 0) {
            return false;
        }
        // 奇数位必须是0或者1
        for (int i = 0; i < exp.length; i = i + 2) {
            if ((exp[i] != '1') && (exp[i] != '0')) {
                return false;
            }
        }
        //偶数位必须为运算符
        for (int i = 1; i < exp.length; i = i + 2) {
            if ((exp[i] != '&') && (exp[i] != '|') && (exp[i] != '^')) {
                return false;
            }
        }
        return true;
    }
}

```

### **动态规划**

改成动态规划

一个三维表，三个变量。

或者搞两个表，一个是true表，一个是false表

![image-20220119220612585](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220612585.png)





```java
class Test {
    public static int num2(String express, boolean desired) {
        if (express == null || express.equals("")) {
            return 0;
        }
        char[] exp = express.toCharArray();
        if (!isValid(exp)) {
            return 0;
        }
        int[][] t = new int[exp.length][exp.length];//表示i到j范围内是true或者是false的结果有几种组合
        int[][] f = new int[exp.length][exp.length];
        t[0][0] = exp[0] == '0' ? 0 : 1;
        f[0][0] = exp[0] == '1' ? 0 : 1;
        for (int i = 2; i < exp.length; i += 2) {
            t[i][i] = exp[i] == '0' ? 0 : 1;
            f[i][i] = exp[i] == '1' ? 0 : 1;
            //表示i到j范围内，是true或者false的有几种
            for (int j = i - 2; j >= 0; j -= 2) {
                //遍历i到j的每每一个值，表示从k处分割i到j范围为两段，两个字段的综合结果就是i到j范围的可能性划分
                for (int k = j; k < i; k += 2) {
                    //0和1的各种运算
                    if (exp[k + 1] == '&') {
                        
                        t[j][i] += t[j][k] * t[k + 2][i];
                        f[j][i] += (f[j][k] + t[j][k]) * f[k + 2][i] + f[j][k] * t[k + 2][i];
                    } else if (exp[k + 1] == '|') {
                        t[j][i] += (f[j][k] + t[j][k]) * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i];
                    } else {
                        t[j][i] += f[j][k] * t[k + 2][i] + t[j][k] * f[k + 2][i];
                        f[j][i] += f[j][k] * f[k + 2][i] + t[j][k] * t[k + 2][i];
                    }
                }
            }
        }
        return desired ? t[0][t.length - 1] : f[0][f.length - 1];
    }
}

```



## 能力蛇最大长度问题![image-20220202161741538](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202161741538.png)

![image-20220202162345377](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202162345377.png)



**递归实现**

```
class Main {
	public static int walk1(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
		int res = Integer.MIN_VALUE;
		for (int i = 0; i < matrix.length; i++) {
			int[] ans = process(matrix, i, 0);
			res = Math.max(res, Math.max(ans[0], ans[1]));
		}
		return res;
	}

	public static int fun(int[][] m) {
		int res = Integer.MIN_VALUE;
		for (int i = 0; i < m.length; i++) {
			int ans = fun(m, i, 0, 0, false);
			res = Math.max(res, ans);
		}
		return res;
	}

	// 从(i,j)出发一直走到最右侧的旅程中
	// 0) 在没有使用过能力的情况下，返回路径最大和
	// 1) 在使用过能力的情况下，返回路径最大和
	//从后往前推，从最后一个格子推到第一个格子
	public static int[] process(int[][] m, int i, int j) {
		//到达最后一列，返回该单位格子使用能力或者不使用能力的能给蛇增加的长度
		if (j == m[0].length - 1) {
			return new int[] { m[i][j], -m[i][j] };
		}
		//继续往下面三个格子走，能增加的长度，分别
		//右边
		int[] restAns = process(m, i, j + 1);
		int restUnuse = restAns[0];
		int restUse = restAns[1];
		
		//右下
		if (i - 1 >= 0) {
			restAns = process(m, i - 1, j + 1);
			restUnuse = Math.max(restUnuse, restAns[0]);
			restUse = Math.max(restUse, restAns[1]);
		}
		//右上
		if (i + 1 < m.length) {
			restAns = process(m, i + 1, j + 1);
			restUnuse = Math.max(restUnuse, restAns[0]);
			restUse = Math.max(restUse, restAns[1]);
		}
		//
		int no = m[i][j] + restUnuse;
		int yes = Math.max(m[i][j] + restUse, -m[i][j] + restUnuse);
		return new int[] { no, yes };
	}
}

```

**动态规划**

写的有问题，没有判断前一个位置为负数的情况。如果前一个位置为负数，说明游戏结束，下一个位置不应该到达。

```java
class Main {
	public static int walk2(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
        
		int[][][] dp = new int[matrix.length][matrix[0].length][2];
        //走到i、j位置，使用能力和不使用能力的最大值
        //basecase，第一列的值
		for (int i = 0; i < dp.length; i++) {
			dp[i][matrix[0].length - 1][0] = matrix[i][matrix[0].length - 1];
			dp[i][matrix[0].length - 1][1] = -matrix[i][matrix[0].length - 1];
		}
		for (int j = matrix[0].length - 2; j >= 0; j--) {
			for (int i = 0; i < matrix.length; i++) {
				int restUnuse = dp[i][j + 1][0];
				int restUse = dp[i][j + 1][1];
				if (i - 1 >= 0) {
					restUnuse = Math.max(restUnuse, dp[i - 1][j + 1][0]);
					restUse = Math.max(restUse, dp[i - 1][j + 1][1]);
				}
				if (i + 1 < matrix.length) {
					restUnuse = Math.max(restUnuse, dp[i + 1][j + 1][0]);
					restUse = Math.max(restUse, dp[i + 1][j + 1][0]);
				}
				dp[i][j][0] = matrix[i][j] + restUnuse;
				dp[i][j][1] = Math.max(matrix[i][j] + restUse, -matrix[i][j] + restUnuse);
			}
		}

		int res = Integer.MIN_VALUE;
		for (int i = 0; i < matrix.length; i++) {
			res = Math.max(res, Math.max(dp[i][0][0], dp[i][0][1]));
		}
		return res;
	}
}

```

## bob活着

题目：**给定范围横向N，纵向M，从（i，j）开始走K步（只能上下左右走，且概率相同）没有超过给定范围那么就是活着，如果在过程中超过了范围则死了，返回活着的概率。**

### **递归实现**

```java
public class Main {

    public static int N, M;

    public static String process(int n, int m, int i, int j, int k) {
        N = n;
        M = m;
        int live = process(i, j, k);// 活着的情况
        int all = (int) Math.pow(4, k);// 一共存在的情况
        int gcb = gcb(all, live);// 求最大公约数
        return live / gcb + " / " + all / gcb;
    }

    private static int gcb(int m, int n) {
        if (n == 0) return m;
        return gcb(n, m % n);
    }

    // 计算活着的情况数
    public static int process(int i, int j, int K) {
        if (i < 1 || i > N || j < 1 || j > M) return 0;
        if (K == 0) return 1;
        return process(i + 1, j, K - 1) +
                process(i - 1, j, K - 1) +
                process(i, j + 1, K - 1) +
                process(i, j - 1, K - 1);
    }
}

```

### **严格表结构**

```java
class U {
    public static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    public static String bob2(int N, int M, int i, int j, int K) {
        int[][][] dp = new int[N + 2][M + 2][K + 1];  //x坐标，y坐标，还有几步没走到达
        //如果剩下0步的时候能走到row,col位置就是存活，否则就是死去了。
        for (int row = 1; row <= N; row++) {//初始化数据
            for (int col = 1; col <= M; col++) {
                dp[row][col][0] = 1;
            }
        }
        for (int rest = 1; rest <= K; rest++) {
            for (int row = 1; row <= N; row++) {
                for (int col = 1; col <= M; col++) {
                	//递归依赖
                    dp[row][col][rest] = dp[row - 1][col][rest - 1];
                    dp[row][col][rest] += dp[row + 1][col][rest - 1];
                    dp[row][col][rest] += dp[row][col - 1][rest - 1];
                    dp[row][col][rest] += dp[row][col + 1][rest - 1];
                }
            }
        }
        long all = (long) Math.pow(4, K);
        long live = dp[i + 1][j + 1][K];
        long gcd = gcd(all, live);
        return (live / gcd) + "/" + (all / gcd);
    }
}

```





# 动态规划

## [095. 最长公共子序列](https://leetcode-cn.com/problems/qJnOS7/)

注意子字符串可以不连续

![image-20220327011241496](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327011241496.png)

状态：`dp[i][j]`表示以str1 0到i，str2以0到j结尾的有相同子串的长度

basecase，`i==0或者j==0的时候表示其中一个为空，dp值为0`

状态转移：

![image-20220327214344459](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327214344459.png)

![image-20220327214602404](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327214602404.png)





```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null || text1.equals("") || text2.equals("")) {
			return 0;
		}
        int len1=text1.length();
        int len2=text2.length();
        int[][] dp=new int[len1+1][len2+1];
        for(int i =1 ; i<=len1;i++){
            for(int j = 1;j<=len2;j++){
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[i][j]=dp[i-1][j-1]+1;
                }else{
                    dp[i][j]=Math.max(dp[i-1][j],dp[i][j-1]);
                }
            }
        }
        return dp[len1][len2];
    }
}
```



空间优化：

使用两个一位数组

```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int m = text1.length(), n = text2.length();
        int[][] dp = new int[2][n + 1];
        for (int i = 1; i <= m; i++) {
            int r = i % 2;
            char c1 = text1.charAt(i - 1);
            for (int j = 1; j <= n; j++) {
                char c2 = text2.charAt(j - 1);
                if (c1 == c2) {
                    dp[r][j] = dp[1 - r][j - 1] + 1;
                } else {
                    dp[r][j] = Math.max(dp[1 - r][j], dp[r][j - 1]);
                }
            }
        }
        return dp[m % 2][n];
    }
}
```

## ?-[1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)



## 最长相同子字符串



![image-20220327215735318](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327215735318.png)

跟上个题不一样，这个要连续的

状态：`dp[i][j]`表示以str1 0到i（包含），str2以0到j（包含）结尾的有相同子串的长度，必须包含i和j位置的字符

basecase，`i==0或者j==0的时候表示其中一个只有一个字符，遍历另一个看相同不相同就好了`

第一行第一列

![image-20220204220538864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204220538864.png)



然后根据该位置相不相等，相等就左上角的格子值加一，不等就是0

**动态规划**

```
public class Main {
	public static String lcst1(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int[][] dp = getdp(chs1, chs2);
		int end = 0;
		int max = 0;
		// 记录最长子串
		for (int i = 0; i < chs1.length; i++) {
			for (int j = 0; j < chs2.length; j++) {
				if (dp[i][j] > max) {
					end = i;
					max = dp[i][j];
				}
			}
		}
		return str1.substring(end - max + 1, end + 1);
	}

	public static int[][] getdp(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		for (int i = 0; i < str1.length; i++) {
			if (str1[i] == str2[0]) {
				dp[i][0] = 1;
			}
		}
		for (int j = 1; j < str2.length; j++) {
			if (str1[0] == str2[j]) {
				dp[0][j] = 1;
			}
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				if (str1[i] == str2[j]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
			}
		}
		return dp;
	}
}

```

**空间压缩**

![image-20220204231051332](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204231051332.png)

因为每个位置只与左上角的值相关，因此可以定义一个变量斜着计算就可以了。

```
class Main {
	public static String lcst2(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		//从右上角开始计算
		int row = 0;
		int col = chs2.length - 1;
		int max = 0;
		int end = 0;
		while (row < chs1.length) {
			int i = row;
			int j = col;
			int len = 0;//表示子字符串的长度，一行一行计算，初始值为0，对角线进行计算
			while (i < chs1.length && j < chs2.length) {
				if (chs1[i] != chs2[j]) {
					len = 0;
				} else {
					len++;
				}
				if (len > max) {
					end = i;
					max = len;
				}
				//按对角线进行计算，往右下角走
				i++;
				j++;
			}
			//row到头走col
			if (col > 0) {
				col--;
			} else {
				row++;
			}
		}
		return str1.substring(end - max + 1, end + 1);
	}
}

```











## 硬币结合动归

![image-20220125222729980](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125222729980.png)



```java
public class Main {
    public static int moneyWays(int[] arbitrary, int[] onlyOne, int money) {
        int[][] arbDp = getArbDp(arbitrary, money);
        int[][] onlyDp = getOnDp(onlyOne, money);
        //arbDp和onlyDp第一行就是所想要的情况数
        int result = 0;
        for (int i = 0; i <= money; i++) {
            result += arbDp[0][i] * onlyDp[0][money - i];
        }
        return result;
    }

    private static int[][] getOnDp(int[] onlyOne, int money) {
        int[][] dp = new int[onlyOne.length + 1][money + 1];
        for (int i = 0; i < onlyOne.length; i++) {
            dp[i][0] = 1;
        }
        for (int coinIndex = onlyOne.length - 1; coinIndex >= 0; coinIndex--) {
            for (int resMoney = 0; resMoney <= money; resMoney++) {
                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];
                if (resMoney > onlyOne[coinIndex]) {// 倘若可以挑选当前的一个硬币
                    //因为不能重复，因此加上上面的一行，coinIndex + 1
                    dp[coinIndex][resMoney] += dp[coinIndex + 1][resMoney - onlyOne[coinIndex]];
                }
            }
        }
        return dp;
    }

    private static int[][] getArbDp(int[] arbitrary, int money) {
        int[][] dp = new int[arbitrary.length + 1][money + 1];
        for (int i = 0; i <= arbitrary.length; i++) {
            dp[i][0] = 1;
        }
        for (int coinIndex = arbitrary.length - 1; coinIndex >= 0; coinIndex--) {
            for (int resMoney = 0; resMoney <= money; resMoney++) {
                //不选当前index的硬币
                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];
                // 倘若可以挑选当前的一个硬币
                if (resMoney > arbitrary[coinIndex]) {
                    //因为可以重复，因此可以加上同一行前面的位置
                    dp[coinIndex][resMoney] += dp[coinIndex][resMoney - arbitrary[coinIndex]];
                }

            }
        }
        return dp;
    }
}

```







## [不同路径 II](https://leetcode-cn.com/problems/unique-paths-ii/)

![image-20220323234801080](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220323234801080.png)

```
class Solution {
    public int uniquePathsWithObstacles(int[][] obstacleGrid) {
        int n = obstacleGrid.length, m = obstacleGrid[0].length;
        int[] f = new int[m];

        f[0] = obstacleGrid[0][0] == 0 ? 1 : 0;
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < m; ++j) {
                if (obstacleGrid[i][j] == 1) {
                    f[j] = 0;
                    continue;
                }
                if (j - 1 >= 0 && obstacleGrid[i][j - 1] == 0) {
                    f[j] += f[j - 1];
                }
            }
        }
        
        return f[m - 1];
    }
}

```



## [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

​	

`根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j) 表示字符串 ss 的第 i 到 j个字母组成的串（下文表示成 s[i:j]）是否为回文串。`

![image-20220327231453792](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327231453792.png)





```java
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}

```



## [516. 最长回文子序列](https://leetcode-cn.com/problems/longest-palindromic-subsequence/)

**序列是可以不连续的，只要字符按顺序即可。子串是必须连续的。**

![image-20220205223706137](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223706137.png)

`dp[i][j]`表示i到j范围上的最长回文字符串的值，`dp[0][length-1]`就是最终的结果，

1.对角线表示一个字符串的场景，值都是1.

2.对角线上面那一列表示两个字符的时候，直接看相等不相等就好了

![image-20220205231955441](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205231955441.png)

然后状态转移有四种情况，需要左边，左下和下面三个格子的值。从下往上，从左往右一行一行填写

![image-20220205232344425](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205232344425.png)





- 直接DP。注意上面的四种情况，第一种已经包含在第二种和第三种之间，因此不用考虑第一种。

```java
class PalindromeSubsequence {

	public static int maxLen(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		char[] str1 = str.toCharArray();
		char[] str2 = reverse(str1);
		return lcse(str1, str2);
	}

	private static char[] reverse(char[] str) {
		char[] reverse = new char[str.length];
		for (int i = 0; i < reverse.length; i++) {
			reverse[i] = str[str.length - 1 - i];
		}
		return reverse;
	}

	private static int lcse(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		dp[0][0] = str1[0] == str2[0] ? 1 : 0;
		for (int i = 1; i < str1.length; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
		}
		for (int j = 1; j < str2.length; j++) {
			dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				if (str1[i] == str2[j]) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
				}
			}
		}
		return dp[str1.length - 1][str2.length - 1];
	}
}

```



- 求逆序串和该串的最长公共子序列,就是该字符串的最长回文子序列，`dp[i][j]`跟上面的概念不一样了。dp数组的状态就是到str1的0到i的子字符串和str2的子字符串0到j，最长能构成的相同子序列的长度。参考上面**相同最长子序列**的解法

```
class Solution {
    public int longestPalindromeSubseq(String s) {
	if (s == null || s.length() == 0) {
			return 0;
		}
		char[] str = s.toCharArray();
		int[][] dp = new int[str.length][str.length];
		for (int i = 0; i < str.length; i++) {
			dp[i][i] = 1;
		}
		for (int i = 0; i < str.length - 1; i++) {
			dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;
		}
        for(int i = str.length - 2; i >= 0; i--){
            for(int j = i+2;j<str.length;j++){
                dp[i][j]=Math.max(dp[i+1][j],dp[i][j-1]);
                if(str[i]==str[j]){
                    dp[i][j]=Math.max(dp[i+1][j-1]+2,dp[i][j]);
                }
            }
        }
        return dp[0][str.length-1];
    }
}
```



官方解法

```java
class Solution {
    public int longestPalindromeSubseq(String s) {
        int n = s.length();
        int[][] dp = new int[n][n];
        //一定是从下往上
        for (int i = n - 1; i >= 0; i--) {
            dp[i][i] = 1;
            char c1 = s.charAt(i);
            for (int j = i + 1; j < n; j++) {
                char c2 = s.charAt(j);
                if (c1 == c2) {
                    //如果i>j，比如i=2，j=3，因为dp[3][2]默认为0，所以不影响结果
                    dp[i][j] = dp[i + 1][j - 1] + 2;
                } else {
                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[0][n - 1];
    }
}

```





![image-20220205174605513](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205174605513.png)

状态：`dp[i][j]`状态就是从i到j需要增加多少字符才能构成回文串。对角线上只有一个字符，构成回文串，因此是0。对角线上面一个线，两个字符的时候，相等就是0，不等就是1。一定是根据开头和结尾讨论可能性。也是分四种情况：

1.添加i，也就是等于`dp[i+1][j]`+1

2.添加j，也就是等于`dp[i][j-1]`+1

2.i==j的时候，也就是等于`dp[i+1][j-1]`

然后把这个路径记录下来就可以了





![image-20220206164435092](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206164435092.png)



三种情况选最少的值。basecase就是对角线和对角线上面的那个斜线。

最终的值就是dp【0】【len-1】的值。

先从下往上，从左往右依次填写

![image-20220206164928474](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206164928474.png)

```java
public class PalindromeMinAdd {

	public static String getPalindrome1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) {
					dp[i][j] = dp[i + 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		char[] res = new char[chas.length + dp[0][chas.length - 1]];
		int i = 0;
		int j = chas.length - 1;
		int resl = 0;
		int resr = res.length - 1;
		while (i <= j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) {
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else {
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}

}

```

## 删除元素构成回文方法数量

![image-20220206190530610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206190530610.png)

**范围尝试的dp**

`dp[i][j]`表示【i。。。。j】范围上，有多少种保留的方案，包括必须i或者j位置字符的可能性。这个位置的值有四种情况的和构成。i和j包含不包含的关系，。

但是dp【i】【j-1】等于第3种和第4种的可能之和了，因为反正都没j。

dp【i+1】【j】等于第3种和第2种之和，都没i。相加多了一个三情况。

第1种情况只有`i==j`的时候才存在。当`i==j`的时候,比dp【i+1】【j-1】多了一种情况就是只保留i和j位置的时候，构成一个回文字符串。因此等于dp【i+1】【j-1】+1(i和j不动，i+1和j-1可以变化，因此为).i和j不相等，就是0.

![image-20220206192519897](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206192519897.png)

所有的解为：

![image-20220206193217882](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206193217882.png)



例子，全量且互斥

![image-20220206192006705](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206192006705.png)

```
class PalindromeWays {

	public static int way1(String str) {
		char[] s = str.toCharArray();
		int len = s.length;
		//`dp[i][j]`表示【i。。。。j】范围上，有多少种保留的方案，
		int[][] dp = new int[len + 1][len + 1];
		//只有一个字符的时候为一种可能
		for (int i = 0; i <= len; i++) {
			dp[i][i] = 1;
		}
		//subLen表示长度如果
		for (int subLen = 2; subLen <= len; subLen++) {
			for (int l = 1; l <= len - subLen + 1; l++) {
				int r = l + subLen - 1;
				dp[l][r] += dp[l + 1][r];
				dp[l][r] += dp[l][r - 1];
				if (s[l - 1] == s[r - 1])
					dp[l][r] += 1;
				else
					dp[l][r] -= dp[l + 1][r - 1];
			}
		}
		return dp[1][len];
	}

	public static int way2(String str) {
		char[] s = str.toCharArray();
		int n = s.length;
		int[][] dp = new int[100][100];
		for (int i = 0; i < n; i++) {
			dp[i][i] = 1;
			if (i + 1 < n && s[i] == s[i + 1])
				dp[i][i + 1] = 3;
			else
				dp[i][i + 1] = 2;
		}
		for (int p = 2; p < n; ++p) {
			for (int i = 0, j = p; j < n; ++i, ++j)
				if (s[i] == s[j])
					dp[i][j] = dp[i + 1][j] + dp[i][j - 1] + 1;
				else
					dp[i][j] = dp[i + 1][j] + dp[i][j - 1] - dp[i + 1][j - 1];
		}
		return dp[0][n - 1];
	}
}


```









## 将字符串分割成最少回文串

![image-20220328225354145](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220328225354145.png)

从左往右或者从右往左尝试的模型

`dp[i]`表示 i到最后这段范围内需要几刀。

```java
class Main {
	public static int minCut(String str) {
		if (str == null || str.equals("")) {
			return 0;
		}
		char[] chas = str.toCharArray();
		int len = chas.length;
		int[] dp = new int[len + 1];
		dp[len] = -1;
		boolean[][] p = new boolean[len][len];
		for (int i = len - 1; i >= 0; i--) {
			dp[i] = Integer.MAX_VALUE;
			for (int j = i; j < len; j++) {
				if (chas[i] == chas[j] && (j - i < 2 || p[i + 1][j - 1])) {
					p[i][j] = true;
					dp[i] = Math.min(dp[i], dp[j + 1] + 1);
				}
			}
		}
		return dp[0];
	}
}

```



![image-20220206180256673](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206180256673.png)

递归的解法：

![image-20220206180710661](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206180710661.png)

![image-20220206181802612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206181802612.png)



创建一个dp的表，表示i-j范围上是不是回文。
![image-20220206182119985](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206182119985.png)

![image-20220206184144382](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206184144382.png)

![image-20220206184228611](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220206184228611.png)







## 字符串转换代价问题

![image-20220119230624915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119230624915.png)

- 该题主要是从什么地方下手，我们采用从字符串最后的地方下手，对于每一次决策进行三种选择，取最小值。

一个字符串作为行，一个字符串作为列

![image-20220119231341055](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119231341055.png)

`dp[i][j]`表示str1的前i个转换为str2的前j个字符串的代价是多少，str2为0的时候相当于str1一直删除。str1位0的时候相当于一直插入到str2.

对于`dp[i][j]`的值，有三种操作：

1. 执行一次更改：

​		`1.1 str1[i] == str[j],dp[i][j] = dp[i-1][j-1]`

​		`1.2 str1[i] != str[j],dp[i][j] = dp[i-1][j-1]+1` 更改一次的操作

2. 执行一次删除
   `dp[i][j] = dp[i][j]+1`
3. 执行一次添加
   `dp[i][j] = dp[i][j-1]+1`



**暴力递归**

暴力基本跟动态规划的几种情况差不多

```java
public class Main {
    public static char[] str1, str2;
    public static int ic, dc, rc;

    public static int process(char[] s1, char[] s2, int i, int d, int r) {
        str1 = s1;
        str2 = s2;
        ic = i;
        dc = d;
        rc = r;
        return process(str1.length - 1, str2.length - 1);
    }

    public static int process(int str1_len, int str2_len) {
        if (str1_len == 0 && str2_len == 0) {
            return 0;
        } else if (str1_len == 0) {
            return ic * str2_len;
        } else if (str2_len == 0) {
            return dc * str1_len;
        }
        int replace;
        if (str1[str1_len - 1] == str2[str2_len - 1]) {
            replace = process(str1_len - 1, str2_len - 1);
        } else {
            replace = process(str1_len - 1, str2_len - 1) + rc;
        }
        int delete = process(str1_len - 1, str2_len) + dc;
        int add = process(str1_len, str2_len - 1) + ic;
        return Math.min(Math.min(delete, add), replace);
    }

}

```

**动态规划**

basecase 第一列，变为空串直接删除就好

```java
public class Main {
    public static int process(String str1, String str2, int ic, int dc, int rc) {
        if (str1 == null || str2 == null) {
            return 0;
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int row = chs1.length + 1;
        int col = chs2.length + 1;
        int[][] dp = new int[row][col];
        //0个字符变成i个的添加代价
        //第一列
        for (int i = 1; i < row; i++) {
            dp[i][0] = dc * i;
        }
        //j个字符变成0个的删除代价
        //第一行
        for (int j = 1; j < col; j++) {
            dp[0][j] = ic * j;
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
 
                if (chs1[i - 1] == chs2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    //替换一个代价
                    dp[i][j] = dp[i - 1][j - 1] + rc;
                }
                /*
                 dp[i][j - 1] + ic：
                            i个转化成j-1长度的代价+一个添加代价
                            
                 dp[i - 1][j] + dc：
                            i-1个转化成j长度的代价+一个删除代价
                 */
                //添加j位置一个          
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
                //删除i位置一个
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
            }
        }
        return dp[row - 1][col - 1];
    }
}

```





## 类斐波那契数列

先看下数列

![image-20220110232208696](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232208696.png)



![image-20220111091236577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091236577.png)



斐波那契数列第n项的值，根据上面的矩阵得出。

![image-20220111091726036](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091726036.png)



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



可以推广到多项组合的数列



### \01字符串组合

![image-20220110232145674](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232145674.png)





![image-20220111094239894](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094239894.png)



- 第一个为1，第二个为2，的斐波那契数列

  

  ```
  public class Test {    public static int process(int N) {        if (N<=0)return 0;        if (N==1)return 1;        if (N==2)return 2;        int a=1;        int b=2;        int res=0;        while (N-2!=0){            res=a+b;            a=b;            b=res;            N--;        }        return res;    }}
  ```



### 辗转相除

```
public class Main {	public static int process(int a, int b) {		if (b == 0)// 表示上一步的辗转相除结果为0了			return a;		return process(b, a % b);	}}
```

### exp2

![image-20220111094656196](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094656196.png)

就是在N范围中第一项为1，第二项为2的斐波那契数列个数就是可以保留的个数。

“组成三角形的三条边需满足最长的边小于另外两条边之和,最短的边大于另外两条边之差的绝对值。”

说白了就是斐波那契数在前n有几个的问题

```
public class Main {	public static int process(int N) {		if (N <= 3)			return 0;		// num记录小于N的类斐波那契数列中元素个数		int a = 1, b = 2, res = 0, num = 2;		// 递归的斐波那契数列		while (true) {			res = a + b;			if (res > N)				return N - num;			a = b;			b = res;			num++;		}	}}
```







![image-20220111215757638](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111215757638.png)

## ？咖啡机问题

![image-20220109172318637](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109172318637.png)

### 递归

```java
public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));
        for (int i : arr) {
            queue.add(new Integer[]{0, i});
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        return sweepAllCup(finishTime, a, b, 0, 0);
    }

    // timePoint指机器时间
    private static int sweepAllCup(int[] finishTime, int a, int b, int index, int timePoint) {
        if (index == finishTime.length - 1) {
            return Math.min(Math.max(finishTime[index], timePoint) + a, finishTime[index] + b);
        }
        //咖啡机刷
        int sweepTime = Math.max(timePoint, finishTime[index]) + a;
        int sweepRestFinish = sweepAllCup(finishTime, a, b, index + 1, sweepTime);
        int time1 = Math.max(sweepRestFinish, sweepTime);//刷这个杯子和剩余杯子都完成
        //自己干
        int dryTime = finishTime[index] + a;
        int dryRestFinish = sweepAllCup(finishTime, a, b, index + 1, timePoint);
        int time2 = Math.max(dryRestFinish, dryTime);//自干这个杯子和剩余杯子都完成
        return Math.min(time1, time2);
    }

}

```

### **动态规划**

```java
public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));
        for (int i : arr) {
            queue.add(new Integer[]{0, i});
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        int M = finishTime[N - 1] + b;
        int[][] dp = new int[N][M + 1];
        for (int i = 0; i <= M; i++) {
            dp[N - 1][i] = Math.min(Math.max(i, finishTime[i]) + a, finishTime[i] + b);
        }
        for (int i = N - 2; i >= 0; i--) {
            for (int j = 0; j < M; j++) {
                int sweepTime = Math.max(finishTime[i], j) + a;
                int time1 = Math.max(sweepTime, dp[i + 1][sweepTime]);
                int dryTime = finishTime[i] + b;
                int time2 = Math.max(dryTime, dp[i][dryTime]);
                dp[i][j] = Math.min(time1, time2);
            }
        }
        return dp[0][0];
    }
}

```



## mirror数

时间复杂度o(n)空间复杂度o1的遍历二叉树的方式，有点像线索二叉树

风 9:00:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA6222916FD12483540696AE21E31DE4.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/4C27099AE86BCE98E709AC5F9CF2538E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8504DEFFA83DB68111285AED30E18B0E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/EED6FE103117301421F4743445C3373B.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C75EE0D5505A484727EA6512F8E86D92.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/72D1C3B3F2016909613C37B70FC62739.jpg)

风 9:00:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0965229D51ED08FB47C5E19C2C823FAA.jpg)

## [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

![image-20220329224329434](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220329224329434.png)



![image-20211228091332515](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228091332515.png)





可以看下官方的解释

### 动态规划

```java
public class Main {
    public static int maxNum(String s) {
        char[] arr = s.toCharArray();
        int[] dp = new int[arr.length];
        int pre, res = 0;
        for (int i = 1; i < dp.length; i++) {
            if (arr[i] == ')' ) {
                pre = i - 1 - dp[i - 1];
                if (pre >= 0 && arr[pre] == '(') {
                	// 和当前)匹配的(之间是dp[pre-1],前存在有效括号为dp[pre-1]
                    dp[i] =  dp[pre - 1] + 2 + ((pre - 1) >= 0 ? dp[pre - 1] : 0);
                }
            }
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}

```

官方的解法,大同小异

![image-20220329231140221](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220329231140221.png)

```
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 栈



```
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.isEmpty()) {
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}
```









## 数字解码方法

https://leetcode-cn.com/problems/decode-ways/

![image-20211228230339191](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228230339191.png)





### **递归实现**

- 时间复杂度为指数级

  ```
  public class Main {
  	public static int process(String s, int i) {
  		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
  		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
  			return 1;
  		if (s.charAt(i) == '0')
  			return 0;// 没有0开头匹配的元素
  		int res = process(s, i + 1);// 一个字符的
  		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
  			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
  		return res;// 累加的结果返回就行了
  	}
  }
  
  ```

  ### **动态规划**

  - 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
  - 时间复杂度为O(N)

  

  ```java
  class Solution {
      public int numDecodings(String s) {
          int n = s.length();
          int[] f = new int[n + 1];
          //初试条件，空字符串为1种可能
          f[0] = 1;
          for (int i = 1; i <= n; ++i) {
          	//单独作为一个字符
              if (s.charAt(i - 1) != '0') {
                  f[i] += f[i - 1];
              }
              //与前一个字符拼成同一个，得保证前一个不为0，并且两个不大于26.可能性就是前前一位。
              if (i > 1 && s.charAt(i - 2) != '0' && ((s.charAt(i - 2) - '0') * 10 + (s.charAt(i - 1) - '0') <= 26)) {
                  f[i] += f[i - 2];
              }
          }
          return f[n];
      }
  }
  
  ```

  

## 最长无重复子串

https://blog.csdn.net/weixin_54884881/article/details/121140623

![image-20220119225152149](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119225152149.png)



**看到子串和子数组的问题，直接就选择以每个位置为结尾会怎么怎么样就好了**



```java
public class Main {
    public static int process(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] array = s.toCharArray();
        int[] map = new int[256];//下标表示字符，值表示字符上一次出现的位置下标
        Arrays.fill(map, -1);
        int left = -1, maxLen = 0;// left表示此时向左延伸的最左位置，不包括array[left],包括array[right]
        for (int right = 0; right < array.length; right++) {
            left = Math.max(left, map[array[right]]);// 上次最左位置和array[right]上次出现的位置取最右的下标
            maxLen = Math.max(maxLen, right - left);// 更新结果
            map[array[right]] = right;// 更新上次出现的位置索引
        }
        return maxLen;
    }
}

```

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> dic = new HashMap<>();
        int res = 0, tmp = 0;
        for(int j = 0; j < s.length(); j++) {
            int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i
            dic.put(s.charAt(j), j); // 更新哈希表
            tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]
            res = Math.max(res, tmp); // max(dp[j - 1], dp[j])
        }
        return res;
    }
}

作者：jyd
链接：https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/solution/mian-shi-ti-48-zui-chang-bu-han-zhong-fu-zi-fu-d-9/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







## 字符串编码

![image-20220121093607212](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093607212.png)



![image-20220121094036917](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121094036917.png)





## 异或和为0的区间个数

网易的题目

![image-20220124231247965](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124231247965.png)

异或，英文为exclusive OR，缩写成xor

如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。

只有在两个比较的位不同时其结果是1，否则结果为0

即“两个输入相同时为0，不同则为1”！

| a    | b    | a⊕b  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

两个相同数异或的结果为0

任何数与0异或，结果都是那个数

![image-20220124232237022](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124232237022.png)

![image-20220124234457717](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124234457717.png)

![image-20220124235901697](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124235901697.png)

### 一般解

- 前序累计异或，根据从左向右的动态规划思想进行最大值的判断和记录。
- 初始值：位置为0的时候，0前面的-1位置默认为dp[-1] = 0
- dp[i]表示，以i位置（包含i位置）结尾的子字符串，最多能有几个异或为0的区间个数。
  对于dp[i]来说，i位置有两种情况：
  1. dp[i] 与前面的数字没有异或成0，因此这个数字相当于废掉的，他如果不为0的话，他就不起作用，单独就不是0.他的值直接等于dp[i-1]， 
  2. dp[i]与前面的数字进行异或构成一个异或为0的子区间。参考**两个相同数异或的结果为0**，因此只需要找这个数字前面最近的异或等于改为数字的区间的起始值就好。假设为j(包含j位置)，则dp[i]这种情况的值为 1+dp[j-1]，
  3. 然后比较两种情况的最大值，就能确定dp[i]位置最好的值
- 因此需要一个map。记录从头往后遍历数字，一直进行异或，记录每个异或以后的结果，key为结果，val为最近一次达到这个值的位置。在进行上面第二步的时候直接查。如果有就直接用来计算第二部，然后更新这个值的最近的位置为i。
- 如果从0位置异或到i位置为1000，如何找到含有i位置的最近的区间异或结果为0的位置？只要找到上一个距离i位置最近的从0异或到j位置的值为1000的j就好，这样从j+1异或到i的值就是0了，因为只有0异或1000的结果才是1000。这样就找到从j+1开始到i位置异或的结果为0，符合上面那个（2）条件了
- 这个就是前缀和，只不过是异或和



```java
public class Main {	public static int process(int[] arr) {		if (arr == null || arr.length == 0) {			return 0;		}		// 存储前面所有元素的累计异或结果		int[] preSum = new int[arr.length];		preSum[0] = arr[0];		// 计算累计异或结果		for (int i = 1; i < preSum.length; i++) {			preSum[i] = preSum[i - 1] ^ arr[i];		}		// 存储每个位置前的最多的亦或者为零的个数		int[] preMaxNum = new int[arr.length];		for (int i = 1; i < arr.length; ++i) {			// 初始化当前结果值			preMaxNum[i] = preSum[i] == 0 ? 1 : 0;			// 后面的值根据前面的更新，需要判断两个累计亦或结果相同，那么这其中异或和定为0			for (int j = i - 1; j >= 0; --j) {				if (preSum[j] == preSum[i]) {//如果preSum[j] == preSum[i]，则说明arr[j+1---i]的异或值为0，因为一个数异或0才等于这个数的值。					// arr[i……j]之间的的数组成一个亦或为0的值然后加上preMaxNum[j]就该结合的结果值					// 这里实际上若preMaxNum[j] + 1大的话可以直接退出该层循环。					preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[j] + 1);				}			}			// 使用arr[i]作为亦或为零的一部分和不用arr[i]的两种情况取最大值			preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[i - 1]);		}		return preMaxNum[preMaxNum.length - 1];	}}
```

### 优化解法

- 上一种解法中提到，当满足preMaxNum[j] + 1 > preMaxNum[i] 时就可以退出循环，说明我们只是找到一个满足更新条件即可

```java
public class Test {    public static int mostEOR(int[] arr) {        if (arr==null||arr.length==0)return 0;        int ans = 0;        int xor = 0;        int[] mosts = new int[arr.length];        HashMap<Integer, Integer> map = new HashMap<>();        map.put(0, -1);//初始值，默认-1位置的值为0，这样跟0位置异或的结果就是0位置的值        for (int i = 0; i < arr.length; i++) {            xor ^= arr[i];            //若存在，说明已经出现，那么之间的数字的异或和为0            //这种方式下就是上次出现该值前的个数+1就是当前个数            if (map.containsKey(xor)) {                int pre = map.get(xor);                mosts[i] = pre == -1 ? 1 : (mosts[pre] + 1);            }            if (i > 0) {                //判断    在次数分割和抛弃改次以上一次的方案哪个为最优解                //为了防止pre...i中出现多个异或和为0的情况                mosts[i] = Math.max(mosts[i - 1], mosts[i]);            }            //更新或添加此时xor的索引            map.put(xor, i);            //ans实际上最后也是mosts的最后一个值，也可以在最后直接返回mosts[mosts.length-1]            ans = Math.max(ans, mosts[i]);        }        return ans;    }}
```



![image-20220125001628190](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125001628190.png)



## [518. 零钱兑换 II](https://leetcode-cn.com/problems/coin-change-2/)

### 动态规划最优解（官方）

![image-20220327010203696](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327010203696.png)

![image-20220327010220152](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327010220152.png)

```
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount + 1];
        dp[0] = 1;
        for (int coin : coins) {
            for (int i = coin; i <= amount; i++) {
                dp[i] += dp[i - coin];
            }
        }
        return dp[amount];
    }
}


```



### **暴力递归**

```java
public class Main {
    public static int[] coins;

    public static int process(int[] arr, int res) {
        coins = arr;
        return process(0, res);
    }

    private static int process(int index, int curRes) {
        if (curRes == 0) return 1;
        if (index == coins.length) return 0;
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        return res;
    }
}

```

### **记忆化搜索**

```java
public class Main {
    public static int[] coins;
    public  static int[][] dp;
    public static int process(int[] arr, int res) {
        coins = arr;
        dp=new int[arr.length+1][res+1];
        for (int[] i:dp){
            Arrays.fill(i,-1);
        }
        return process(0, res);
    }

    public static int process(int index, int curRes) {
        if (dp[index][curRes]!=-1)return dp[index][curRes];
        if (curRes == 0) {
            dp[index][curRes]=1;
            return 1;
        }
        if (index == coins.length) {
            dp[index][curRes]=0;
            return 0;
        }
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        dp[index][curRes]=res;
        return res;
    }
}

```

**严格表结构**

```java
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        //有个隐藏的条件，就是当coinindex为超出了硬币数量的范围，也就是coin.length的位置，而res>0的时候，那一列就都是0种可能
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                int ways = 0;
                // coins[coinIndex]硬币使用了thisCoinNum个
                for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curRes; thisCoinNum++) {
                    ways += dp[coinIndex + 1][curRes - thisCoinNum * coins[coinIndex]];
                }
                dp[coinIndex][curRes] = ways;
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```

![image-20220324225634341](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324225634341.png)

```java
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                // 该位置结果就是：
                //          dp[coinIndex+1][curRes] ( coins[coinIndex]硬币使用了0个 )
                //                      +
                //          dp[coinIndex][curRes-coins[coinIndex]] (coins[coinIndex]硬币使用了1个 )
                dp[coinIndex][curRes] = dp[coinIndex + 1][curRes];
                if (curRes - coins[coinIndex] >= 0) {
                    dp[coinIndex][curRes] += dp[coinIndex][curRes - coins[coinIndex]];
                }
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```









### 最优解（官方）

![image-20220327004629547](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327004629547.png)

![image-20220327004737618](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327004737618.png)



```
public class Solution {
    public int coinChange(int[] coins, int amount) {
        int max = amount + 1;
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, max);
        dp[0] = 0;
        for (int i = 1; i <= amount; i++) {
            for (int j = 0; j < coins.length; j++) {
                if (coins[j] <= i) {
                    dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
                }
            }
        }
        return dp[amount] > amount ? -1 : dp[amount];
    }
}

```



## 可能性整理

1.从左往右推，也就是dp【i】表示0-i,这个i可以强制必须以i结尾，也可以是0-i范围内最优解，不一定以i结尾

2，范围尝试模型 也就是dp【i】【j】表示i到j范围上的最优解，以开头和结尾的字符有没有作为分类

3.如果还是两个序列相关联，比如a字符串修改成b字符串，dp【i】【j】可以表示成从0到i转为从0到j，这样就关联起来了

## [相同最长子序列](https://leetcode-cn.com/problems/qJnOS7/)



![image-20220406230726603](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220406230726603.png)	

可能性分类：四种情况，以i/j结尾的情况

![image-20220205191437590](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205191437590.png)

dp数组的状态就是到str的0到i的子字符串和str2的子字符串0到j，最长能构成的相同子序列的长度，

base case，第一行和第一列，因为都只有一个子字符串，因此可以根据两个字符串的第一个位置是否相等，也就是`dp[0][0]` 的值，如果相等，后续都为1，如果不等，就是0，然后往后推。或者扩大一行和一列，也就是第0行和第0列，表示两个字符串的其中一个为0的时候，都为0，按照这个`dp`的逻辑，直接往下走。

```java
public class Main {
    public static String lcse(String str1, String str2) {
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int[][] dp = getdp(chs1, chs2);

        // 根据dp表格还原计算出公共的字符序列
        int m = chs1.length - 1;
        int n = chs2.length - 1;
        char[] res = new char[dp[m][n]];
        int index = res.length - 1;
        while (index >= 0) {
            // dp[m][n]是根据那个值进行推出，是dp[m][n-1],dp[m-1][n]还是dp[m-1][n-1]
            if (n > 0 && dp[m][n] == dp[m][n - 1]) {
                n--;
            } else if (m > 0 && dp[m][n] == dp[m - 1][n]) {
                m--;
            } else {
                res[index--] = chs1[m];
                m--;
                n--;
            }
        }
        return String.valueOf(res);
    }

    private static int[][] getdp(char[] str1, char[] str2) {
        int[][] dp = new int[str1.length][str2.length];
        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
        //初始化条件
        for (int i = 1; i < str1.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
        }
        for (int j = 1; j < str2.length; j++) {
            dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
        }
        //根据str1[0...i]和str2[0...j]比较是三种情况
        //				i不当前str1子序列末尾结果，j为str2当前子序列最后元素
        //				i在当前str1子序列末尾结果，j不为str2当前子序列最后元素
        //				i是当前str1子序列末尾结果，j是str2当前子序列最后元素，存在条件为：str1[i] == str2[j] 成立
        for (int i = 1; i < str1.length; i++) {
            for (int j = 1; j < str2.length; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                if (str1[i] == str2[j]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp;
    }
}

```

空间压缩-官方解答

```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        if (text1 == null || text2 == null || text1.equals("") || text2.equals("")) {
			return 0;
		}
        int len1=text1.length();
        int len2=text2.length();
        int[][] dp=new int[2][len2+1];
        for(int i =1 ; i<=len1;i++){
            for(int j = 1;j<=len2;j++){
                int r=i%2;
                if(text1.charAt(i-1)==text2.charAt(j-1)){
                    dp[r][j]=dp[1-r][j-1]+1;
                }else{
                    dp[r][j]=Math.max(dp[1-r][j],dp[r][j-1]);
                }
            }
        }
        return dp[len1%2][len2];
    }
}
```





# 数组和字符串

## [300. 最长递增子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

子序列 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，[3,6,2,7] 是数组 [0,3,1,6,2,2,7] 的子序列。



- ![image-20220330231317076](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220330231317076.png)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = 1, n = nums.length;
        if (n == 0) {
            return 0;
        }
        //长度为i的递增子序列，最后一位的最小值--贪心
        int[] d = new int[n + 1];
        d[len] = nums[0];
        for (int i = 1; i < n; ++i) {
            if (nums[i] > d[len]) {
                d[++len] = nums[i];
            } else {
                int l = 1, r = len, pos = 0;
                // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0
                while (l <= r) {
                    int mid = (l + r) >> 1;
                    if (d[mid] < nums[i]) {
                        pos = mid;
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
                d[pos + 1] = nums[i];
            }
        }
        return len;
    }
}

```



## [647. 回文子串个数](https://leetcode-cn.com/problems/palindromic-substrings/)

### 中心拓展

![image-20220328213945522](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220328213945522.png)

```
class Solution {
    public int countSubstrings(String s) {
        int n = s.length(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int l = i / 2, r = i / 2 + i % 2;
            while (l >= 0 && r < n && s.charAt(l) == s.charAt(r)) {
                --l;
                ++r;
                ++ans;
            }
        }
        return ans;
    }
}

```

或者简单一点

```
class Solution {
    public int countSubstrings(String s) {
        int ans = 0;
        int n = s.length();
        for(int i = 0 ; i< n ; i++){
            for(int j = 0;j<=1;j++){
                int l = i;
                int r = i+j;
                
                while(r<n&&l>=0&&s.charAt(l--)==s.charAt(r++)){
                    ans++;
                }
            }
        }
        return ans;
    }
}
```







### ？-Manacher 算法

回头看

## [剑指 Offer II 103. 最少的硬币数目](https://leetcode-cn.com/problems/gaM7Ch/)

动态规划的版本

给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

你可以认为每种硬币的数量是无限的。

```
class Solution {
    public int coinChange(int[] coins, int amount) {
        if (amount <= 0) return 0;
        int dp[] = new int[amount+1];
 
        Arrays.fill(dp,amount+1);
        //这里要注意，base case
        dp [0] = 0;
        for(int i = 1; i <amount+1;i++){
            for(int j = 0;j<coins.length;j++){
                if(i-coins[j] >= 0){
                    dp[i] = Math.min(dp[i-coins[j]]+1 , dp[i]);
                }
            }
        }
        return dp[amount] > amount?-1:dp[amount];


    }
}
```



## 数组中没有出现的数

![image-20220118234729600](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118234729600.png)







力扣原题

![image-20220118235433067](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235433067.png)





## [排序数组中只出现一次的数字](https://leetcode.cn/problems/skFtm2/)

剑指 Offer II 070. 

给定一个只包含整数的有序数组 `nums` ，每个元素都会出现两次，唯有一个数只会出现一次，请找出这个唯一的数字。

![image-20220523094706449](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220523094706449.png)

关键就是要01 23 45 这种相邻位置进行比较

**异或**

异或（xor）是一个数学运算符。它应用于[逻辑运算](https://baike.baidu.com/item/逻辑运算/7224729)。异或的数学符号为“⊕”，计算机符号为“xor”。其运算法则为：

a⊕b = (¬a ∧ b) ∨ (a ∧¬b)

如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。



```
class Solution {
    public int singleNonDuplicate(int[] nums) {
        int low = 0, high = nums.length - 1;
        while (low < high) {
            int mid = (high - low) / 2 + low;
             //注意这里 low 和 high 与mid的关系
            if (nums[mid] == nums[mid ^ 1]) {
                low = mid + 1;
            } else {
                high = mid;
            }
        }
        return nums[low];
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/skFtm2/solution/pai-xu-shu-zu-zhong-zhi-chu-xian-yi-ci-d-jk8w/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











## [1979. 找出数组的最大公约数](https://leetcode-cn.com/problems/find-greatest-common-divisor-of-array/)

求数组中最大值和最小值的最大公约数

![image-20220327001446748](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220327001446748.png)



```
    public static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }
```



解法

```
class Solution {
    /**
     * Java 
     * 执行耗时:0 ms,击败了100.00% 的Java用户
     * 内存消耗:38.1 MB,击败了68.42% 的Java用户
     */
    public int findGCD(int[] nums) {
        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;
        for (int num : nums) {
            if (num > max) {
                max = num;
            }
            if (num < min) {
                min = num;
            }
        }
        return gcd(min, max);
    }

    public int gcd(int x, int y) {
        return y == 0 ? x : gcd(y, x % y);
    }
}
```













# 数学计算



## [只有两个键的键盘](https://leetcode.cn/problems/2-keys-keyboard/)

![image-20220524095434371](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524095434371.png)



![image-20220524095237964](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524095237964.png)

 ```
 class Solution {
     public int minSteps(int n) {
         int[] f = new int[n + 1];
         for (int i = 2; i <= n; ++i) {
             f[i] = Integer.MAX_VALUE;
             for (int j = 1; j * j <= i; ++j) {
                 if (i % j == 0) {
                  // 下面两个顺序不能换
                     f[i] = Math.min(f[i], f[j] + i / j);
                     f[i] = Math.min(f[i], f[i / j] + j);
                 }
             }
         }
         return f[n];
     }
 }
 
 作者：LeetCode-Solution
 链接：https://leetcode.cn/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/
 来源：力扣（LeetCode）
 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 ```



```
class Solution {
    public int minSteps(int n) {
        int[] dp = new int[n+1];
        //从2开始，因为0和1都不需要进行操作。
        for(int i = 2 ; i <= n ; i++){
            dp[i] = Integer.MAX_VALUE;
            //从1开始，因为从1开始筹够i的值，如果从2开始的话，dp在2位置就成0了，2位置由1位置推导出来的
            for(int j = 1 ; (long)j*j<=i;j++){
                if(i%j==0){
                    dp[i] = Math.min(dp[i], dp[j]+ i/j);
                    dp[i] =Math.min(dp[i],dp[i/j]+j );
                }
            }
        }
        return dp[n];

    }
}
```

### 拆分为质数的乘积

![image-20220524212335407](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524212335407.png)

![image-20220524212352790](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524212352790.png)

首先我们写前几个函数值并观察规律：
1 2 3 4 5 6 7 8
| | | | | | | |
0 2 3 4 5 5 7 6

结论 1 ：f(2 * n) = f(n) + 2.
这是因为我们需要先通过 f(n) 次操作得到 n，再复制粘贴(2步)得到 2 * n.

结论 2 ：对于质数 p，f(p) = p.
这是因为要达到 p，只有复制 1，再粘贴 p - 1 次.

从以上两个结论得到启发，我们考虑一个合数 n = p1 * p2 的达到方式，有三种途径可以达到 n:

```
1 -> p1 * p2
1 -> p1 -> p1 * p2
1 -> p2 -> p1 * p2
```



这些途径的步数分别为 p1 * p2, p1 + 1(复制) + (p2 - 1)(粘贴) = p1 + p2, p2 + 1(复制) + (p1 - 1)(粘贴) = p1 + p2.
所以，f(p1 * p2) = p1 + p2.

从而，我们很容易推导出，若 n = p1 * p2 * ... * pi，其中 pi 为质数，则
f(n) = p1 + p2 + ... + pi.



进一步地，若 n = p1^r1 * p2^r2 * ... * pi^ri，这里的 ^ 表示几次幂其中 ，pi 为质数，ri >= 1，则
f(n) = p1 * r1 + p2 * r2 + ... + pi * ri.
也就是对 n 做质因数分解，并将所有质因数乘以它的幂次并相加即可.



代码

作者：zdx2007
链接：https://leetcode.cn/problems/2-keys-keyboard/solution/shu-xue-si-lu-de-zui-you-jie-fen-jie-zhi-ijfb/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```
class Solution {
    public int minSteps(int n) {
        int ans = 0;
        for (int i = 2; i * i <= n; ++i) {
        //2,3都是质数，如果后面有非质数，一定是前面质数的乘积，而这个循环迭代，已经排除了有非质数的乘数的可能。
            while (n % i == 0) {
                n /= i;
                ans += i;
            }
        }
        if (n > 1) {
            ans += n;
        }
        return ans;
    }
}

```





## [204. 计数质数](https://leetcode.cn/problems/count-primes/)

#### o(n)的方法

```
	public static boolean check(int number) {
		int flag=0;//设置一个标志
		
		if(number==1||number==0) {//此方法用于排除1和0的影响
			return false;//返回false
		}
		for(int i=2;i<number;i++) {//用一个for循环
			if(number%i==0) {
				flag=1;
				break;
			}
		}
		if(flag==1) {//标志处理
			return false;
		}else {
			return true;
		}
	}

```



#### o(根号n)

n=xy，x、y为整数，n=√n√n，此时就当x，y都等于√n，x取小于√n的某整数时，若能被n整除，得到y大于√n的某整数，也能被n整除，保持乘积还是n。x、y两个约数在√n两边。判断是否素数，需要n除[2,n-1]的所有数，使用√n分为[2,√n]和[√n,n-1]，n在[2,√n]有约数，在[√n,n-1]也有约数，n在[2,√n]没有约数，在[√n,n-1]也没有约数。
其实只需要[2,√n]就能起到判断质数作用。



![image-20220524085757831](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524085757831.png)



```
class Solution {
    public int countPrimes(int n) {
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            ans += isPrime(i) ? 1 : 0;
        }
        return ans;
    }

    public boolean isPrime(int x) {
        for (int i = 2; i * i <= x; ++i) {
            if (x % i == 0) {
                return false;
            }
        }
        return true;
    }
}
```

超时

#### 埃氏筛



![image-20220524091805562](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220524091805562.png)

```
class Solution {
    public int countPrimes(int n) {
        int[] isPrime = new int[n];
        Arrays.fill(isPrime, 1);
        int ans = 0;
        for (int i = 2; i < n; ++i) {
            if (isPrime[i] == 1) {
                ans += 1;
                if ((long) i * i < n) {
                    for (int j = i * i; j < n; j += i) {
                        isPrime[j] = 0;
                    }
                }
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/count-primes/solution/ji-shu-zhi-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```







# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位



![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整

### 布隆过滤器的误判率该如何计算？







## 一致性哈希

我们对水平拆分数据库有了一个大致的印象，其实就是把很多的数据按照一定的规则存放在不同的服务器上，然后查找的时候能够根据存放的时候的规则去找到前面存放的数据。那么我们要说的一致性[哈希](https://so.csdn.net/so/search?q=哈希&spm=1001.2101.3001.7020)算法，其实就是解决了这里面的 `存取规则` 的问题，有了这个一致性哈希算法，我们能够准确的知道我们要取的数据落在哪个机器的哪个数据库中。

#### 1. 简单哈希

还是上面水平拆分数据库的例子，假设我们现在不知道什么一致性哈希什么集群分槽，就让我们自己想的话，我们可以很容器的想到 java 中的 HashMap 的原理，它通过计算了一个 key 的哈希值，然后拿这个哈希值对底层数组取模就得到了一个哈希桶，如果数据存在的话，就一定在这个哈希桶里，否则就不存在。类似的可以想到，假设我们的 `customer_info` 我们可以按照用户 id 去分库分表，假设此时存在水平的三个库表，如下，我们分别称之为 节点 D1, 节点 D2, 节点 D0

| 机器 ip   | 数据库   | 数据表        |
| --------- | -------- | ------------- |
| 127.0.0.1 | customer | customer_info |
| 127.0.0.2 | customer | customer_info |
| 127.0.0.3 | customer | customer_info |

分库分表的时候，用户 A 的记录落在了 D1 机器，用户 B 的记录落在了 D2 机器，用户 C 的机器落在了 D0 机器上，用户 A 要存在哪条数据库上的计算过程是用户 A 的会员 id 的哈希值对 3 取模，因为现在只有 3 台机器，伪代码: `A_id.hash() % / 3`，用户 B 和用户 C 依次类推。如下图所示

这好像很方便的解决了存取规则的问题，我们来分析一波:
假设我们的系统用户量又激增了，我们就需要再加一些机器，此时我们再计算哈希值的时候，取模不再是对 3 取模了，而是对 4 进行取模了，之前 `A_id.hash() % / 3 = 1`, 而现在 `A_id.hash() % / 4 = ?` 这个值很大概率不会是 1，所以这就会出现用户明明存在记录但是却查不到的情况，这就问题很大了，如果要解决这个问题只能在机器节点数量变化的时候对数据重新哈希，这代价就有点大了。所以，我们需要想办法让这种情况不发生，这种情况发生的根本是哈希算法本身的特性导致的，直接使用取模的话这是无法避免的。所以就有了一致性哈希



#### 2. 一致性哈希

上面通过数据库的例子介绍了哈希算法，然后也分析了它的劣势，当机器数量发生变动的时候，几乎所有的数据都会移动 (不移动的应该是运气比较好吧前后取模都是同一个值)，这个代价很大。此时的问题从水平如何拆分变成了，当增加或者删除节点时，对于大多数记录，保证原来分配到的某个节点，现在仍然应该分配到那个节点，将数据迁移量的降到最低，这就是一致性哈希要做的事情。在这里我们不指定是数据库还是什么，反正都是分布式存储节点。

##### 2.1 一致性哈希

一致性 [Hash](https://so.csdn.net/so/search?q=Hash&spm=1001.2101.3001.7020) 算法也是使用取模的思想，只是，刚才描述的取模法是对节点数量进行取模，而一致性 Hash 算法是对 `2^32` 取模，什么意思呢？简单来说，一致性 Hash 算法将整个哈希值空间组织成一个虚拟的圆环，如假设某哈希函数 H 的值空间为 0-2^32-1（即哈希值是一个 32 位无符号整形），整个哈希环如下，从 0 ~ 2^32-1 代表的分别是一个个的节点，这个环也叫哈希环

![image-20220525095414618](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095414618.png)





然后我们将我们的节点进行一次哈希，按照一定的规则，比如按照 ip 地址的哈希值，让节点落在哈希环上。比如此时我们可能得到了如下图的环:

![image-20220525095619170](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095619170.png)



然后就是需要通过数据 key 找到对应的服务器然后存储了，我们约定，通过数据 key 的哈希值落在哈希环上的节点，如果命中了机器节点就落在这个机器上，否则落在顺时针直到碰到第一个机器。如下图所示 : A 的哈希值落在了 D2 节点的前面，往下找落在了 D2 机器上，D 的哈希值 在 D1 节点的前面，往下找到了 D1 机器，B 的哈希值刚好落在了 D1 节点上，依次～～～

![image-20220525095654267](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095654267.png)



##### 2.2 一致性哈希的分析

一致性哈希主要就是解决当机器减少或增加的时候，大面积的数据重新哈希的问题，主要从下面 2 个方向去考虑的，当节点宕机时，数据记录会被定位到下一个节点上，当新增节点的时候 ，相关区间内的数据记录就需要重新哈希。

###### 2.2.1 某节点宕机

我们假设上图中的 节点 D2 因为一些原因宕机了，可以看到，只有数据 A 的记录需要重新重新定位存储到节点 D1 上，因为 D1 是 D2 的下一个节点，其它的数据都没有被影响到，此时被影响的仅仅是 图中的 D0-D2 这段区间的记录，也就是之前落在 D2 上的数据现在都要落到 D1 上面了。如下图

![image-20220525095734649](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095734649.png)



###### 2.2.2 新增节点

我们假设我们需要增加一台机器，也就是增加一个节点 D4，如下图所示，这个节点落在 D2-D1 之间，按照上述的哈希环上的哈希值落在节点的规则，那么此时之前落在 D2 到 D4 之间的数据都需要重新定位到新的节点上面了，而其它位置的数据是不需要有改变的。



![image-20220525095753948](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095753948.png)



##### 2.3 一致性哈希的数据倾斜问题

一致性 Hash 算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。比如只有 2 台机器，这 2 台机器离的很近，那么顺时针第一个机器节点上将存在大量的数据，第二个机器节点上数据会很少。如下图所示，D0 机器承载了绝大多数的数据

##### 2.3 一致性哈希的数据倾斜问题

一致性 Hash 算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题。比如只有 2 台机器，这 2 台机器离的很近，那么顺时针第一个机器节点上将存在大量的数据，第二个机器节点上数据会很少。如下图所示，D0 机器承载了绝大多数的数据

##### 2.4 虚拟节点解决数据倾斜问题

为了避免出现数据倾斜问题，一致性 Hash 算法引入了虚拟节点的机制，也就是每个机器节点会进行多次哈希，最终每个机器节点在哈希环上会有多个虚拟节点存在，使用这种方式来大大削弱甚至避免数据倾斜问题。同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到 “D1#1”、“D1#2”、“D1#3” 三个虚拟节点的数据均定位到 D1 上。这样就解决了服务节点少时数据倾斜的问题。在实际应用中，通常将虚拟节点数设置为 32 甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。这也是 Dubbo 负载均衡中有一种一致性哈希负载均衡的实现思想。



![image-20220525095924256](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525095924256.png)

##### .5 一致性哈希的应用案例

一致性哈希用到的地方很多，特别是中间件里面，比如 Dubbo 的负载均衡也有一种策略是一致性哈希策略，使用的就是虚拟节点实现的。Redis 集群中也用到了相关思想但是没有用它而是根据实际情况改进了一下。而对于存储数据的节点水平切分的时候它的作用就更不可代替了。and so on・・・

#### 3. Redis 集群分槽的实现

Redis 集群并没有直接使用一致性哈希，而是使用了哈希槽 `（slot）` 的概念，Redis 没有直接使用哈希算法 hash ()，而是使用了 `crc16` 校验算法。槽位其实就是一个个的空间的单位。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布，可能会产生数据倾斜问题。而 Redis 的槽位空间是自定义分配的，类似于 Windows 盘分区的概念。这种分区是可以自定义大小，自定义位置的。Redis 集群包含了 `16384` 个哈希槽，每个 Key 经过计算后会落在一个具体的槽位上，而槽位具体在哪个机器上是用户自己根据自己机器的情况配置的，机器硬盘小的可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。
另外在容错性和扩展性上与一致性哈希一样，都是对受影响的数据进行转移而不影响其它的数据。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。

> 需要注意的是，对于槽位的转移和分派，Redis 集群是不会自动进行的，而是需要人工配置的。所以 Redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。

https://blog.csdn.net/qq_33945246/article/details/105113417



## crc16

CRC即循环冗余校验码（Cyclic Redundancy Check），是数据通信领域中最常用的一种查错校验码。奇偶校验虽然简单，但是漏检率太高，而CRC则要低的多，所以大多数都是使用CRC来校验。CRC也称为多项式码。

任何一个由二进制数位串组成的代码，都可以唯一的与一个只含有0和1两个系数的多项式建立一一对应的关系。如：1010111对应的多项式为X^6 + X^4 + X^2 + X + 1。

CRC码是利用事先约定好的多项式G(x)来得到的。k位要发送的信息位可对应于一个（k - 1）次多项式K(x)，r位冗余位则对应于一个（r - 1）次多项式R(x)。k位信息位和r位冗余位组成的码字多项式为T(x) = x^r * K(x) + R(x)。因为补上了r位冗余为，所以K(x)要乘以x^r。

由信息位产生冗余位的编码过程，即已知K(x)求R(x)的过程。通过约定好的r次多项式G(x)，最高项X^r的系数恒定为1，即r bit为1。然后用X^r * K(x) 去除以G(x)，得到的余式就是R(x)。除法是模2除法，即使用异或运算。当被除数逐位除完时，最后得到的比除数少一位的余数，此余数即为冗余位。将其添加在信息位后面。

这里以K(x) = x^6 + x^4 + x^3 + 1为例（信息位即为1011001），设G(x) = x^4 + x^3 + 1（11001），则r = 4，x^4 * K(x) （即低位补r个0：10110010000）。

![image-20220525231818845](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220525231818845.png)

https://baijiahao.baidu.com/s?id=1725614586582847515&wfr=spider&for=pc



## [缓存算法（页面置换算法）-FIFO、LFU、LRU ](https://www.cnblogs.com/dolphin0520/p/3749259.html)

**FIFO**（First in First out），先进先出。利用一个双向链表保存数据，当来了新的数据之后便添加到链表末尾，如果Cache存满数据，则把链表头部数据删除，然后把新的数据添加到链表末尾。在访问数据的时候，如果在Cache中存在该数据的话，则返回对应的value值；否则返回-1。如果想提高访问效率，可以利用hashmap来保存每个key在链表中对应的位置。

**LFU**（Least Frequently Used）最不经常使用(最少次)淘汰算法。它是基于“如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小”的思路。注意LFU和LRU算法的不同之处，LRU的淘汰规则是基于访问时间，而LFU是基于访问次数的。为了能够淘汰最少使用的数据，因此LFU算法最简单的一种设计思路就是 利用一个数组存储 数据项，用hashmap存储每个数据项在数组中对应的位置，然后为每个数据项设计一个访问频次，当数据项被命中时，访问频次自增，在淘汰的时候淘汰访问频次最少的数据。这样一来的话，在插入数据和访问数据的时候都能达到O(1)的时间复杂度，在淘汰数据的时候，通过选择算法得到应该淘汰的数据项在数组中的索引，并将该索引位置的内容替换为新来的数据内容即可，这样的话，淘汰数据的操作时间复杂度为O(n)。另外还有一种实现思路就是利用 小顶堆+hashmap，小顶堆插入、删除操作都能达到O(logn)时间复杂度，因此效率相比第一种实现方法更加高效。

**LRU** 是（ Least Recently Used） 最近最少使用的缩写，这种算法认为最近使用的数据是热门数据，下一次很大概率将会再次被使用。而最近很少被使用的数据，很大概率下一次不再用到。当缓存容量的满时候，优先淘汰最近很少使用的数据。其在Redis、Guava等工具中也有非常广泛的应用，甚至是最核心的思想之一。

所以，LRU 算法具体步骤：

- 新数据直接插入到列表头部
- 缓存数据被命中，将数据移动到列表头部
- 缓存已满的时候，移除列表尾部数据。

`LRU`使用双向链表加散列表（哈希表）结合体，数据结构如图所示:

![image-20220526084931137](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220526084931137.png)

在双向链表中特意增加两个『哨兵』节点，不用来存储任何数据。使用哨兵节点，增加/删除节点的时候就可以不用考虑边界节点不存在情况，简化编程难度，降低代码复杂度。

```
public class LRUCache {
    Entry head, tail;
    int capacity;
    int size;
    Map<Integer, Entry> cache;
    
    public LRUCache(int capacity) {
        this.capacity = capacity;
        // 初始化链表
        initLinkedList();
        size = 0;
        cache = new HashMap<>(capacity + 2);
    }

    /**
     * 如果节点不存在，返回 -1.如果存在，将节点移动到头结点，并返回节点的数据。
     */
    public int get(int key) {
        Entry node = cache.get(key);
        if (node == null) {
            return -1;
        }
        // 存在移动节点
        moveToHead(node);
        return node.value;
    }

    /**
     * 将节点加入到头结点，如果容量已满，将会删除尾结点
     */
    public void put(int key, int value) {
        Entry node = cache.get(key);
        if (node != null) {
            node.value = value;
            moveToHead(node);
            return;
        }
        // 不存在。先加进去，再移除尾结点
        // 此时容量已满 删除尾结点
        if (size == capacity) {
            Entry lastNode = tail.pre;
            deleteNode(lastNode);
            cache.remove(lastNode.key);
            size--;
        }
        // 加入头结点
        Entry newNode = new Entry();
        newNode.key = key;
        newNode.value = value;
        addNode(newNode);
        cache.put(key, newNode);
        size++;
    }

    private void moveToHead(Entry node) {
        // 首先删除原来节点的关系
        deleteNode(node);
        addNode(node);
    }

    private void addNode(Entry node) {
        head.next.pre = node;
        node.next = head.next;

        node.pre = head;
        head.next = node;
    }

    private void deleteNode(Entry node) {
        node.pre.next = node.next;
        node.next.pre = node.pre;
    }

    public static class Entry {
        public Entry pre;
        public Entry next;
        public int key;
        public int value;

        public Entry(int key, int value) {
            this.key = key;
            this.value = value;
        }

        public Entry() {
        }
    }

    private void initLinkedList() {
        head = new Entry();
        tail = new Entry();

        head.next = tail;
        tail.pre = head;
    }

    public static void main(String[] args) {
        LRUCache cache = new LRUCache(2);
        cache.put(1, 1);
        cache.put(2, 2);
        System.out.println(cache.get(1));
        cache.put(3, 3);
        System.out.println(cache.get(2));
    }
}

```

### LRU 算法改进

上面的LRU算法还有一些不足：当热点数据较多时，有较高的命中率，但是如果有偶发性的批量操作，会使得热点数据被非热点数据挤出容器。

那就出现了LRU-K，它是对上面LRU算法的改进，可以说上面的基础LRU是LRU-1，LRU-K是将原先进入缓存队列的评判标准从访问一次改为访问K次。

LRU-K算法有两个队列，一个是缓存队列，一个是数据访问历史队列。当访问一个数据时，首先先在访问历史队列中累加访问次数，当历史访问记录超过K次后，才将数据缓存至缓存队列，从而避免缓存队列被污染。同时访问历史队列中的数据可以按照LRU的规则进行淘汰。

一般来讲，当K的值越大，则缓存的命中率越高，但是也会使得缓存难以被淘汰。综合来说，使用LRU-2的性能最优。

```
// 直接继承我们前面写好的LRUCache
public class LRUKCache extends LRUCache {
    
    private int k; // 进入缓存队列的评判标准
    private LRUCache historyList; // 访问数据历史记录

    public LRUKCache(int cacheSize, int historyCapacity, int k) {
        super(cacheSize);
        this.k = k;
        this.historyList = new LRUCache(historyCapacity);
    }

    @Override
    public Integer get(Integer key) {

        // 记录数据访问次数
        Integer historyCount = historyList.get(key);
        historyCount = historyCount == null ? 0 : historyCount;
        historyList.put(key, ++historyCount);

        return super.get(key);
    }

    @Override
    public Integer put(Integer key, Integer value) {

        if (value == null) {
            return null;
        }
        
        // 如果已经在缓存里则直接返回缓存中的数据
        if (super.get(key) != null) {
            return super.put(key, value);;
        }

        // 如果数据历史访问次数达到上限，则加入缓存
        Integer historyCount = historyList.get(key);
        historyCount = historyCount == null ? 0 : historyCount;
        if (historyCount >= k) {
            // 移除历史访问记录
            historyList.remove(key);
            return super.put(key, value);
        }
    }
}

```

## 4.2 冷热分区优化

将链表拆分成两部分，分为热数据区，与冷数据区，如图所示。

改进之后算法流程将会变成下面一样:

访问数据如果位于热数据区，与之前 LRU 算法一样，移动到热数据区的头结点。
插入数据时，若缓存已满，淘汰尾结点的数据。然后将数据插入冷数据区的头结点。
处于冷数据区的数据每次被访问需要做如下判断：若该数据已在缓存中超过指定时间，比如说 1 s，则移动到热数据区的头结点。若该数据存在在时间小于指定的时间，则位置保持不变。

![image-20220526085624595](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220526085624595.png)



对于偶发的批量查询，数据仅仅只会落入冷数据区，然后很快就会被淘汰出去。热门数据区的数据将不会受到影响，这样就解决了 LRU 算法缓存命中率下降的问题。其他改进方法还有 LRU-K，2Q,LIRS 算法，感兴趣同学可以自行查阅。

# 并查集

看一个图是不是联通的？或者看两个不直接相交的节点是不是有关系的？
https://zhuanlan.zhihu.com/p/93647900/ 并查集的介绍

## 原理



https://www.cnblogs.com/noKing/p/8018609.html

并查集被很多OIer认为是最简洁而优雅的数据结构之一，主要用于解决一些**元素分组**的问题。它管理一系列**不相交的集合**，并支持两种操作：

- **合并**（Union）：把两个不相交的集合合并为一个集合。
- **查询**（Find）：查询两个元素是否在同一个集合中。

介绍并查集->     并查集是一种数据结构, 常用于描述集合,经常用于解决此类问题:某个元素是否属于某个集合,或者 某个元素 和 另一个元素是否同属于一个集合

数组里存的数字代表所属的集合。比如`arr[4]==1;代表4是第一组。如果arr[7]==1`,代表7也是第一组。既然 arr[4] == arr[7] == 1 ，那么说明4 和 7同属于一个集合，

### 快速union，快速find，基于高度(基于秩)

上面介绍的是，当两个集合合并时，谁的重量大，谁就来当合并之后的根。是比以前好多了。但还是有并查集深度太深的问题。并查集越深，就越接近线性，find函数就越接近O(n)

所以有了这种基于高度的union。合并时，谁的深度深，谁就是新的根。这样集合的深度最多是最大深度的集合的深度，而不会让深度增加。

比如上面的例子中，元素2的深度是2，元素6的深度是3，按基于重量的union合并后，新的集合深度是4。

但是如果不比重量，而是比高度呢？

那就是6的深度是3，2的深度是2。3大于2, 所以6是新集合的根。看下面图。 可以看到按高度合并后,新的结合的深度并没有加深，深度为3，而按基于重量的合并后的高度是4。



```
package 并查集;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/5/26
 * @Version 1.0
 **/
public class FatestUnionFind {
    private int[] parent;
    private int[] height;
    int size;

    public FatestUnionFind(int size) {
        this.size = size;
        this.parent = new int[size];
        this.height = new int[size];
        for (int i = 0; i < size; i++) {
            parent[i] = i;
            height[i] = 1;
        }
    }

    public int find(int element) {
        while (element != parent[element]) {
            element = parent[element];
        }
        return element;
    }

    public boolean isConnected(int firstElement, int secondElement) {
        return find(firstElement) == find(secondElement);
    }

    public void unionElements(int firstElement, int secondElement) {
        int firstRoot = find(firstElement);
        int secondRoot = find(secondElement);

        if (height[firstRoot] < height[secondRoot]) {
            parent[firstRoot] = secondRoot;
        } else if (height[firstRoot] > height[secondRoot]) {
            parent[secondRoot] = firstRoot;
        } else {
            parent[firstRoot] = secondRoot;
            height[secondRoot] += 1;
        }
    }
 
                /*
              如果要合并的两个集合高度一样，那么随意选一个作为根
              我这里选的是让secondRoot作为新集合的根。
              然后secondRoot高度高了一层，所以+1
            */

    private void printArr(int[] arr) {
        for (int p : arr) {
            System.out.print(p + "\t");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int n = 10;
        FatestUnionFind union = new FatestUnionFind(n);

        System.out.println("初始parent：");
        union.printArr(union.parent);
        System.out.println("初始height：");
        union.printArr(union.height);

        System.out.println("连接了5 6 之后的parent：");
        union.unionElements(5, 6);
        union.printArr(union.parent);
        System.out.println("连接了5 6 之后的height：");
        union.printArr(union.height);

        System.out.println("连接了1 2 之后的parent：");
        union.unionElements(1, 2);
        union.printArr(union.parent);
        System.out.println("连接了1 2 之后的height：");
        union.printArr(union.height);

        System.out.println("连接了2 3 之后的parent：");
        union.unionElements(2, 3);
        union.printArr(union.parent);
        System.out.println("连接了2 3 之后的height：");
        union.printArr(union.height);

        System.out.println("连接了1 4 之后的parent：");
        union.unionElements(1, 4);
        union.printArr(union.parent);
        System.out.println("连接了1 4 之后的height：");
        union.printArr(union.height);

        System.out.println("连接了1 5 之后的parent：");
        union.unionElements(1, 5);
        union.printArr(union.parent);
        System.out.println("连接了1 5 之后的height：");
        union.printArr(union.height);

        System.out.println("1  6 是否连接：" + union.isConnected(1, 6));

        System.out.println("1  8 是否连接：" + union.isConnected(1, 8));
    }
}

```



### 路径压缩

路径压缩就是处理并查集中的深的结点。实现方法很简单，就是在find函数里加上一句 parent[element] = parent[parent[element]];就好了，就是让当前结点指向自己父亲的父亲，减少深度，同时还没有改变根结点的weight(非根节点的weight改变了无所谓)。

注：只能在基于重量的并查集上改find函数，而不能在基于高度的并查集上采用这种路径压缩。因为路径压缩后根的重量不变，但高度会变，然而高度改变后又不方便重新计算。













## 杭电ACM-1232-畅通工程

连接：http://acm.hdu.edu.cn/showproblem.php?pid=1232

> 某省调查城镇交通状况，得到现有城镇道路统计表，表中列出了每条道路直接连通的城镇。省政府“畅通工程”的目标是使全省任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要互相间接通过道路可达即可）。问最少还需要建设多少条道路？ 

思路：与上面题思路一样，在并查集中进行合并操作，求出最后剩下多少个组(集合)。这些组之间是互相不可达的。假如有M个组，那其实再需要M-1条连线就可以把他们连接起来了。所以组数 - 1 就是最后答案

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/20
 * @Version 1.0
 **/
class UnionFind2 {
    /**
     * 记录并查集对应位置的父亲结点位置
     */
    private int[] parent;
    /**
     * 记录并查集对应结点的重量
     */
    private int[] weight;
    /**
     * 表示并查集的元素个数
     */
    private int size;
    /**
     * 表示并查集中集合的个数(组数)
     */
    private int groups;

    public UnionFind2(int size) {
        this.size = size;
        this.groups = size;
        this.parent = new int[size];
        this.weight = new int[size];
        for (int i = 0; i < size; i++) {
            this.parent[i] = i;
            this.weight[1] = 1;
        }
    }

    public int find(int element) {
        while (element != parent[element]) {
            parent[element] = parent[parent[element]];
            element = parent[element];
        }
        return element;
    }

    public boolean isConneted(int firstElement, int secondElement) {
        return find(firstElement) == find(secondElement);
    }

    public void unionElements(int firstElement, int secondElement) {
        int firstRoot = find(firstElement);
        int secondRoot = find(secondElement);
        if (firstRoot == secondRoot) {
            return;
        }
        if (weight[firstRoot] < weight[secondRoot]) {
            parent[firstRoot] = secondRoot;
            weight[secondRoot] += weight[firstRoot];
        } else {
            parent[secondRoot] = firstRoot;
            weight[firstRoot] += secondRoot;
        }

        this.groups--;
    }

    public int getGroups() {
        return this.groups;
    }
}

public class unionFindPath {
    public static void main(String[] args) {
        java.util.Scanner scanner = new java.util.Scanner(System.in);
        int size = scanner.nextInt();
        while (size != 0) {
            int input = scanner.nextInt();
            UnionFind2 union = new UnionFind2(size);
            for (int i = 0; i < input; i++) {
                //因为测试数据中是从1开始技术。而我们的并查集是从0开始，所以每个输入都减1
                int first = scanner.nextInt() - 1;
                int second = scanner.nextInt() - 1;
                union.unionElements(first, second);
            }
            //最后剩下的组数 - 1 就是最后的答案。因为连接M组的话，需要M-1条连线就可以了
            System.out.println(union.getGroups() - 1);
            size = scanner.nextInt();
        }
    }
}
```





## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

![image-20220531095506974](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220531095506974.png)

```
class Solution {
    public int longestConsecutive(int[] nums) {
        Set<Integer> num_set = new HashSet<Integer>();
        for (int num : nums) {
            num_set.add(num);
        }

        int longestStreak = 0;

        for (int num : num_set) {
            if (!num_set.contains(num - 1)) {
                int currentNum = num;
                int currentStreak = 1;

                while (num_set.contains(currentNum + 1)) {
                    currentNum += 1;
                    currentStreak += 1;
                }

                longestStreak = Math.max(longestStreak, currentStreak);
            }
        }

        return longestStreak;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/longest-consecutive-sequence/solution/zui-chang-lian-xu-xu-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



并查集的思路实际上与思路2有点像，也是来记录右边界的，所有在一个连续区间内的元素都会在一个连通分量中，且这些元素的根结点都为最远的右边界元素。
具体思路是：

遍历所有元素num，如果num+1存在，将num加入到num+1所在的连通分量中；
重新遍历一遍所有元素num，通过find函数找到num所在分量的根结点，也就是最远右边界，从而求得连续区间的长度。

```
class UnionFind {
    // 记录每个节点的父节点
    private Map<Integer, Integer> parent;

    public UnionFind(int[] nums) {
        parent = new HashMap<>();
        // 初始化父节点为自身
        for (int num : nums) {
            parent.put(num, num);
        }
    }

    // 寻找x的父节点，实际上也就是x的最远连续右边界，这点类似于方法2
    public Integer find(int x) {
        // nums不包含x
        if (!parent.containsKey(x)) {
            return null;
        }
        // 遍历找到x的父节点
        while (x != parent.get(x)) {
            // 进行路径压缩，不写下面这行也可以，但是时间会慢些
            parent.put(x, parent.get(parent.get(x)));
            x = parent.get(x);
        }
        return x;
    }

    // 合并两个连通分量，在本题中只用来将num并入到num+1的连续区间中
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        parent.put(rootX, rootY);
    }
}

class Solution {
    public int longestConsecutive(int[] nums) {
        UnionFind uf = new UnionFind(nums);
        int ans = 0;
        
        for (int num : nums) {
            // 当num+1存在，将num合并到num+1所在集合中
            if (uf.find(num + 1) != null) {
                uf.union(num, num + 1);
            }
        }

        for (int num : nums) {
            // 找到num的最远连续右边界
            int right = uf.find(num);
            ans = Math.max(ans, right - num + 1);
        }
        return ans;
    }
}

作者：yimeixiaobai
链接：https://leetcode.cn/problems/longest-consecutive-sequence/solution/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





# kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)





## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

# 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





# 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算





## 接雨水



### 1.单调栈

```
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 双指针

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
        // 先更新指针的值，再进行计算雨水，再移动指针较小的端的指针。
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











### 最大分段最大值的差

![image-20220107000935422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000935422.png)



找到最大值，然后减去两头的值，哪个小减去哪个。因为两段以后必然包含端点的值。
![image-20220107001615368](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001615368.png)











# 有序表

![image-20211219180032411](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219180032411.png)















# 大数据问题

有限的空间找到几十亿条数据中没有出现的数

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3FDC6603989FCA68399CFD474D160126.jpg)

风 9:00:23
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9E73E41834A98DDD73670482DB8BD9DB.jpg)









# 回溯法

1.确定base case，也就是递归的终止条件或者出口

2.确定递归方法的固定参数和可变参数，以及局部输出结果，也就是下一个节点要走的结果，相当于黑盒子，

3.然后搜集子递归过程，返回给上游，最上游输出的结果就是递归的结果



优化为记忆化搜索的过程：

将子问题的结果记录在一个数组中，别的递归调用到相同的参数 的时候可以重复使用，然后就可以转为记忆化搜索的过程



## [字符串转换](https://leetcode-cn.com/problems/word-transformer-lcci/)



![image-20220121092936819](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121092936819.png)



```
import java.util.ArrayList;
import java.util.List;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/4/1
 * @Version 1.0
 **/
class findLadders {
    List<String> map;
    String ew, bw;
    List<String> result = new ArrayList<>();
    List<String> fake = new ArrayList<>();
    boolean[] flag;

    //定义几个成员变量，方便在其他函数中使用，布尔数组flag用来记录已经查看过的节点
    public List<String> findLadders(String beginWord, String endWord, List<String> wordList) {
        map = wordList;
        ew = endWord;
        bw = beginWord;
        flag = new boolean[wordList.size()];
        dfs(beginWord);
        return result;

    }

    //dfs用来递归调用，并且返回值为Boolean，当找到正确答案时，就直接可以快速退出所有的dfs
//在进入下一层时，将路径记录，如果没有找到答案就返回上一层，并且，并且把路径fake去掉最后一个String
    public boolean dfs(String temp) {
        List<String> neighbhood = near(temp);
        if (!neighbhood.isEmpty()) {
            for (String tt : neighbhood) {
                fake.add(tt);
                if (tt.equals(ew)) {
                    result.add(bw);
                    for (String str : fake) {
                        result.add(str);//这一步没有办法直接的将result=fake这么写，
                    }//因为这么写的话就会导致result记录的是fake的地址，后面改变fake会改变result的值
                    return true;
                }
                if (dfs(tt)) {
                    //已经有了结果
                    return true;
                } else
                    //没有结果，回溯
                    fake.remove(fake.size() - 1);
            }
        } else {
            return false;
        }
        return false;

    }

    //这个函数就是返回一个ArraysList，就是当前的str的所临近（一个字符不同）的所有的字符串，
//并且将返回的字符串标记下，如果标记过的字符串不再返回，至于为啥要这么做，建议拿个草稿纸
//模拟下题目所给的案例，如果没这一步就会需要一直递归，而且浪费时间和资源
    public List<String> near(String str) {
        List<String> res = new ArrayList<>();
        int len1 = str.length();
        for (int j = 0; j < map.size(); j++) {
            String tt = map.get(j);
            if (tt.length() != len1 || flag[j])
                continue;
            int differ = 0;
            for (int i = 0; i < len1; i++) {
                if (str.charAt(i) != tt.charAt(i))
                    differ++;
                if (differ == 2)
                    break;
            }
            if (differ == 1) {
                flag[j] = true;
                res.add(tt);
            }
        }
        return res;
    }
//方便在编译器中自己调试
/*	public static void main(String[] args) {
		Number9_1 a=new Number9_1();
		String beginWord="hit",endWord="cog";
		List<String> wordList=new ArrayList<String>();
		wordList.add("hot");
		wordList.add("dot");
		wordList.add("dog");
		wordList.add("lot");
		wordList.add("log");
		wordList.add("cog");
		List<String>str1=a.findLadders(beginWord, endWord, wordList);
		for(String tt:str1) {
			System.out.println(tt);
		}
	}*/
}


```





## 矩阵中的路径
题目 : 请设计请设计一个函数用来判断在矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个位置开始，每部可以在矩阵中的上下左右四个方向移动，如果一条路径已经经过了矩阵的某一个格子，那么该路径就不能够再次进入该格子。

对于每个格子均有可能是起始节点，并且每个路径和其他路径没有太多可利用关系，所以要进行所有的格子作为起始结点来判断。
由于要进行方向定位，像迷宫一样进行递归回缩。

```java 
public class Main {
	public static boolean process(char[][] matrix, char[] str) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0 || str.length == 0) {
			return false;
		}
		int rows = matrix.length;
		int line = matrix[0].length;
		// 用于记录是否走过该路径
		boolean[][] isVisited = new boolean[rows][line];
		int pathLen = 0;
		// 对于每一个元素进行起始的判断
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < line; j++) {
				if (hasSuccessPath(matrix, i, j, str, 0, isVisited)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * @param matrix    元素矩阵
	 * @param row       判断matrix中行位置元素
	 * @param line      判断matrix中列位置元素
	 * @param str       寻找的目标串
	 * @param index     目标串的第几个元素
	 * @param isVisited 记录是否走过的表格
	 * @return			该路径是否可行
	 */
	private static boolean hasSuccessPath(char[][] matrix, int row, int line, char[] str, int index,
			boolean[][] isVisited) {
		// 此时说明index前面的所有元素均已经匹配成功
		if (str.length == index) {
			return true;
		}
		// 不符合条件返回不通行
		if (row >= matrix.length || line == matrix[0].length || row < 0 || line < 0 || isVisited[row][line]
				|| matrix[row][line] != str[index]) {
			return false;
		}
		++index;
		// 标记该路已经走过
		isVisited[row][line] = true;
		// 向四个方向均进行尝试
		boolean hasPath = hasSuccessPath(matrix, row + 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line + 1, str, index, isVisited)
				|| hasSuccessPath(matrix, row - 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line - 1, str, index, isVisited);
		// 若没有成功将isVisited值进行还原避免影响后续判断，若为真那么在该步骤结束时循环，不会对后来的产生影响
		if (!hasPath) {
			isVisited[row][line] = false;
		}
		return hasPath;
	}
}

```


## 机器人的运动范围
题目： 地上有一个M行N列的方格，一个机器人从坐标( 0, 0 )的个格子开始移动，他每次可向左右上下四个方向移动一个格子，但不能进入行坐标和列坐标的各个位数之和大于K值，并且到达每个格子之前必定可以通过其他格子到达该格子。例如： k=18,机器人可以进入（35，37），3+5+3+7=18<=18能进入,（36，38），3+6+3+8=20>18,不能进入。

该题目实际上和上一题本质相同，仅仅是改变了限制条件和起始范围
该题的起始范围已经给定（0，0），只需要向上下左右进行递归回溯，另外在递归时要记录路径个数。

```
public class Main {
	public static int process(int k, int rows, int lines) {
		if (k < 0 || rows <= 0 || lines <= 0) {
			return 0;
		}
		boolean[][] isVisited = new boolean[rows][lines];
		return movingCount(k, rows, lines, 0, 0, isVisited);

	}

	/**
	 * @param k         限制条件k
	 * @param rows      矩阵总行数
	 * @param lines     矩阵总列数
	 * @param i         当前元素行数量
	 * @param j         当前元素列数量
	 * @param isVisited 是否已经访问过
	 * @return 可以选择的个数
	 */
	private static int movingCount(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		int count = 0;
		// 如果满足限制条件就进行标记，并以此为展开进行递归搜索
		if (canVisited(k, rows, lines, i, j, isVisited)) {
			isVisited[rows][lines] = true;
			count += movingCount(k, rows, lines, i + 1, j, isVisited)
					+ movingCount(k, rows, lines, i - 1, j, isVisited)
					+ movingCount(k, rows, lines, i, j + 1, isVisited)
					+ movingCount(k, rows, lines, i, j - 1, isVisited);
		}
		return count;
	}

	private static boolean canVisited(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		if (i >= 0 && i < rows && j >= 0 && j < lines && !isVisited[i][j] && getDigitSum(i) + getDigitSum(j) <= k) {
			return true;
		}
		return false;
	}

	// 计算num和各位数字之和
	private static int getDigitSum(int num) {
		int sum = 0;
		while (num > 0) {// 不能 = 0
			sum += num % 10;
			num /= 10;
		}
		return sum;
	}
}

```

## 机器人到达某个位置的路径数量

## 机器人运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**

**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
    public static int[][] dp;
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20211214220219521](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220219521.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



加个二维数组记录位置的结果，记忆化搜索的优化

![image-20211214091329206](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091329206.png)



![image-20211214091359467](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091359467.png)

改为动态规划的版本：

​	二维数组，行代表在哪个位置，列代表该位置还有几部可以走。
​	首先初始化第一行，也就是basecase，然后分析下一个位置。



![image-20211214092524034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214092524034.png)





## 飞棋盘

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```

**严格表结构**

```
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围 三维分别是 x坐标、y坐标、走了几步
        dp[1][1][0] = 1;// 递归结束条件 起始位置，走0步到1,1的方式有一种
        // 递归的意识是，走了k步到达i,j位置的方式有几种
        for (int k = 1; k <= K; k++) {// 步数 
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```



## 整数分裂

![image-20211214220703594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220703594.png)

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes) return 0;
        int ways = 0;
        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }

}

```

**记忆化搜索**

```
public class Main {
    public static int[][] dp;
    public static int process(int res) {
        if (res < 1) return 0;
        dp=new int[res+1][res+1];
        for (int[]i:dp){
            Arrays.fill(i,-1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (dp[pre][curRes]!=-1)return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes]=1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes]=0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes]=ways;
        return ways;
    }

}

```

**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                for (int i = pre; i <= curRes; i++) {// 所有情况累加
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

**斜率优化**

- 枚举行为推导

![image-20211214220817010](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220817010.png)



```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        dp[res][res]=1;// 根据下一层退出结果，所以要先对最后一层就行添值
        for (int pre = res-1; pre >= 1; pre--) {// 前驱
            for (int curRes = pre ; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                dp[pre][curRes]=dp[pre+1][curRes]+dp[pre][curRes-pre];// 分析的关系
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

## 数字转化成字母（树形）

![image-20211214220923610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220923610.png)

**递归实现**

- 时间复杂度为指数级

```
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```

**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。

- 时间复杂度为O(N)

  ```
  public class Main {
  	public static int process(String string) {
  		if (string == null || string.length() == 0) {
  			return 0;
  		}
  		if (string.length() == 1) {
  			return string == "0" ? 0 : 1;
  		}
  		char[] arr = string.toCharArray();
  		int N = arr.length;
  		int[] res = new int[arr.length + 1];
  		res[N] = 1;
  		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
  		for (int i = N - 2; i >= 0; --i) {
  			if (arr[i] == '0') {
  				res[i] = 0;
  			} else {
  				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
  					res[i] = res[i + 1];
  				} else {
  					res[i] = res[i + 1] + res[i + 2];
  				}
  			}
  		}
  		return res[0];
  	}
  }
  
  ```




## 数字转为字符串

![image-20211228093016742](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093016742.png)





## [ 字符串的全排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)


全排列不重复

visit记录这个位置是否已经被当前字母试过全排列试过，每次都重新初始化visit，这样可以在同一个位置的下一个位置去跟别的位置交换的时候看是不是重复过。



### 回溯

```java
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.List;
import java.util.PriorityQueue;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/12
 * @Version 1.0
 **/
class Solution {
    public List<String> list = new ArrayList<>();
    public String[] permutation(String s) {
        char[] chars = s.toCharArray();
        process(chars, 0);
        int size = list.size();
        String[] recArr = new String[size];
        for (int i = 0; i < size; i++) {
            recArr[i] = list.get(i);
        }
        return recArr;

    }

    private void process(char[] chars, int i) {
        if (i == chars.length) {// 结果
            list.add(new String(chars));
            return;
        }
        boolean[] isVisited = new boolean[26];// 默认只有小写字母
        for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
            if (!isVisited[chars[j] - 'a']) {// 是否重复
                isVisited[chars[j] - 'a'] = true;
                swap(chars, i, j);// 交换
                process(chars, i + 1);// 递归
                swap(chars, i, j);// 恢复
            }
        }
    }

    private static void swap(char[] chars, int i, int j) {
        char c = chars[i];
        chars[i] = chars[j];
        chars[j] = c;
    }
}

```

```java
class Solution {
    List<String> rec;
    boolean[] vis;

    public String[] permutation(String s) {
        int n = s.length();
        rec = new ArrayList<String>();
        vis = new boolean[n];
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        StringBuffer perm = new StringBuffer();
        backtrack(arr, 0, n, perm);
        int size = rec.size();
        String[] recArr = new String[size];
        for (int i = 0; i < size; i++) {
            recArr[i] = rec.get(i);
        }
        return recArr;
    }

    public void backtrack(char[] arr, int i, int n, StringBuffer perm) {
        if (i == n) {
            rec.add(perm.toString());
            return;
        }
        for (int j = 0; j < n; j++) {
            if (vis[j] || (j > 0 && !vis[j - 1] && arr[j - 1] == arr[j])) {
                continue;
            }
            vis[j] = true;
            perm.append(arr[j]);
            backtrack(arr, i + 1, n, perm);
            perm.deleteCharAt(perm.length() - 1);
            vis[j] = false;
        }
    }
}


```





### 下一个排列

[31. 下一个排列的官方题解](https://leetcode-cn.com/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/)

```
class Solution {
    public String[] permutation(String s) {
        List<String> ret = new ArrayList<String>();
        char[] arr = s.toCharArray();
        Arrays.sort(arr);
        do {
            ret.add(new String(arr));
        } while (nextPermutation(arr));
        int size = ret.size();
        String[] retArr = new String[size];
        for (int i = 0; i < size; i++) {
            retArr[i] = ret.get(i);
        }
        return retArr;
    }

    public boolean nextPermutation(char[] arr) {
        int i = arr.length - 2;
        while (i >= 0 && arr[i] >= arr[i + 1]) {//从后往前寻找一个逆序排列的ab（a<b），此时i位于b
            i--;
        }
        if (i < 0) {
            return false;//说明已经是最大的字符串了，无法继续找下一个大点的字典序
        }
        int j = arr.length - 1;
        while (j >= 0 && arr[i] >= arr[j]) {//从后往前找第一个比i大的最小值，i后面应该都是从大到小排列了，相当于找到的是比i大的最小的
            j--;
        }
        swap(arr, i, j);//交换这俩位置，交换后应该还是有序的（倒叙成54321），因为j前面的比i大，j后面的比i小。因为是逆序，肯定能在i后面找一个这样的j
        reverse(arr, i + 1);//从i+1（包含）位置开始，倒叙，也就是54321变为12345.
        return true;
    }

    public void swap(char[] arr, int i, int j) {
        char temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public void reverse(char[] arr, int start) {
        int left = start, right = arr.length - 1;
        while (left < right) {
            swap(arr, left, right);
            left++;
            right--;
        }
    }
}

```









## 字符串的全排列

![image-20211228093104568](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093104568.png)

1. 我们通常都思路都是将所有字符依次放在最前面，例如ABC，第一位为A，B,C，然后判断第二位，那么我们如何在字符串中标记该字符已经被我们安排在前面了？

2. 若我们使用下标的方式，那么在每次选择都会产生一个下标，这样会很乱。

3. 于是我们可以通过将欲放在前面的字符就直接放在前面（将字符一次和后面的交换），用一个下标指引我们前面已经定了多少的元素。

4. 但是若我们交换后在后续调用时，数据顺序已经打乱，我们可能会造成重复情况，所以我们在每次运行后再将数据交换变成原来位置。

5. 但是当数据有重复字符时，会出现重复的全排列，这是我们就要判断交换的字符是否和之前交换的相同，若相同，就不用交换

   ```java
   class Main {
   	public static List<String> list = new ArrayList<>();
   
   	public static void process(String string) {
   		char[] chars = string.toCharArray();
   		process(chars, 0);
   	}
   
   	private static void process(char[] chars, int i) {
   		if (i == chars.length) {// 结果
   			list.add(new String(chars));
   			return;
   		}
   		boolean[] isVisited = new boolean[26];// 默认只有大写字母
   		for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
   			if (!isVisited[chars[j] - 'A']) {// 是否重复
   				isVisited[chars[j] - 'A'] = true;
   				swap(chars, i, j);// 交换
   				process(chars, i + 1);// 递归
   				swap(chars, i, j);// 恢复
   			}
   		}
   	}
   
   	private static void swap(char[] chars, int i, int j) {
   		char c = chars[i];
   		chars[i] = chars[j];
   		chars[j] = c;
   	}
   }
   ```

   https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

   ```
   class Solution {
       List<String> res = new LinkedList<>();
       char[] c;
       public String[] permutation(String s) {
           c = s.toCharArray();
           dfs(0);
           return res.toArray(new String[res.size()]);
       }
       void dfs(int x) {
           if(x == c.length - 1) {
               res.add(String.valueOf(c));      // 添加排列方案
               return;
           }
           HashSet<Character> set = new HashSet<>();
           for(int i = x; i < c.length; i++) {
               if(set.contains(c[i])) continue; // 重复，因此剪枝
               set.add(c[i]);
               swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
               dfs(x + 1);                      // 开启固定第 x + 1 位字符
               swap(i, x);                      // 恢复交换
           }
       }
       void swap(int a, int b) {
           char tmp = c[a];
           c[a] = c[b];
           c[b] = tmp;
       }
   }
   ```

   



# 贪心算法

## [409. 最长回文串](https://leetcode-cn.com/problems/longest-palindrome/)

只允许有一个单个字符，其余都是两个

```java
class Solution {
    public int longestPalindrome(String s) {
        int[] count = new int[128];
        int length = s.length();
        for (int i = 0; i < length; ++i) {
            char c = s.charAt(i);
            count[c]++;
        }

        int ans = 0;
        for (int v: count) {
            ans += v / 2 * 2;
            if (v % 2 == 1 && ans % 2 == 0) {
                ans++;
            }
        }
        return ans;
    }
}

```





## 绳子覆盖问题

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/60e968bcb3e94c07b3d48db38b220c81.png)



#### 定右二分向左查找O(N*logN)

- 最主要还是二分的实现，**详见查找深度探索二分查找**

```java
public class Main {
	public static int process(int[] arr, int L) {
		if (arr == null || arr.length == 0 || L <= 0) {
			return 0;
		}
		int res = 1;
		for (int i = 0; i < arr.length; i++) {
			int index = bRNum(arr, i, arr[i] + L);
			res = Math.max(res, index - i + 1);
		}
		return res;
	}
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```



#### 滑动窗口的解法

```java
两个值，从左往右，一个是开始位置l，一个是右边界r，保证arr[r]-arr[l]>=L，记录下r-l+1的值
```



## 前后缀差点最大值

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/cacd1046d8a0429a996570d3eccc6007.png)

一般思路：数据预处理建立两个从左右两端的最值数组，再遍历求解。
极限贪心思维：直接获取最大值和左右两端的差值
两个最大值数中定存在一个整体的最大值。
在满足将最大值放在一左端，无论怎么选择, 右一半的最大值一定大于等于最右端的元素。所以右侧最值最小只能是最右边的元素。
在满足将最大值放在一右端时同理，只需要这两种情况下取最值即可。

```java 
public class Test {
    public static int num(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        int max=arr[0];
        for (int i = 1;i < arr.length; i++){
            max = Math.max( max, arr[i]);
        }
        return Math.max(max-arr[0],max-arr[arr.length-1]);
    }
}
```



子数组累计和最大值

## magic操作

![image-20211227234337115](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234337115.png)



需要将平均值大的集合里面，拿出去介于两个平均值的值的数字到平均值小的集合里面。
尽量拿靠近平均值小的数字移动。也就是拿最小的

![image-20211227234858672](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234858672.png)
![image-20211227235542296](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235542296.png)

![image-20211227235737178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235737178.png)


因为magic操作会将两个集合的平均值都变大，所以每个可以操作数之前的数可以不用在下一轮选数里面考虑了。

## 括号深度

![image-20211228000346795](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228000346795.png)



遇到（ count++，遇到）count--，count最大的值就是深度。



## 超级洗衣机

https://leetcode-cn.com/problems/super-washing-machines/



![image-20211229085418463](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229085418463.png)



![90f2d42ebf6e4514aa4ea839f36ec099](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/90f2d42ebf6e4514aa4ea839f36ec099.png)



![image-20211229091620577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229091620577.png)



因为每次只能放到相邻的位置，相当于分成两半以后，每次只能通过选定位置传送一件衣服到另一半。

```java
public class Test {
    public static int minPoint(int[] machines) {
        if (machines == null || machines.length == 0) return -1;
        int N = machines.length;
        int allSum = 0;
        for (int i : machines) {
            allSum += i;
        }
        if (allSum % N != 0) return -1;
        int average = allSum / N;
        int leftSum = 0;
        int res = 0;
        for (int i = 0; i < N; i++) {
            int leftRest = leftSum - average * i;
            int rightRest = (allSum - leftSum - machines[i]) - (N - 1 - i) * average;
            if (leftRest < 0 && rightRest < 0) {
                res = Math.max(res, Math.abs(leftRest) + Math.abs(rightRest));
            } else {
                res = Math.max(res, Math.max(Math.abs(leftRest), Math.abs(rightRest)));
            }
            leftSum += machines[i];
        }
        return res;
    }
}

```

## 找工作

![image-20220111230320313](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111230320313.png)



![image-20220111231245062](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111231245062.png)

```java
public class Test {
    public static int[] process(Job[] jobs, int[] ability) {
        Arrays.sort(jobs, (o1, o2) -> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money));
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(jobs[0].hard, jobs[0].money);
        Job j = jobs[0];
        // 将同 hard 情况下 money 最多的进入map
        for (Job job : jobs) {
            if (job.hard != j.hard && job.money > j.money) {
                j = job;
                map.put(j.hard, j.money);
            }
        }
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            // 小于或等于ability[i]的最大键值
            Integer key = map.floorKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }
    static class Job {
    	int hard;
    	int money;
	}
}

```



**java treemap_Java TreeMap floorKey（）方法与示例**

**floorKey()方法**用于返回小于或等于给定键元素(key_ele)的最大键元素(如果存在)，否则，当不存在该键元素时返回null。**floorKey()方法**是一种非静态方法，只能通过类对象访问，如果尝试使用类名称访问该方法，则会收到错误消息。



## 子数组累计和最大值



![image-20220117094756580](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117094756580.png)



![image-20220117213014775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117213014775.png)

```
public class Test {
    public static int maxLenNum(int[] arr){
        int max=Integer.MIN_VALUE;
        int cur=0;
        for (int i : arr) {
            cur+=i;
            max=Math.max(max,cur);
            cur=Math.max(cur, 0);
        }
        return max;
    }
}

```

## 子矩阵累计和最大值(压缩数组)

![image-20220117214128825](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214128825.png)



![image-20220117214111768](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214111768.png)



- 子矩阵往往考虑是否可以转换成字数组的问题，就是将多行转化成一行或者多列转化成多列
- 转化之后思考一维情况下的解决思路，看看是否能应用到矩阵中。
  求出

0-0行 0-1行 0-2行。。0-n行，1-1行1-2行。。。1-n行 ，2-2行。。。。n-n行，将这些区间行对应列的值加在一起成为一行，然后用上面的方法求出最大值，最终的最大值就是子矩阵的最大值

这是**行压缩的方法**

```java
public class Test {
    public static int maxAreaNum(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int cur;
        int[] sumArr;
        for (int i = 0; i != arr.length; i++) {
            sumArr = new int[arr[0].length];
            for (int j = i; j != arr.length; j++) {
                cur = 0;
                for (int k = 0; k != sumArr.length; k++) {
                    sumArr[k] += arr[j][k];
                    cur += sumArr[k];
                    max = Math.max(max, cur);
                    cur = Math.max(cur, 0);
                }
            }
        }
        return max;
    }
}

```

## 安路灯

![image-20220117233125057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117233125057.png)





- 一个简单的贪心思想，将路灯尽量安装在需要安装的第二个位置。

- ```java
  public class Test {
      public static int minNum(String s) {
          char[] arr = s.toCharArray();
          int minNum = 0;
          int index = 0;
          while (index < arr.length) {
              if (arr[index] == 'X') {
               //不点灯
                  index++;
              } else {
                   //这个位置需要点亮，前面都是亮的，因此可以放在这个位置，也可以放在这个位置的下一个。
                  minNum++;
                  if (index + 1 == arr.length) {
                      break;.
                    //下一个是x，就直接去下下一个看
                  } else if (arr[index + 1] == 'X') {
                      index += 2;
                  } else {
                      //下一个不是x，相当于是...或者..*，将灯放在第二个点，然后直接去下下下个位置，这个位置需要点亮，这个位置以前的都是亮的。
                      index += 3;
                  }
              }
          }
          return minNum;
      }
  }
  
  ```

- 



## 排序相邻最大差值

- 构造一个差值范围，使差值在该范围内的所有数据都放弃考虑，从减小了大量的情况。

![image-20220124224846491](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124224846491.png)

- 用分桶的方法，将n个数分到n+1个桶中，每个桶只记录最大值和最小值。用一个boolean数组记录桶里面是否有数字，一个数组记录最大值，一个数组记录最小值

- 然后挨个计算相邻桶的差值（后一个桶的最小值和前一个桶的最大值），求出最大值就是结果

- 尤其要注意看一个数字分去哪个桶的算法。
  n+1个桶，每个桶间隔的数字gap= (max-min)/n。

  数字a应该去哪个桶？ (a-min)/gap =(a-min)*len/(max-min)
  如果a==min,则该去0号桶。
  如果a == max，应该去len号桶，而不是len-1号桶。因此上面的三个数组都要创建(len+1)的长度才能切分。

风 22:47:30
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/21B1F7EE322861D11A11DF35E1C3B291.png)



![image-20220124225001279](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225001279.png)

![image-20220124225029666](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225029666.png)



```java
public class Main {
	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
		// 记录桶中是否存在值
		boolean[] hasNum = new boolean[len + 1];
		int[] maxs = new int[len + 1];
		int[] mins = new int[len + 1];
		int bid = 0;
        // 由于多一个桶，那么其中一个桶定为空，最大差值定比一个桶的范围大
        // 最大差值定比的两个数定在不同的桶中，选出每个桶中的最大值最小值
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max);// 该数应该在桶中的下标
			// 更新桶中的最大最小值
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = maxs[0];

		// 最大差值定存在于不同的桶中
		for (int i = 1; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];// 记录该桶的最大值，用于后续不同桶的最大差值的比较
			}
		}
		return res;
	}
	// 计算桶的下标索引
	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
}

```




![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/04030C2E7169D2A81FE489D649658BA0.png)



## 过河

![image-20220205201539832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205201539832.png)



- 贪心思想：将最小的和较大的放在一条上，若能就放一条上，否则让较大的自己一条。

- ![image-20220205205653104](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205205653104.png)

- ![image-20220205211557507](C:/Program%20Files/Typora/image-20220205211557507.png)

- ![image-20220205212541779](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212541779.png)
  ![image-20220205212639057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212639057.png)
  ![image-20220205223114248](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223114248.png)

- 

  ```java
  public class Main {
  	public static int minBo(int[] arr, int weight) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		Arrays.sort(arr);
  		if (arr[arr.length-1]>weight) {
  			return Integer.MAX_VALUE;
  		}
  		int left = 0;
  		int right = arr.length - 1;
  		int boatNum = 0;
  		while (left <= right) {
  			if (arr[right] + arr[left] <= weight) {
  				++left;
  			}
  			--right;
  			++boatNum;
  		}
  		return boatNum;
  	}
  }
  
  ```

  











# 打表法

- 出现和倍数相关的问题时，可以考虑通过一般方法解题后的结果是否存在某种特殊的规律，通过直观的答案直接进行代码的书写，不需要关注本质含义。

## 整体装袋



![image-20211219220615833](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219220615833.png)

**一般思路**

可以发现，超过6和8的最小公约数以后，构成的差值一直是3/5/1循环，超过24以后，也就是8的倍数，每个rest都可以映射到减去24的某个rest。

如果超过rest超过24以后，就没必要尝试试了，因为24是6和8的最小公倍数

107个苹果

107/8=13

8的包数 	rest	mod6余数  

13				3		3

12				11		5

11				19		1

10				27		3

9					35		5

8					43		1	

```
public class Main {
	public static int num(int apple) {
		if (apple % 8 == 0)
			return apple / 8;
		int n8 = apple / 8;
		int m = apple % 8;
		while (m < 24 && n8 >= 0) {
			if (m % 6 == 0)
				return n8 + m / 6;
			--n8;
			m += 8;
		}
		return -1;
	}
}

```





**打表代码**
![image-20211219232123273](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232123273.png)

- 18前无规律，18后单为-1，双为一个值，每增加8个就增加1

```
public class Main {
	public static int daBiao(int apple) {
		if (apple < 18)
			return apple == 0 ? 0
					: (apple == 6 || apple == 8) ? 1 
						: (apple == 12 || apple == 14 || apple == 16) ? 2 
							: -1;
		if (apple % 2 == 1)
			return -1;
		return (apple - 18) / 8 + 3;
	}
}

```

2*8=16

3*6=18

差值是2，当大于18以后，多的2可以通过这个转换转换为8或者6的袋子，因此奇数肯定不可能凑成，大于18的偶数可以凑成。

## 幂次方吃草

![image-20220324225613294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220324225613294.png)

不是看谁吃得多，而是看谁最后吃不了剩下的草算输



```
public class Main {
	public static String winner(int N) {
		if (N <= 4)
			return N == 0 || N == 2 ? "羊羊" : "牛牛";
		int eatTest = 1;
		while (eatTest <= N) {
			if (winner(N - eatTest).equals("羊羊"))
				return "牛牛";
			eatTest *= 4;
		}
		return "羊羊";
	}
}

```

![image-20211219232823835](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232823835.png)

![image-20211219232220642](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232220642.png)



```
public static String win(int N){
    return (N)%5==0||(N)%5==2?"羊羊":"牛牛";
}

```





# 枚举

### 优化枚举方法

- 每次计算时出现重复的动作，我们就将这些操作在计算之前进行直接处理，在我们需要时直接进行数据的获取。



### 最小染色数

![image-20220308140350585](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220308140350585.png)



**枚举**

遍历每一个位置i，从0到length，i位置往右设置为G，i位置往左设置为R，则以i为边界。左边有个G就涂成R，右边有一个R，就涂成G，记录最小涂得数量

```java
public class Main {
	public static int process(String s) {
		char[] arr = s.toCharArray();
		int min = Integer.MAX_VALUE;
		int N = arr.length;
		for (int i = 0; i <= N; i++) {
			int num = 0;
			for (int j = 0; j < i; ++j) {
				if (arr[j] == 'G') {
					++num;
				}
			}
			for (int j = i; j < N; ++j) {
				if (arr[j] == 'R') {
					++num;
				}
			}
			min = Math.min(min, num);
		}
		return min;
	}
}

```

**优化枚举**

- 在我们枚举所有情况时发现：对于每次计算单方向上的G，R的个数均可以在之前的操作中部分求出，但是尽管我们之前已经部分求出，在每次计算的时候并没有得到充分应用，只是重复的计算单方向上R，G的个数，正式因为这些重复的计算，造成我们时间效率上有巨大的提升空间。

leftSum 记录每个位置（包含）左边有几个G，

rightSum 记录每个位置（包含）右边有几个R

```java
public class Main {
	public static int process(String s) {
		char[] arr = s.toCharArray();
		int N = arr.length;
		int[] leftSum = new int[N];
		leftSum[0] = arr[0] == 'G' ? 1 : 0;
		// 左累加
		for (int i = 1; i < N; i++) {
			leftSum[i] = leftSum[i - 1] + (arr[i] == 'G' ? 1 : 0);
		}
		int[] rightSum = new int[N];
		// 右累加
		rightSum[N - 1] = arr[N - 1] == 'R' ? 1 : 0;
		for (int i = N - 2; i >= 0; i--) {
			rightSum[i] = rightSum[i + 1] + (arr[i] == 'R' ? 1 : 0);
		}
		// 根据累加计算最小值，注意这时代交错相加。也就是把所有的都涂成R或者G时候需要涂几个
		int min = Math.min(leftSum[N - 1], rightSum[0]);
		for (int i = 1; i < N; i++) {
			min = Math.min(min, leftSum[i - 1] + rightSum[i]);
		}
		return min;
	}
}

```









### 矩阵最大正方形

![image-20211221215153594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211221215153594.png)

- 还是若我们直接对于单个起始位置寻找，对于每个其实位置进行判断的话时间复杂度就会比较高
- 由此我们要单向记录连续1的个数

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(maxLen(new int[][]{
        		{0, 1, 1, 1, 1, 1},
                {0, 1, 0, 0, 1, 1},
                {0, 1, 0, 0, 1, 0},
                {1, 1, 1, 1, 1, 1},
                {0, 1, 0, 1, 1, 1}}));
    }

    public static void show(int[][] a) {
        for (int[] aa : a) {
            System.out.println(Arrays.toString(aa));
        }
        System.out.println();
    }

    public static int maxLen(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        show(arr);
        
        //*******************生成向横向的累计连续数值******************
        int[][] rightArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = arr[0].length - 1; j >= 0; j--) {
                rightArr[i][j] = arr[i][j] == 0 ? 0 : j == arr[0].length - 1 ? 1 : rightArr[i][j + 1] + 1;
            }
        }
        show(rightArr);

        //*******************生成向纵向的累计连续数值******************
        int[][] downArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < arr[0].length; i++) {
            for (int j = arr.length - 1; j >= 0; j--) {
                downArr[j][i] = arr[j][i] == 0 ? 0 : j == arr.length - 1 ? 1 : downArr[j + 1][i] + 1;
            }
        }
        show(downArr);

        //*************************从小到大看看多大的正方形存在**************************8
        for (int size = Math.min(arr.length, arr[0].length); size != 0; size--) {
            if (hasSizeOfBorder(size, rightArr, downArr)) {
                return size;
            }
        }
        return 0;
    }

    private static boolean hasSizeOfBorder(int size, int[][] rightArr, int[][] downArr) {
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = 0; j < rightArr[0].length; j++) {
                if (rightArr[i][j] >= size && downArr[i][j + size - 1] >= size &&
                        downArr[i][j] >= size && rightArr[i + size - 1][j] >= size)
                    return true;
            }
        }
        return false;
    }
}

```

![image-20220310231519666](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220310231519666.png)







### 括号字符

![image-20211227233419037](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233419037.png)

![image-20211227233649531](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233649531.png)





### 差值为k的去重数字对

![image-20211227233908870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233908870.png)



使用hashset记录每个元素，然后遍历arr，找个一个数，加上k看这个值在不在hashset里面，在的话就加1。











# 业务题

## 被3整除的数的个数

![image-20220118233659667](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118233659667.png)





```

```

# 查找

## 深度探索二分查找

- **注意med的取法和R或L的调整方式**

### 经典二分查找



```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```

### 查找大于该值的最小值

```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med;
			}
		}
		return L;
	}
}

```

### 查找大于等于目标值的最右值

```
public class Main {
	// 返回大于等于target的最右元素
    private int rightest(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] == target) left = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

### 查找小于该值的最大值

````
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

````

### 查找小于等于目标值的最左值

```
class Main {
	// 返回小于等于target最左元素
    private int leftest(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

## 查找极小值

题目：
极值定义该值比左右的值都小，如果是在数组两侧则只比较一点即可。
在无序数组中找到该极小值。

```
public class Main {
	private static Integer process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int N = arr.length;
		if (N == 1) {
			return arr[0];
		}
		// 最左侧
		if (arr[0] < arr[1]) {
			return arr[0];
		}
		// 最右侧
		if (arr[N - 1] < arr[N - 2]) {
			return arr[N - 1];
		}
		int left = 1;
		int right = N - 2;
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			// right=med+1和left=med这种情况是在判断条件为arr[med]>arr[med-1]时
			if (arr[med] < arr[med + 1]) {
				right = med;
			} else {
				left = med + 1;
			}
		}
		return arr[left];
	}
}

```



## 无序数组中第k大的值



类似的题目

[剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode-cn.com/problems/xx4gT2/)

bfprt

![image-20220209092642502](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209092642502.png)





![image-20220209094413363](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094413363.png)





![image-20220209094455765](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094455765.png)

![image-20220209094748264](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094748264.png)
![image-20220209094913219](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220209094913219.png)






## 两个有序数组寻找第k大的值

![image-20220125233334064](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125233334064.png)





### 归并排序子过程O(logk)

### 二分判定O(log(m)*log(n))

### O(log(min{n,m}))

```
public class Test {
    public static int findKthNum(int[] arr1, int[] arr2, int kth) {
        if (arr1 == null || arr2 == null) {
            throw new RuntimeException("Your arr is invalid!");
        }
        if (kth < 1 || kth > arr1.length + arr2.length) {
            throw new RuntimeException("K is invalid!");
        }
        int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
        int[] shorts = arr1.length < arr2.length ? arr1 : arr2;
        int l = longs.length;
        int s = shorts.length;
        if (kth <= s) {
            return getUpMedian(shorts, 0, kth - 1, longs, 0, kth - 1);
        }
        if (kth > l) {
            if (shorts[kth - l - 1] >= longs[l - 1]) {
                return shorts[kth - l - 1];
            }
            if (longs[kth - s - 1] >= shorts[s - 1]) {
                return longs[kth - s - 1];
            }
            return getUpMedian(shorts, kth - l, s - 1, longs, kth - s, l - 1);
        }
        if (longs[kth - s - 1] >= shorts[s - 1]) {
            return longs[kth - s - 1];
        }
        return getUpMedian(shorts, 0, s - 1, longs, kth - s, kth - 1);
    }

    public static int getUpMedian(int[] a1, int s1, int e1, int[] a2, int s2,
                                  int e2) {
        int mid1 = 0;
        int mid2 = 0;
        int offset = 0;
        while (s1 < e1) {
            mid1 = (s1 + e1) / 2;
            mid2 = (s2 + e2) / 2;
            offset = ((e1 - s1 + 1) & 1) ^ 1;
            if (a1[mid1] > a2[mid2]) {
                e1 = mid1;
                s2 = mid2 + offset;
            } else if (a1[mid1] < a2[mid2]) {
                s1 = mid1 + offset;
                e2 = mid2;
            } else {
                return a1[mid1];
            }
        }
        return Math.min(a1[s1], a2[s2]);
    }
}

```



# 其他

## 判断是不是质数

见   题目计算质数

    ## 自定义比较器

​    https://blog.csdn.net/whing123/article/details/77851737
​    
​     Comparator
​    class Teacher{  
​        int num;  
​        double salary;  
​    public Teacher(int num, double salary) {  
​        this.num = num;  
​        this.salary = salary;  
​    }  
​    
​    @Override  
​    public String toString() {  
​        return "\r\tnum:"+num+" salary:"+salary+"\r";  
​    }  
​    }  
​    
​    class StudentComparator implements Comparator{  
​    public int compare(Object o1, Object o2) {  
​        Teacher t1 = (Teacher) o1;  
​        Teacher t2 = (Teacher) o2;  
​        int result = t1.num > t2.num ? 1 : (t1.num == t2.num ? 0 : -1);  
​        return result = result == 0 ?(t1.salary<t2.salary ? 1 : -1) : result;  
​    }   
​    }  
Comparable

     import java.util.ArrayList;  
    import java.util.Collections;  
    import java.util.Comparator;  
    import java.util.List;  
    
    public class CompareTest {  
        public static void main(String[] args) {  
            List<Student> list = new ArrayList<Student>(10);  
            list.add(new Student(1,"jj"));  
            list.add(new Student(0,"ww"));  
            list.add(new Student(0,"kk"));  
            list.add(new Student(2,"ll"));  
            Collections.sort(list); // 内部比较器:要排序的类实现Comparable接口,可以对自身进行比较  
            System.out.println(list);  
       List<Teacher> t = new ArrayList<Teacher>(10);  
        t.add(new Teacher(1,12));  
        t.add(new Teacher(0,13));  
        t.add(new Teacher(0,14));  
        t.add(new Teacher(2,15));  
        Collections.sort(t,new StudentComparator()); //外部比较器:通过额外的类来实现Comparator接口  
        System.out.println(t);  
        }  
    }  


​	```





```
class Student implements Comparable {  
	int num;  
	String name;  
	
	public Student(int num, String name) {  
	    this.num = num;  
	    this.name = name;  
	}  
	
	@Override  
	public String toString() {  
	    return "\r\tnum:"+num+" name:"+name+"\r";  
	}  
	
	public int compareTo(Object o) {  
	    Student tmp = (Student) o;  
	    int result = tmp.num > num ? 1 : (tmp.num==num ? 0 : -1);  
	    if (result == 0) {  
	        result = tmp.name.indexOf(0) > name.indexOf(0) ? 1 : -1;  
	    }  
	    return result;  
	    }  
	}  
```







## 1 比较器

```
  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }
```



你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 2 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2



## 求解最小公倍数





## 二分法

查找一个数组元素的下标。
二分法适用于已经排好序的数组，定义两个变量，一个low,一个high,则mid=(low+high)/2

算法核心：
如果 value==arr[mid],中间值正好等于要查找的值，则返回下标，return mid;

如果 value<arr[mid],要找的值小于中间的值，则再往数组的小端找，high=mid-1;

如果 value>arr[mid],要找的值大于中间的值，则再往数组的大端找，low=mid+1;

```
import java.util.Arrays;
 
/**
 * 测试二分法查找
 * 二分法适用于已经排好序的数组
 * @author Administrator
 *
 */
public class TestBinarySearch {
	public static void main(String[] args) {
		int[] arr= {30,20,50,10,80,9,7,12,100,40,8};
		Arrays.sort(arr);
		System.out.println(Arrays.toString(arr));
		System.out.println(myBinarySearch(arr,40));
		}
	
	public static int myBinarySearch(int[] arr,int value) {
		int low=0;
		int high=arr.length-1;
		while(low<=high) {
			int mid=(low+high)/2;
			if(value==arr[mid]) {
				return mid;
				}
			if(value>arr[mid]) {
				low=mid+1;	
			}
			if(value<arr[mid]) {
				high=mid-1;
			}
			
		}
		return -1;//没有找到返回-1
	}
	
}
```

## [关于二分法 查找的边界问题，大于等于目标值的最小值，小于等于目标值的最大值。](https://www.cnblogs.com/welen/articles/9984058.html)

```
/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/12
 * @Version 1.0
 **/
public class binary {
    public static void main(String[] args) {
        int a[]={1,3,5,7,9,12,43,56,67,78};
        System.out.println(binary_search_upperbound(a,10,3));
        System.out.println(binary_search_lowerbound(a,10,56));
    }
    static int binary_search_upperbound(int a[], int n, int key){

        if(key>=a[n-1]) return -1;//如果是大于等于key的第一个值，则此处改为>

        int low,high,mid;
        low=0;
        high=n-1;
        mid=(low+high)/2;
        while(low<high){
            if(key<a[mid])//如果是大于等于key的第一个值，则此处改为<=
                high=mid;
            else
                low=mid+1;
            mid=(low+high)/2;
        }
        System.out.println(mid==high? "YES":"No");// mid是等于high的
        return a[mid];
    }

    // 查找小于key的第一个值
    static int binary_search_lowerbound(int a[], int n, int key){
        if(key<=a[0]) return -1;//如果是大于等于key的第一个值，则此处改为<
        int low,high,mid;
        low=0;
        high=n-1;
        mid=(low+high+1)/2;
        while(low<high){
            if(key>a[mid])//如果是大于等于key的第一个值，则此处改为>=
                low=mid;
            else
                high=mid-1;
            mid=(low+high+1)/2; //如果不加1，会有死循环
        }
        System.out.println((mid==low? "YES":"No"));
        return a[mid];
    }
}

```





```java
int a[10] = { 1, 4, 5, 3, 2, 1, 2, 3, 4, 2 };
sort(a, a + 10);
//sort(a,a+10,cmp);
int x;
 
 
 
while (scanf("%d", &x) != EOF)
{
     
    for (int i = 0; i<10; i++)
        printf("%d ", i);
    printf("\n");
    for (int i = 0; i<10; i++)
        printf("%d ", a[i]);
    printf("\n");
    int flag = 1;
    int less_last_mid = -1;
    int low = 0, high = 9, mid;
 
    while (low <= high)//循环必须包括等于，因为只有包括等于，才会把low,high数据都访问一遍。
    {
     
            //在查找指定目标值时，可能漏掉
            //例如，倒数第二步时，low, high=low+1；mid取floor((low+high)/2)=low，只把low访问到了，可能漏掉high没有访问到，下次就是(mid偏小，漏掉)<br>                //low=mid+1或者(mid偏大)high=mid-1(high<low);即
 
            //high<-mid->low
            //low  high
            //如果只是查找目标值，只需要比较等于即可。
 
            //如果要查找到大于等于目标值的最小值，应该就是high的最后位置，因为high一开始就是大于等于目标值，直到high向左移动的最后的位置，如果high最终的位置比目标值还要小，
            //则查找不到。
 
            //同样地，如果查找小于等于目标值的最大值，应该就是low的最后位置，如果low的最终位置比目标值还要大，则查找不到。<br>
            //如果要找到小于x的最大值，则
            //最后一步,flag=0时，flag=1时的最后一次mid，即less_last_mid为x最终的值
            //如果flag = 1时， 保存最后一次mid即可,即data[less_last_mid]
            //另外就是越界，找不到
        mid = (low + high) / 2;
        if (a[mid] < x)//如果1：要找的是小x的最大值;
 
        {//如果2：要找的是小于等于x的最大值; if (a[mid] <= x)
 
            less_last_mid = mid;
            low = mid + 1;
            flag = 1;//假设最后一步，走在这里，变成了low>high这个无理的条件，这是因为Low的变化造成的，所以low的值已无法使用
        }
 
        else
        {
            high = mid - 1;
            flag = 0;//假设最后一步，走在这里，变成了low>high这个无理的条件，这是因为high的变化造成的，所以high的值已无法使用
        }
    }
    if (flag)
    {//肯定存在
        printf("flag=0:%d\n", a[less_last_mid]);
    }
    else//可能不存在,调整high左移
    {
        if (high >= 0)
        {
            printf("flag=0:%d\n", a[less_last_mid]);
        }
        else
        {
            printf("不存在\n");
        }
    }
}
```



## 快速排序





## 利用二分法寻找最某个值或者最大于某个值的最小值



```
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
```



## 判定数字某位二进制的值是不是1



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



## 自定义大顶堆&小顶堆





大顶堆

```
  PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });


```

插入元素  `  pq.offer(new int[]{nums[i], i});`

查看堆顶元素 `pq.peek()[1] <= i - k`

弹出堆顶元素 `pq.poll()`



***（优先队列）***:默认是小顶堆

```
        PriorityQueue<Integer> heap = new PriorityQueue<>();
        heap.add(3);
        heap.add(2);
        heap.add(5);
        while (!heap.isEmpty()){
            System.out.println(heap.poll());
        }
        
2
3
5

```







## 双端队列

定义：`Deque<Integer> deque = new LinkedList<Integer>();`

当队列使用：
				尾部弹出 ` deque.pollLast();`

​		查看尾部元素`deque.peekLast()`	

​		查看头部元素 `deque.peekFirst()`

​		尾部插入 ` deque.offerLast(i);`



当栈使用：

 ```
 Deque<Integer> stack = new LinkedList<Integer>()
 deque.push()
 deque.pop()
 deque.peek()
 ```

当成队列使用

```
Deque<Integer> deque = new LinkedList<>();
deque.offer(i);
deque.poll()  
```

```
package test;

import java.util.Deque;
import java.util.LinkedList;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/30
 * @Version 1.0
 **/
public class stacktest {
    public static void main(String[] args) {
        Deque<Integer> deque = new LinkedList<>();
        //当成栈使用,pop()和poll效果一样
        for (int i = 0; i < 5; i++) {
            deque.push(i);
        }
        //4	3	2	1	0
        while (!deque.isEmpty()){
            System.out.print(deque.pop()+"\t");
        }
        System.out.println();
        // 当成队列使用
        for (int i = 0; i < 5; i++) {
            deque.offer(i);
        }
        //0	1	2	3	4
        while (!deque.isEmpty()){
            System.out.print(deque.poll()+"\t");
        }

    }
}

```

用push和pollLast表示队列

用push和pollFirst表示栈

```
package test;

import java.util.Deque;
import java.util.LinkedList;

/**
 * @author chilcyWind
 * @Description
 * @Author Yang
 * @Date 2022/3/30
 * @Version 1.0
 **/
public class stacktest {
    public static void main(String[] args) {
        Deque<Integer> deque = new LinkedList<>();
        // 当成队列使用
        for (int i = 0; i < 5; i++) {
            deque.push(i);
        }
        //0	1	2	3	4
        while (!deque.isEmpty()){
            System.out.print(deque.pollLast()+"\t");
        }
        System.out.println();
        // 当成栈使用
        for (int i = 0; i < 5; i++) {
            deque.push(i);
        }
        //4	3	2	1	0	
        while (!deque.isEmpty()){
            System.out.print(deque.pollFirst()+"\t");
        }
    }
}

```





offer（）：

如果可以在不违反容量限制的情况下立即执行此操作，则将指定元素插入此双端队列表示的队列中（换句话说，在此双端队列的尾部），成功时返回 true，如果当前没有可用空间则返回 false。 当使用容量受限的双端队列时，此方法通常优于 add 方法，后者仅通过抛出异常可能无法插入元素。
此方法等效于 offerLast。

push（）：

如果可以在不违反容量限制的情况下立即将元素推送到此双端队列表示的堆栈上（换句话说，在此双端队列的头部），则如果当前没有可用空间则抛出 IllegalStateException。
此方法等效于 addFirst。

pop()

从这个双端队列表示的堆栈中弹出一个元素。 换句话说，删除并返回此双端队列的第一个元素。
此方法等效于 removeFirst()。

poll()

检索并删除此双端队列表示的队列的头部（换句话说，此双端队列的第一个元素），如果此双端队列为空，则返回 null。
此方法等效于 pollFirst()。

## 二分法查找值大于或等于value的最小值索引

```
	/**
	 * 该函数在查找时总结过
	 * 
	 * @param indexIsMaxNumArr 数组
	 * @param value            目标值
	 * @param right            右端索引
	 * @return 值大于或等于value的最小值索引
	 */
	private static int biggerThanValueLeftestIndex(int[] indexIsMaxNumArr, int value,int left, int right) {
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			if (indexIsMaxNumArr[med] == value) {
				return med;
			} else if (indexIsMaxNumArr[med] > value) {
				right = med;//这里不能等于med-1，因为有可能med-1的位置就小于value的值了，只要等于med就行。普通的二分法可以这么做
			} else {
				left = med + 1;
			}
		}
		return right;
	}
```

## Long的范围

Long.MIN_VALUE;

```
public class test {
    public static void main(String[] args) {
        System.out.println(1);
        long a = 1L;
        int b =2;
        long c = b;
        System.out.println(c);
        System.out.println(a+b);
    }
}
```



 double inorder = -Double.MAX_VALUE;



# 整体思想

### [ 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)



### 旋转字符串

![image-20220107001832841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001832841.png)

- 一般思路：尝试所有的情况，看是否存在相同的
- 优化思路：见代码

```
public class Test {
    public static boolean isRoa(String s,String r){
        if (s.length()!=r.length())return false;
        String ss= s + s;
        return ss.contains(r);
    }
}

```





### zigzag方式打印矩阵

![image-20211229093821968](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229093821968.png)

- 只关注单趟循环，分离宏观控制和循环过程

- ```java
  public class Main {
  	public static void print(int[][] arr) {
  		int N = arr.length - 1;
  		int M = arr[0].length - 1;
  		int firstRow = 0, firstLine = 0, secondRow = 0, secondLine = 0;
  		boolean flag = false; // 控制打印方向
  		while (secondLine != M + 1) {
  			print(arr, firstRow, firstLine, secondRow, secondLine, flag);
  			if (firstLine != M)
  				firstLine++;
  			else
  				firstRow++;
  			if (secondRow != N)
  				secondRow++;
  			else
  				secondLine++;
  			flag = !flag;
  		}
  	}
  
  	private static void print(int[][] arr, int firstRow, int firstLine, int secondRow, int secondLine, boolean flag) {
  		if (flag) {
  			while (firstLine >= secondLine) {
  				System.out.print(arr[firstRow++][firstLine--] + " ");
  			}
  		} else {
  			while (secondLine <= firstLine) {
  				System.out.print(arr[secondRow--][secondLine++] + " ");
  			}
  		}
  	}
  }
  
  ```

  ### 

  ### 



### 90度旋转

https://leetcode-cn.com/problems/rotate-matrix-lcci/submissions/



![image-20211230000012145](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230000012145.png)

1.先水平翻转，再根据主对角线翻转得到：

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

。
```

2.原地旋转

一组四个对角转一下，借助一个临时变量就够了



```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}

```

https://pic.leetcode-cn.com/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif

![194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif)

3.暴力方法

`对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。`

![image-20211230001116999](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230001116999.png)

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] matrix_new = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
    }
}

```





# hot 100



## [1. 两数之和](https://leetcode.cn/problems/two-sum/)

哈希表

```
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> hashtable = new HashMap<Integer, Integer>();
        for (int i = 0; i < nums.length; ++i) {
            if (hashtable.containsKey(target - nums[i])) {
                return new int[]{hashtable.get(target - nums[i]), i};
            }
            hashtable.put(nums[i], i);
        }
        return new int[0];
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/two-sum/solution/liang-shu-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处


```



## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)





官方解法

```
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode head = null, tail = null;
        int carry = 0;
        while (l1 != null || l2 != null) {
            int n1 = l1 != null ? l1.val : 0;
            int n2 = l2 != null ? l2.val : 0;
            int sum = n1 + n2 + carry;
            if (head == null) {
                head = tail = new ListNode(sum % 10);
            } else {
                tail.next = new ListNode(sum % 10);
                tail = tail.next;
            }
            carry = sum / 10;
            if (l1 != null) {
                l1 = l1.next;
            }
            if (l2 != null) {
                l2 = l2.next;
            }
        }
        if (carry > 0) {
            tail.next = new ListNode(carry);
        }
        return head;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/add-two-numbers/solution/liang-shu-xiang-jia-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

我的解法，右指针移动，左指针不动

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0||s.equals(""))return 0;
        int res = 0;
        int l=0;
        int r = 0;
        HashSet set = new HashSet<Character>();
        while(r<s.length()){
            if(!set.contains(s.charAt(r))){
                set.add(s.charAt(r));
                res = Math.max(r-l+1,res);
                r++;
            }else{
                while(l<=r&&s.charAt(l)!=s.charAt(r)){
                    set.remove(s.charAt(l));
                    l++;                   
                }
                r++;
                 l++;
                
                            }

        }
return res;

    }
}
```



官方解法，固定左指针，往右移动

```
class Solution {
    public int lengthOfLongestSubstring(String s) {
        // 哈希集合，记录每个字符是否出现过
        Set<Character> occ = new HashSet<Character>();
        int n = s.length();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.remove(s.charAt(i - 1));
            }
            while (rk + 1 < n && !occ.contains(s.charAt(rk + 1))) {
                // 不断地移动右指针
                occ.add(s.charAt(rk + 1));
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = Math.max(ans, rk - i + 1);
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/longest-substring-without-repeating-characters/solution/wu-zhong-fu-zi-fu-de-zui-chang-zi-chuan-by-leetc-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)



```
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int length1 = nums1.length, length2 = nums2.length;
        int totalLength = length1 + length2;
        if (totalLength % 2 == 1) {
            double median = getKthElement(nums1, nums2, totalLength / 2 + 1);
            return median;
        } else {
            double median = (getKthElement(nums1, nums2, totalLength / 2 ) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;
            return median;
        }
    }

    public int getKthElement(int[] nums1, int[] nums2, int k) {
        /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
         * 这里的 "/" 表示整除
         * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
         * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
         * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
         * 这样 pivot 本身最大也只能是第 k-1 小的元素
         * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
         * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
         * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
         */

        int length1 = nums1.length, length2 = nums2.length;
        int index1 = 0, index2 = 0;
        int kthElement = 0;

        while (true) {
            // 边界情况
            if (index1 == length1) {
                return nums2[index2 + k - 1];
            }
            if (index2 == length2) {
                return nums1[index1 + k - 1];
            }
            if (k == 1) {
                return Math.min(nums1[index1], nums2[index2]);
            }

            // 正常情况
            int half = k / 2;
            int newIndex1 = Math.min(index1 + half, length1) - 1;
            int newIndex2 = Math.min(index2 + half, length2) - 1;
            int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
            if (pivot1 <= pivot2) {
                k -= (newIndex1 - index1 + 1);
                index1 = newIndex1 + 1;
            } else {
                k -= (newIndex2 - index2 + 1);
                index2 = newIndex2 + 1;
            }
        }
    }
}


```





## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)


### 中心扩展法

```
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() < 1) {
            return "";
        }
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
            int len = Math.max(len1, len2);
            if (len > end - start) {
                start = i - (len - 1) / 2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end + 1);
    }

    public int expandAroundCenter(String s, int left, int right) {
        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            --left;
            ++right;
        }
        return right - left - 1;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```


### 动态规划

```
class Solution {
    public String longestPalindrome(String s) {
        if (s == null || s.length() == 0) {
            return s;
        }
        int len = s.length();
        int[][] dp = new int[len][len];
        int left = 0;
        int right = 0;
        int max = 1;
        for (int i = len - 1; i >= 0; i--) {
            for (int j = i; j < len; j++) {
                if (i == j) {
                    dp[i][j] = 1;

                } else if ((i + 1 == j) && (s.charAt(i) == s.charAt(j))) {
                    dp[i][j] = 2;
                } else {
                    if (s.charAt(i) == s.charAt(j) && dp[i + 1][j - 1] > 0) {
                        dp[i][j] = dp[i + 1][j - 1] + 2;
                    }

                }
                if (max < dp[i][j]) {
                    max = dp[i][j];
                    left = i;
                    right = j;
                }
            }
        }

        return s.substring(left, right + 1);
    }
}
```

## [10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)



动态规划

```
class Solution {
    public boolean isMatch(String s, String p) {
        int m = s.length();
        int n = p.length();

        boolean[][] f = new boolean[m + 1][n + 1];
        f[0][0] = true;
        for (int i = 0; i <= m; ++i) {
            for (int j = 1; j <= n; ++j) {
                if (p.charAt(j - 1) == '*') {
                    f[i][j] = f[i][j - 2];
                    if (matches(s, p, i, j - 1)) {
                        f[i][j] = f[i][j] || f[i - 1][j];
                    }
                } else {
                    if (matches(s, p, i, j)) {
                        f[i][j] = f[i - 1][j - 1];
                    }
                }
            }
        }
        return f[m][n];
    }

    public boolean matches(String s, String p, int i, int j) {
        if (i == 0) {
            return false;
        }
        if (p.charAt(j - 1) == '.') {
            return true;
        }
        return s.charAt(i - 1) == p.charAt(j - 1);
    }
}

```



## [11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)

双指针

```
class Solution {
    public int maxArea(int[] height) {
        int l = 0 ;
        int r = height.length-1;
        int ans = 0;
        while(l<r){
            ans = Math.max(ans, Math.min(height[l], height[r])*(r-l));
            if(height[l]<=height[r]){
                l++;
            }else{
                r--;
            }
        }
    return ans;
    }
}
```



## [12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)

这个题两个要点：
		1: 只有七种基本 + 六种组合：
   ![image-20220711090853923](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220711090853923.png)



2. 尽可能选最大的数字拼凑：
   我们用来确定罗马数字的规则是：对于罗马数字从左到右的每一位，选择尽可能大的符号值。对于 140，最大可以选择的符号值为 C=100。接下来，对于剩余的数字 40，最大可以选择的符号值为XL=40。因此，140140 的对应的罗马数字为 C+XL=CXL。

   ![image-20220711091023168](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220711091023168.png)

   贪心算法。从最大向下遍历拼凑就可以

```java
class Solution {
     int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
    String[] symbols = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};
    public String intToRoman(int num) {
        StringBuffer roman = new StringBuffer();
        for(int i = 0 ; i < values.length ; i++){
            while(num>=values[i]){
                num-=values[i];
                roman.append(symbols[i]);

            }
            if (num==0) break;
        }
        return roman.toString();



    }
}
```



## [15. 三数之和](https://leetcode.cn/problems/3sum/)

双指针，固定一个数，然后剩下的部分进行双指针拼凑固定数的负数

### 比较清晰的解法

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {// 总时间复杂度：O(n^2)
        List<List<Integer>> ans = new ArrayList<>();
        if (nums == null || nums.length <= 2) return ans;

        Arrays.sort(nums); // O(nlogn)

        for (int i = 0; i < nums.length - 2; i++) { // O(n^2)
            if (nums[i] > 0) break; // 第一个数大于 0，后面的数都比它大，肯定不成立了
            if (i > 0 && nums[i] == nums[i - 1]) continue; // 去掉重复情况
            int target = -nums[i];
            int left = i + 1, right = nums.length - 1;
            while (left < right) {
                if (nums[left] + nums[right] == target) {
                    ans.add(new ArrayList<>(Arrays.asList(nums[i], nums[left], nums[right])));
                    
                    // 现在要增加 left，减小 right，但是不能重复，比如: [-2, -1, -1, -1, 3, 3, 3], i = 0, left = 1, right = 6, [-2, -1, 3] 的答案加入后，需要排除重复的 -1 和 3
                    left++; right--; // 首先无论如何先要进行加减操作
                    while (left < right && nums[left] == nums[left - 1]) left++;
                    while (left < right && nums[right] == nums[right + 1]) right--;
                } else if (nums[left] + nums[right] < target) {
                    left++;
                } else {  // nums[left] + nums[right] > target
                    right--;
                }
            }
        }
        return ans;
    }
}
```









### 官方解法

```
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        int n = nums.length;
        Arrays.sort(nums);
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    List<Integer> list = new ArrayList<Integer>();
                    list.add(nums[first]);
                    list.add(nums[second]);
                    list.add(nums[third]);
                    ans.add(list);
                }
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/3sum/solution/san-shu-zhi-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## [17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/)

深度优先搜索

```
class Solution {
    public List<String> letterCombinations(String digits) {
        List<String> combinations = new ArrayList<String>();
        if (digits.length() == 0) {
            return combinations;
        }
        Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};
        backtrack(combinations, phoneMap, digits, 0, new StringBuffer());
        return combinations;
    }

    public void backtrack(List<String> combinations, Map<Character, String> phoneMap, String digits, int index, StringBuffer combination) {
        if (index == digits.length()) {
            combinations.add(combination.toString());
        } else {
            char digit = digits.charAt(index);
            String letters = phoneMap.get(digit);
            int lettersCount = letters.length();
            for (int i = 0; i < lettersCount; i++) {
                combination.append(letters.charAt(i));
                backtrack(combinations, phoneMap, digits, index + 1, combination);
                combination.deleteCharAt(index);
            }
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/dian-hua-hao-ma-de-zi-mu-zu-he-by-leetcode-solutio/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。深度优先
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

构造一个头结点，然后双指针

```
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode first = head;
        ListNode second = dummy;
        for (int i = 0; i < n; ++i) {
            first = first.next;
        }
        while (first != null) {
            first = first.next;
            second = second.next;
        }
        second.next = second.next.next;
        ListNode ans = dummy.next;
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/remove-nth-node-from-end-of-list/solution/shan-chu-lian-biao-de-dao-shu-di-nge-jie-dian-b-61/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)

栈 



```
class Solution {
    public boolean isValid(String s) {
        int n = s.length();
        if (n % 2 == 1) {
            return false;
        }

        Map<Character, Character> pairs = new HashMap<Character, Character>() {{
            put(')', '(');
            put(']', '[');
            put('}', '{');
        }};
        Deque<Character> stack = new LinkedList<Character>();
        for (int i = 0; i < n; i++) {
            char ch = s.charAt(i);
            if (pairs.containsKey(ch)) {
                if (stack.isEmpty() || stack.peek() != pairs.get(ch)) {
                    return false;
                }
                stack.pop();
            } else {
                stack.push(ch);
            }
        }
        return stack.isEmpty();
    }
}


```





## [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)



递归

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1==null){
            return list2;
        }else if(list2==null){
            return list1;
        }else if(list1.val<=list2.val){
            list1.next=mergeTwoLists(list1.next,list2);
            return list1;

        }else{
            list2.next = mergeTwoLists(list1,list2.next);
            return list2;
        }

    }
}
```



迭代

```
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode prehead = new ListNode(-1);

        ListNode prev = prehead;
        while (l1 != null && l2 != null) {
            if (l1.val <= l2.val) {
                prev.next = l1;
                l1 = l1.next;
            } else {
                prev.next = l2;
                l2 = l2.next;
            }
            prev = prev.next;
        }

        // 合并后 l1 和 l2 最多只有一个还未被合并完，我们直接将链表末尾指向未合并完的链表即可
        prev.next = l1 == null ? l2 : l1;

        return prehead.next;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/merge-two-sorted-lists/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode-solu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)



回溯法

如果剩余左右括号都是0，则是新的组合，添加进结果集

如果剩余左右相等，则只能加左边

否则（这个时候肯定左边小于右边的，因为相等的时候只加左边），加一个左边的，然后回溯，再加一个右边的 回溯

```
class Solution {
    List<String> res = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        if(n<1){
            return res;
        }
        getParenthesis(new StringBuffer(),n,n);
        return res;

    }
    public void getParenthesis(StringBuffer sb,int left, int right){
        if(left==0&&right==0){
            res.add(new String(sb));
            return;
        }
        if(left==right){
            sb.append("(");
            getParenthesis(sb,left-1,right);
            sb.deleteCharAt(sb.length()-1);
        }else{
            if(left>0){
                sb.append("(");
            getParenthesis(sb,left-1,right);
            sb.deleteCharAt(sb.length()-1);
            }
            sb.append(")");
            getParenthesis(sb,left,right-1);
            sb.deleteCharAt(sb.length()-1);

        }
    }
}
```





参考

```
class Solution {
        List<String> res = new ArrayList<>();
        public List<String> generateParenthesis(int n) {
            if(n <= 0){
                return res;
            }
            getParenthesis("",n,n);
            return res;
        }

        private void getParenthesis(String str,int left, int right) {
            if(left == 0 && right == 0 ){
                res.add(str);
                return;
            }
            if(left == right){
                //剩余左右括号数相等，下一个只能用左括号
                getParenthesis(str+"(",left-1,right);
            }else if(left < right){
                //剩余左括号小于右括号，下一个可以用左括号也可以用右括号
                if(left > 0){
                    getParenthesis(str+"(",left-1,right);
                }
                getParenthesis(str+")",left,right-1);
            }
        }
    }
```







## [23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

### 前置知识：合并两个有序链表



```
public ListNode mergeTwoLists(ListNode a, ListNode b) {
    if (a == null || b == null) {
        return a != null ? a : b;
    }
    ListNode head = new ListNode(0);
    ListNode tail = head, aPtr = a, bPtr = b;
    while (aPtr != null && bPtr != null) {
        if (aPtr.val < bPtr.val) {
            tail.next = aPtr;
            aPtr = aPtr.next;
        } else {
            tail.next = bPtr;
            bPtr = bPtr.next;
        }
        tail = tail.next;
    }
    tail.next = (aPtr != null ? aPtr : bPtr);
    return head.next;
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 

### 分治算法

```
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        return merge(lists, 0, lists.length - 1);
    }

    public ListNode merge(ListNode[] lists, int l, int r) {
        if (l == r) {
            return lists[l];
        }
        if (l > r) {
            return null;
        }
        int mid = (l + r) >> 1;
        return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));
    }

    public ListNode mergeTwoLists(ListNode a, ListNode b) {
        if (a == null || b == null) {
            return a != null ? a : b;
        }
        ListNode head = new ListNode(0);
        ListNode tail = head, aPtr = a, bPtr = b;
        while (aPtr != null && bPtr != null) {
            if (aPtr.val < bPtr.val) {
                tail.next = aPtr;
                aPtr = aPtr.next;
            } else {
                tail.next = bPtr;
                bPtr = bPtr.next;
            }
            tail = tail.next;
        }
        tail.next = (aPtr != null ? aPtr : bPtr);
        return head.next;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### 使用优先队列合并

```
class Solution {
    class Status implements Comparable<Status> {
        int val;
        ListNode ptr;

        Status(int val, ListNode ptr) {
            this.val = val;
            this.ptr = ptr;
        }

        public int compareTo(Status status2) {
            return this.val - status2.val;
        }
    }

    PriorityQueue<Status> queue = new PriorityQueue<Status>();

    public ListNode mergeKLists(ListNode[] lists) {
        for (ListNode node: lists) {
            if (node != null) {
                queue.offer(new Status(node.val, node));
            }
        }
        ListNode head = new ListNode(0);
        ListNode tail = head;
        while (!queue.isEmpty()) {
            Status f = queue.poll();
            tail.next = f.ptr;
            tail = tail.next;
            if (f.ptr.next != null) {
                queue.offer(new Status(f.ptr.next.val, f.ptr.next));
            }
        }
        return head.next;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/merge-k-sorted-lists/solution/he-bing-kge-pai-xu-lian-biao-by-leetcode-solutio-2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)





从后往前找顺序，然后跟仅大于它的数交换，然后反转剩下的部分

```
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]) {
            i--;
        }
        if (i >= 0) {
            int j = nums.length - 1;
            while (j >= 0 && nums[i] >= nums[j]) {
                j--;
            }
            swap(nums, i, j);
        }
        reverse(nums, i + 1);
    }

    public void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void reverse(int[] nums, int start) {
        int left = start, right = nums.length - 1;
        while (left < right) {
            swap(nums, left, right);
            left++;
            right--;
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/next-permutation/solution/xia-yi-ge-pai-lie-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)


### 动态规划

状态： 以i结尾往前，最长的合法括号是多长



![image-20220714212919061](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220714212919061.png)

![image-20220714212936947](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220714212936947.png)





```java
class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int[] dp = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                //
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 贪心算法



![image-20220714215653984](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220714215653984.png)

```
class Solution {
    public int longestValidParentheses(String s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

```
class Solution {
    public int search(int[] nums, int target) {
        int n = nums.length;
        if(n == 0){
            return -1;
        }
        if(n==1){
            return nums[0]==target?0:-1;
        }
        int l=0,r = n-1;

        while(l<=r){
            int mid = (l+r)>>1;
            if(target==nums[mid]){
                return mid;
            }
            if(nums[0]<=nums[mid]){//左半边有序,看在不在这个区间，不在就在另一个区间
            //注意这里的target>=nums[0]
                if(target>=nums[0]&&target<nums[mid]){
                    r=mid-1;
                }else{
                    l=mid+1;
                }

            }else{//右半边有序,看在不在这个区间，不在就在另一个区间
            //注意这里的target<=nums[n-1] 小于等于号
                  if(target>nums[mid]&&target<=nums[n-1]){
                    l=mid+1;
                }else{
                    r=mid-1;
                }   
            }
        }
        return -1;

    }
}
```

## [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

### 二分法寻找大于或者大于等于target的位置

![image-20220718095834280](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220718095834280.png)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = binarySearch(nums, target, true);
        int right = binarySearch(nums,target,false)-1;
        if(left<=right&&nums[left]==target&&nums[right]==target){
            return new int[]{left,right};
        }
        return new int[]{-1,-1};

    }
     public int binarySearch(int[] nums, int target, boolean lower) {
         int left = 0,right = nums.length-1;
         int ans =  nums.length;//[1]的时候这个条件就起作用了
         
         while(left<=right){
             int mid = (left+right)>>1;
             //如果是找大于target就是nums[mid]>target，找大于等于target就是nums[mid]>=target，在num[mid]=target的时候不一样，一个是走左边，一个是走右半边
             if(nums[mid]>target||(lower&&nums[mid]>=target)){
                 ans=mid;//每一步将min的值作为ans，因为我们找的是大于(或大于等于)target的值
                  right = mid-1;
             }else{
                  left=mid+1;
             }
         }
         return ans;

     }
}
```



## [39. 组合总和](https://leetcode.cn/problems/combination-sum/)

深度优先搜索

```
class Solution {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        Arrays.sort(candidates);
        List<Integer> combina = new ArrayList<>();
        dfs(candidates,ans,combina,target,0);

        return ans;
    }
    public void dfs(int[] candidates, List<List<Integer>> ans,List<Integer> combina,int target,int idx){
        if(idx==candidates.length){
            return;
        }
        if(target==0){
            ans.add(new ArrayList<>(combina));
            return;
        }
        if(target>=candidates[idx]){
            combina.add(candidates[idx]);
            dfs(candidates,ans,combina,target-candidates[idx],idx);
            combina.remove(combina.size()-1);
        }
       dfs(candidates,ans,combina,target,idx+1);

    }
}
```



## [42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)

### 动态规划-推荐

创建两个长度为 nn 的数组 leftMax 和 rightMax。对于 0≤i<n，leftMax[i] 表示下标 i及其左边的位置中，height 的最大高度，rightMax[i] 表示下标 i 及其右边的位置中，height 的最大高度。



```
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 方法二：单调栈

看官方题解吧

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        Deque<Integer> stack = new LinkedList<Integer>();
        int n = height.length;
        for (int i = 0; i < n; ++i) {
            while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
                int top = stack.pop();
                if (stack.isEmpty()) {
                    break;
                }
                int left = stack.peek();
                int currWidth = i - left - 1;
                int currHeight = Math.min(height[left], height[i]) - height[top];
                ans += currWidth * currHeight;
            }
            stack.push(i);
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





### 双指针

动态规划的节省空间版

![image-20220719100415526](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220719100415526.png)

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [46. 全排列](https://leetcode.cn/problems/permutations/)



```
class Solution {
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();

        List<Integer> output = new ArrayList<Integer>();
        for (int num : nums) {
            output.add(num);
        }

        int n = nums.length;
        backtrack(n, output, res, 0);
        return res;
    }

    public void backtrack(int n, List<Integer> output, List<List<Integer>> res, int first) {
        // 所有数都填完了
        if (first == n) {
            res.add(new ArrayList<Integer>(output));
        }
        for (int i = first; i < n; i++) {
            // 动态维护数组
            Collections.swap(output, first, i);
            // 继续递归填下一个数
            backtrack(n, output, res, first + 1);
            // 撤销操作
            Collections.swap(output, first, i);
        }
    }
}
```



## [48. 旋转图像](https://leetcode.cn/problems/rotate-image/)

原地旋转

![image-20220719213525233](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220719213525233.png)





![image-20220719213543091](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220719213543091.png)



```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/rotate-image/solution/xuan-zhuan-tu-xiang-by-leetcode-solution-vu3m/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

排序+hash



```
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        Map<String, List<String>> map =new HashMap<String, List<String>>();
        
        for(String s: strs){
            char[] chars = s.toCharArray();
            Arrays.sort(chars);
            String key = new String(chars);
            List<String> list = map.getOrDefault(key, new ArrayList<String>());
            list.add(s);
            map.put(key,list);
        }
        return new ArrayList<List<String>>(map.values());

    }
}
```



## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

### 简单的dp

```
class Solution {
    public int maxSubArray(int[] nums) {
        int pre = 0, maxAns = nums[0];
        for (int x : nums) {
            pre = Math.max(pre + x, x);
            maxAns = Math.max(maxAns, pre);
        }
        return maxAns;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



### 线段树



![image-20220722092439298](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722092439298.png)

![image-20220722092450325](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722092450325.png)

```
class Solution {
    public class Status {
        public int lSum, rSum, mSum, iSum;

        public Status(int lSum, int rSum, int mSum, int iSum) {
            this.lSum = lSum;
            this.rSum = rSum;
            this.mSum = mSum;
            this.iSum = iSum;
        }
    }

    public int maxSubArray(int[] nums) {
        return getInfo(nums, 0, nums.length - 1).mSum;
    }

    public Status getInfo(int[] a, int l, int r) {
        if (l == r) {
            return new Status(a[l], a[l], a[l], a[l]);
        }
        int m = (l + r) >> 1;
        Status lSub = getInfo(a, l, m);
        Status rSub = getInfo(a, m + 1, r);
        return pushUp(lSub, rSub);
    }

    public Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        int lSum = Math.max(l.lSum, l.iSum + r.lSum);
        int rSum = Math.max(r.rSum, r.iSum + l.rSum);
        int mSum = Math.max(Math.max(l.mSum, r.mSum), l.rSum + r.lSum);
        return new Status(lSum, rSum, mSum, iSum);
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/maximum-subarray/solution/zui-da-zi-xu-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)

贪心

```
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/jump-game/solution/tiao-yue-you-xi-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [56. 合并区间](https://leetcode.cn/problems/merge-intervals/)

自定义比较器，然后挨个合并

```
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[0] - interval2[0];
            }
        });
        List<int[]> merged = new ArrayList<int[]>();
        for (int i = 0; i < intervals.length; ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {
                merged.add(new int[]{L, R});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/merge-intervals/solution/he-bing-qu-jian-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

## [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

### 动态规划

```
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] f = new int[m][n];
        for (int i = 0; i < m; ++i) {
            f[i][0] = 1;
        }
        for (int j = 0; j < n; ++j) {
            f[0][j] = 1;
        }
        for (int i = 1; i < m; ++i) {
            for (int j = 1; j < n; ++j) {
                f[i][j] = f[i - 1][j] + f[i][j - 1];
            }
        }
        return f[m - 1][n - 1];
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 数学公式

![image-20220722093829888](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722093829888.png)





```
class Solution {
    public int uniquePaths(int m, int n) {
        long ans = 1;
        for (int x = n, y = 1; y < m; ++x, ++y) {
            ans = ans * x / y;
        }
        return (int) ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/unique-paths/solution/bu-tong-lu-jing-by-leetcode-solution-hzjf/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

\





```
class Solution {
    public int minPathSum(int[][] grid) {
        if( grid==null||grid.length==0){
            return 0;
        }
        int m = grid.length;
        int n = grid[0].length;
        int[]dp =new int[n];
        dp[0]=grid[0][0];
        for(int i  = 1;i<n;i++){
            dp[i]=dp[i-1]+grid[0][i];
        }
        for(int i = 1 ; i<m;i++){
            for(int j = 0;j<n;j++){
                if(j>0){
                    dp[j]=Math.min(dp[j-1]+grid[i][j],dp[j]+grid[i][j]);
                }else{
                    dp[j]=dp[j]+grid[i][j];
                }
            }
        }
        return dp[n-1];


    }
}
```



## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)



```
class Solution {
    public int climbStairs(int n) {
        int p = 0, q = 0, r = 1;
        for (int i = 1; i <= n; ++i) {
            p = q; 
            q = r; 
            r = p + q;
        }
        return r;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/climbing-stairs/solution/pa-lou-ti-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

![image-20220722095329588](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722095329588.png)

![image-20220722095358689](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722095358689.png)

![image-20220722095425807](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722095425807.png)

![image-20220722095440641](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722095440641.png)

![image-20220722095459232](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220722095459232.png)

动态规划

```
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length();
        int m = word2.length();

        // 有一个字符串为空串
        if (n * m == 0) {
            return n + m;
        }

        // DP 数组
        int[][] D = new int[n + 1][m + 1];

        // 边界状态初始化
        for (int i = 0; i < n + 1; i++) {
            D[i][0] = i;
        }
        for (int j = 0; j < m + 1; j++) {
            D[0][j] = j;
        }

        // 计算所有 DP 值
        for (int i = 1; i < n + 1; i++) {
            for (int j = 1; j < m + 1; j++) {
                int left = D[i - 1][j] + 1;
                int down = D[i][j - 1] + 1;
                int left_down = D[i - 1][j - 1];
                if (word1.charAt(i - 1) != word2.charAt(j - 1)) {
                    left_down += 1;
                }
                D[i][j] = Math.min(left, Math.min(down, left_down));
            }
        }
        return D[n][m];
    }
}

```

## [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)





![image-20220727092908447](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220727092908447.png)





```
class Solution {
    public void sortColors(int[] nums) {
        int n = nums.length;
        int p0 = 0, p2 = n - 1;
        for (int i = 0; i <= p2; ++i) {
            while (i <= p2 && nums[i] == 2) {
                int temp = nums[i];
                nums[i] = nums[p2];
                nums[p2] = temp;
                --p2;
            }
            if (nums[i] == 0) {
                int temp = nums[i];
                nums[i] = nums[p0];
                nums[p0] = temp;
                ++p0;
            }
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/sort-colors/solution/yan-se-fen-lei-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)



两个hashmap。l和r两个指针

```
class Solution {
    Map<Character, Integer> ori = new HashMap<Character, Integer>();
    Map<Character, Integer> cnt = new HashMap<Character, Integer>();

    public String minWindow(String s, String t) {
        int tLen = t.length();
        for (int i = 0; i < tLen; i++) {
            char c = t.charAt(i);
            ori.put(c, ori.getOrDefault(c, 0) + 1);
        }
        int l = 0, r = -1;
        int len = Integer.MAX_VALUE, ansL = -1, ansR = -1;
        int sLen = s.length();
        while (r < sLen) {
            ++r;
            if (r < sLen && ori.containsKey(s.charAt(r))) {
                cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
                            while (check() && l <= r) {
                if (r - l + 1 < len) {
                    len = r - l + 1;
                    ansL = l;
                    ansR = l + len;
                }
                if (ori.containsKey(s.charAt(l))) {
                    cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                }
                ++l;
            }
            }

        }
        return ansL == -1 ? "" : s.substring(ansL, ansR);
    }

    public boolean check() {
        Iterator iter = ori.entrySet().iterator(); 
        while (iter.hasNext()) { 
            Map.Entry entry = (Map.Entry) iter.next(); 
            Character key = (Character) entry.getKey(); 
            Integer val = (Integer) entry.getValue(); 
            if (cnt.getOrDefault(key, 0) < val) {
                return false;
            }
        } 
        return true;
    }
}

```



用数组达到同样的效果



```
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || s == "" || t == null || t == "" || s.length() < t.length()) {
            return "";
        }
        //维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数
        //ASCII表总长128
        int[] need = new int[128];
        int[] have = new int[128];

        //将目标字符串指定字符的出现次数记录
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++;
        }

        //分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)
        //已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置
        int left = 0, right = 0, min = s.length() + 1, count = 0, start = 0;
        while (right < s.length()) {
            char r = s.charAt(right);
            //说明该字符不被目标字符串需要，此时有两种情况
            // 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断
            // 2.循环已经开始一段时间，此处又有两种情况
            //  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时
            //      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可
            //  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针
            if (need[r] == 0) {
                right++;
                continue;
            }
            //当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1
            //是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数
            if (have[r] < need[r]) {
                count++;
            }
            //已有字符串中目标字符出现的次数+1
            have[r]++;
            //移动右指针
            right++;
            //当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次
            while (count == t.length()) {
                //挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置
                if (right - left < min) {
                    min = right - left;
                    start = left;
                }
                char l = s.charAt(left);
                //如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针
                if (need[l] == 0) {
                    left++;
                    continue;
                }
                //如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，
                //就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1
                if (have[l] == need[l]) {
                    count--;
                }
                //已有字符串中目标字符出现的次数-1
                have[l]--;
                //移动左指针
                left++;
            }
        }
        //如果最小长度还为初始值，说明没有符合条件的子串
        if (min == s.length() + 1) {
            return "";
        }
        //返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串
        return s.substring(start, start + min);
    }
}
```



## [78. 子集](https://leetcode.cn/problems/subsets/)

### 位运算

![image-20220727094848733](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220727094848733.png)

````java
class Solution {
    public List<List<Integer>> subsets(int[] nums) {
        // 位运算
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        List<Integer> t = new ArrayList<>();
        int len = nums.length;
        for(int i = 0; i<(1<<len);i++){
            t.clear();
            for(int j = 0 ; j <len;j++){
                if((i&(1<<j))!=0){
                    t.add(nums[j]);
                }
            }
            res.add(new ArrayList<Integer>(t));
        }
        return res;


    }
}
````



### dfs

```
class Solution {
    List<Integer> t = new ArrayList<Integer>();
    List<List<Integer>> ans = new ArrayList<List<Integer>>();

    public List<List<Integer>> subsets(int[] nums) {
        int n = nums.length;
        for (int mask = 0; mask < (1 << n); ++mask) {
            t.clear();
            for (int i = 0; i < n; ++i) {
                if ((mask & (1 << i)) != 0) {
                    t.add(nums[i]);
                }
            }
            ans.add(new ArrayList<Integer>(t));
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/subsets/solution/zi-ji-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [79. 单词搜索](https://leetcode.cn/problems/word-search/)

dfs 加状态，防止重复遍历



```
class Solution {

    public boolean exist(char[][] board, String word) {
        int r = board.length;
        int l = board[0].length;
        boolean[][] status  = new boolean[r][l];
        for(int i = 0; i < r;i++){
            for(int j = 0 ; j < l ; j++){
                if(dfs(board,word,status,i,j,0,r,l)){
                    return true;
                }
            }
        }
        return false;
    }
    public boolean dfs(char[][] board, String word,boolean[][] status ,int i,int j,int cur, int r,int l){
        if(cur>=word.length()){
            return true;
        }
        if(i>=r||j>=l||i<0||j<0||status[i][j]){
            return false;
        }
        if(board[i][j]==word.charAt(cur)){
            status[i][j]=true;
            if(dfs(board,word,status,i+1,j,cur+1,r,l)||dfs(board,word,status,i,j+1,cur+1,r,l)||dfs(board,word,status,i,j-1,cur+1,r,l)||dfs(board,word,status,i-1,j,cur+1,r,l)){
                return true;
            }
             status[i][j]=false;
        }
 
        return false;
    }
}
```



## [84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)

维护两个单调栈，一个是从左往右递增，一个是从右往左遍历，递减，目的都是为了找到当前遍历柱子左右两边第一个比他高度矮的，这样可以计算以他的高度为结果的宽。

![image-20220727100104777](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220727100104777.png)

![image-20220727100320418](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220727100320418.png)

![image-20220727100337689](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220727100337689.png)

```
class Solution {
    public int largestRectangleArea(int[] heights) {
        int n = heights.length;
        int[] left = new int[n];
        int[] right = new int[n];
        
        Deque<Integer> mono_stack = new ArrayDeque<Integer>();
        for (int i = 0; i < n; ++i) {
            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
                mono_stack.pop();
            }
            left[i] = (mono_stack.isEmpty() ? -1 : mono_stack.peek());
            mono_stack.push(i);
        }

        mono_stack.clear();
        for (int i = n - 1; i >= 0; --i) {
            while (!mono_stack.isEmpty() && heights[mono_stack.peek()] >= heights[i]) {
                mono_stack.pop();
            }
            right[i] = (mono_stack.isEmpty() ? n : mono_stack.peek());
            mono_stack.push(i);
        }
        
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans = Math.max(ans, (right[i] - left[i] - 1) * heights[i]);
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## [85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)

跟上个题一样，把每一行的到左边连续1的长度当成高，来进行单调栈判断矩形面积。



```
import java.util.ArrayDeque;
import java.util.Deque;

class Solution {
    public int maximalRectangle(char[][] matrix) {
        int row = matrix.length;
        if (row == 0) {
            return 0;
        }
        int col = matrix[0].length;
        int[][] left = new int[row][col];
        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
                }

            }
        }

        for (int i = 0; i < row; i++) {
            for (int j = 0; j < col; j++) {
                if (matrix[i][j] == '1') {
                    left[i][j] = (j == 0 ? 0 : left[i][j - 1]) + 1;
                }
            }
        }


        int res = 0;
        Deque<Integer> queue = new ArrayDeque<Integer>();

        for (int j = 0; j < col; j++) {
            int[] low = new int[row];
            int[] up = new int[row];
            for (int i = 0; i < row; i++) {
                while (!queue.isEmpty() && left[queue.peek()][j] >= left[i][j]) {
                    queue.pop();
                }
                low[i] = queue.isEmpty() ? -1 : queue.peek();
                queue.push(i);
            }
            queue.clear();
            for (int i = row - 1; i >= 0; i--) {
                while (!queue.isEmpty() && left[queue.peek()][j] >= left[i][j]) {
                    queue.pop();
                }
                up[i] = queue.isEmpty() ? row : queue.peek();
                queue.push(i);
            }
            queue.clear();
            for (int i = 0; i < row; i++) {
                res = Math.max(res, left[i][j] * (up[i] - low[i] - 1));
            }
        }
        return res;

    }
}

```



## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)



### 递归

```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> list = new ArrayList<>();
    public List<Integer> inorderTraversal(TreeNode root) {
        if(root==null){
            return list;
        }
        inorderTraversal(root.left);
        list.add(root.val);
        inorderTraversal(root.right);
        return list;

    }
}
```



### 迭代



```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<>();
        Deque<TreeNode> stack = new ArrayDeque<>();
        while(root!=null||!stack.isEmpty()){
            while(root!=null){
                stack.push(root);
                root=root.left;
            }
            root=stack.pop();
            list.add(root.val);
            root=root.right;
        }
        return list;
    }
}
```





## [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/) 



### 我自己写的递归调用

```
class Solution {
    public int numTrees(int n) {
        if(n==0){
            return 1;
        }
        if(n==1){
            return 1;
        }
        if(n == 2){
            return 2;
        }
        int res = 0;
        for(int i = 0;i<=n-1;i++){

               res+=numTrees(i)*numTrees(n-1-i);
           
        }
        return res;

    }
}
```



### 动态规划

上一个的优化

![image-20220801100619538](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220801100619538.png)

```
class Solution {
    public int numTrees(int n) {
        int[] G = new int[n + 1];
        G[0] = 1;
        G[1] = 1;

        for (int i = 2; i <= n; ++i) {
            for (int j = 1; j <= i; ++j) {
                G[i] += G[j - 1] * G[i - j];
            }
        }
        return G[n];
    }
}

作者：LeetCode-Solution
链接：https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```









##

##

##

##

##

##

##

##





## [128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

### hashmap

```
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums.length<2) return nums.length;
        HashSet<Integer> set = new HashSet<>();
        int res = 1;
        for(int num: nums){
            set.add(num);
        }
        for(int num:nums){
            if(set.contains(num-1)){
                continue;
            }
            int temnum = num;
            int temres = 1;
            while(set.contains(temnum+1)){
                temnum+=1;
                temres++;
            }
            res = Math.max(temres, res);
        }
        return res;

    }
}
```

### 解题思路4：并查集

并查集的思路实际上与思路2有点像，也是来记录右边界的，所有在一个连续区间内的元素都会在一个连通分量中，且这些元素的根结点都为最远的右边界元素。
具体思路是：

遍历所有元素num，如果num+1存在，将num加入到num+1所在的连通分量中；
重新遍历一遍所有元素num，通过find函数找到num所在分量的根结点，也就是最远右边界，从而求得连续区间的长度。

作者：yimeixiaobai
链接：https://leetcode.cn/problems/longest-consecutive-sequence/solution/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



```java
class UnionFind {
    // 记录每个节点的父节点
    private Map<Integer, Integer> parent;

    public UnionFind(int[] nums) {
        parent = new HashMap<>();
        // 初始化父节点为自身
        for (int num : nums) {
            parent.put(num, num);
        }
    }

    // 寻找x的父节点，实际上也就是x的最远连续右边界，这点类似于方法2
    public Integer find(int x) {
        // nums不包含x
        if (!parent.containsKey(x)) {
            return null;
        }
        // 遍历找到x的父节点
        while (x != parent.get(x)) {
            // 进行路径压缩，不写下面这行也可以，但是时间会慢些
            parent.put(x, parent.get(parent.get(x)));
            x = parent.get(x);
        }
        return x;
    }

    // 合并两个连通分量，在本题中只用来将num并入到num+1的连续区间中
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        if (rootX == rootY) {
            return;
        }
        parent.put(rootX, rootY);
    }
}

class Solution {
    public int longestConsecutive(int[] nums) {
        UnionFind uf = new UnionFind(nums);
        int ans = 0;
        
        for (int num : nums) {
            // 当num+1存在，将num合并到num+1所在集合中
            if (uf.find(num + 1) != null) {
                uf.union(num, num + 1);
            }
        }

        for (int num : nums) {
            // 找到num的最远连续右边界
            int right = uf.find(num);
            ans = Math.max(ans, right - num + 1);
        }
        return ans;
    }
}

作者：yimeixiaobai
链接：https://leetcode.cn/problems/longest-consecutive-sequence/solution/xiao-bai-lang-ha-xi-ji-he-ha-xi-biao-don-j5a2/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623



# git time out 问题

取消代理

```

取消代理
git config --global --unset http.proxy
git config --global --unset https.proxy
git config --global http.sslVerify "false"
```

 OpenSSL SSL_read: Connection was reset, errno 10054



ipconfig /flushdns cmd中执行一下再试试

执行完再打开git就好了





# 双端队列

```
 public static void main(String[] args) {
        Deque<Integer> stack = new ArrayDeque<>();
        stack.push(1);
        stack.push(2);
        stack.push(3);
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println(stack.pop());
        System.out.println("++++++++++++++++++++++++++++++++++++++++++++");
        stack = new ArrayDeque<>();
        stack.offer(1);
        stack.offer(2);
        stack.offer(3);
        System.out.println(stack.poll());
        System.out.println(stack.poll());
        System.out.println(stack.poll());


    }
    
    
3
2
1
++++++++++++++++++++++++++++++++++++++++++++
1
2
3    
```

