![image-20220121094438997](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121094438997.png)









# 数学计算

## 数组相邻积能被4整除

![image-20220109181842536](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109181842536.png)

![image-20220109182228294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109182228294.png)

## 只有两个键的键盘


![image-20220107000747053](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000747053.png)

https://leetcode-cn.com/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/

两个题目有点像。
如果n是个质数，那么操作数只能是n-1次，也就相当于操作第二步。不然的话，无法凑成n（质数：只有1和自己的因数的的数。）
如果b不是个质数，则把n分解成`x*Y*z*...`等几个质数的乘积，需要的最少操作数就是子质数之和减去质数的个数。
因此可以用动态规划做。
初试条件s已经有了a了，因此dp的边界条件dp[1] = 0.
![image](https://user-images.githubusercontent.com/43565774/147913317-7f29fccd-8cf6-4214-8447-c75ad5465732.png)

![image](https://user-images.githubusercontent.com/43565774/147913626-a29d5f15-e26a-4bc1-bbf9-0185afa2b3e6.png)

```
class Solution {
    public int minSteps(int n) {
        int[] dp=new int[n+1];
        for(int i = 2;i<=n;i++){
            dp[i] = Integer.MAX_VALUE;
            for(int j = 1;j*j<=i;j++){
                if(i%j==0){
                    // 下面两个顺序不能换
                    dp[i]=Math.min(dp[i],dp[j]+i/j);
                dp[i]=Math.min(dp[i],dp[i/j]+j);
                 
            }
            }
        }
        return dp[n];
    }
}


##  判断是不是质数素数
```
public boolean isPrime(int n)

{undefined

if(n < 2) return false;

for(int i = 2; i < n; ++i)

if(n%i == 0) return false;

return true;

}
```


## 自定义比较器
https://blog.csdn.net/whing123/article/details/77851737

 Comparator

```

class Teacher{  
    int num;  
    double salary;  

    public Teacher(int num, double salary) {  
        this.num = num;  
        this.salary = salary;  
    }  
    
    @Override  
    public String toString() {  
        return "\r\tnum:"+num+" salary:"+salary+"\r";  
    }      
}  

class StudentComparator implements Comparator{  

    public int compare(Object o1, Object o2) {  
        Teacher t1 = (Teacher) o1;  
        Teacher t2 = (Teacher) o2;  
        int result = t1.num > t2.num ? 1 : (t1.num == t2.num ? 0 : -1);  
        return result = result == 0 ?(t1.salary<t2.salary ? 1 : -1) : result;  
    }   
}  


```
Comparable

```
import java.util.ArrayList;  
import java.util.Collections;  
import java.util.Comparator;  
import java.util.List;  

public class CompareTest {  
    public static void main(String[] args) {  
        List<Student> list = new ArrayList<Student>(10);  
        list.add(new Student(1,"jj"));  
        list.add(new Student(0,"ww"));  
        list.add(new Student(0,"kk"));  
        list.add(new Student(2,"ll"));  
        Collections.sort(list); // 内部比较器:要排序的类实现Comparable接口,可以对自身进行比较  
        System.out.println(list);  

        List<Teacher> t = new ArrayList<Teacher>(10);  
        t.add(new Teacher(1,12));  
        t.add(new Teacher(0,13));  
        t.add(new Teacher(0,14));  
        t.add(new Teacher(2,15));  
        Collections.sort(t,new StudentComparator()); //外部比较器:通过额外的类来实现Comparator接口  
        System.out.println(t);  
    }  
}  
	
	
	

```
	
```
	class Student implements Comparable {  
	int num;  
	String name;  
	
	public Student(int num, String name) {  
	    this.num = num;  
	    this.name = name;  
	}  
	
	@Override  
	public String toString() {  
	    return "\r\tnum:"+num+" name:"+name+"\r";  
	}  
	
	public int compareTo(Object o) {  
	    Student tmp = (Student) o;  
	    int result = tmp.num > num ? 1 : (tmp.num==num ? 0 : -1);  
	    if (result == 0) {  
	        result = tmp.name.indexOf(0) > name.indexOf(0) ? 1 : -1;  
	    }  
	    return result;  
	}  
}  
	
	```

# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位

 ![image](https://user-images.githubusercontent.com/43565774/144262216-121ffafc-12ef-4094-a838-e9ef2f034ba4.png)

![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整



## 一致性哈希









# 并查集

融合

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8CF8D66817018FBB3E968AB8FACBB42B.jpg)

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C15EF7866196C79D418DCECBC4D33358.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/69490C61145109D46C98A19C56B204BD.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0DAF1C2D9659D76ED8EE873A64431511.jpg)

风 23:46:16
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/AC53BA985C9A6E9E5B79F90A72375321.jpg)

## 岛屿数量



多cpu情况



![image-20211202232412841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202232412841.png)





# kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)





## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

## 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





# 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算





## 接雨水



### 1.单调栈

```
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 双指针

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
        // 先更新指针的值，再进行计算雨水，再移动指针较小的端的指针。
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











### 最大分段最大值的差

![image-20220107000935422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000935422.png)



找到最大值，然后减去两头的值，哪个小减去哪个。因为两段以后必然包含端点的值。
![image-20220107001615368](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001615368.png)







# 树形dp





风 9:11:52
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8137EC9804C17A0400E254509CD5AD74.jpg)

风 9:11:53
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/759C819ADFCB16E2CA56D2AEED307D6A.jpg)

## 树节点最远距离

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3D9B73ED255C5D81E3CC844F11CB856B.jpg)

风 9:11:55
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C361F70153593EABDE8588C7F7D23CF3.jpg)

风 9:11:56
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/325332F68C65A9A217E9F07DE2527361.jpg)



![image-20211209092409856](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211209092409856.png)



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D95FBD3D6DD4FF2CBDAA5A9011CCC7E.jpg)



***递归套路：***

- 根据子树最大深度计算出经过当前节点的最长距离
- 向上传递子树和经过当前节点最长距离 的最大值
- 最长距离需要子树深度
- 所以递归数据包括最大距离和最大深度





```java

public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}



```



## 树节点最远距离（套路题）

![image-20211228222749514](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228222749514.png)

递归套路：

根据子树最大深度计算出经过当前节点的最长距离
向上传递子树和经过当前节点最长距离 的最大值
最长距离需要子树深度
所以递归数据包括最大距离和最大深度

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```
}





## 员工的快乐值



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/513BBF7364AF9B669F89CB5E33521B1C.jpg)


![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/36AEC04043D12E4DD4B9DD9B070B6BE8.jpg)

***递归套路：***

- 最大值和每个节点是否去有关，就是取 **当前节点不去（0）+子节点去或不去的最大值** 和 **当前节点去（happy）+子节点不去的最大值**
- 每个节点的去和不去都会直接影响父类节点，间接影响祖宗节点。
- 只要递归传递该节点去和不去的最大值信息即可。

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxHappy(header);
		return Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
	}

	private static TransformData maxHappy(Node header) {
		if (header.nexts == null) {
			return new TransformData(0, header.happyNum);
		}
		int dontWent = 0;
		int went = 0;
		for (Node nextNode : header.nexts) {
			TransformData data = maxHappy(nextNode);
			went += data.thisNodeDontWentSumHappy;
			dontWent += Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
		}
		return new TransformData(dontWent, went);
	}

	public static class TransformData {
		int thisNodeDontWentSumHappy;
		int thisNodeWentSumHappy;
		public TransformData(int thisNodeDontWentSumHappy, int thisNodeWentSumHappy) {
			this.thisNodeDontWentSumHappy = thisNodeDontWentSumHappy;
			this.thisNodeWentSumHappy = thisNodeWentSumHappy;
		}

	}

	public static class Node {
		int happyNum;
		Node[] nexts;
	}
}

```



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/052E9D9096F34CEC4809DB9CA1D60FD0.jpg)

风 9:12:03
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/116215E06216BC9B2D6E0E6BE249E6C7.jpg)



## 树结构转成链表（套路题）

![]()

- 将左右子树构建好的结果通过本节点链接，就是递归对数据就是链接起始和结束节点。



```java
public class Main {
    public static Data process(Node x) {
        if (x == null) {
            return new Data(null, null);
        }
        // 将x作为中间节点，x.leftNode为创建x的前面的链表，x.rightNode为创建后面的链表。
        Data leftData = process(x.leftNode);
        Data rightData = process(x.rightNode);
        // 前后创建的链表和中间节点x链接，因为是双向链表，所以要有四句链接
        if (leftData.end != null) {
            leftData.end.rightNode = x;
        }
        x.leftNode = leftData.end;
        if (rightData.start != null) {
            rightData.start.leftNode = x;
        }
        x.rightNode = rightData.start;
        // 创建好后重新分装返回起始节点和尾节点
        return new Data(leftData.start != null ? leftData.start : x,
                rightData.end != null ? rightData.end : x);
    }

    static class Data {
        Node start;
        Node end;
        public Data(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 子搜索二叉树的节点个数（套路题）



![image-20220113001019144](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220113001019144.png)







## 二叉树的个数

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/adea57019f814883a17071344d4f5f96.png)

```java
public class Main {
	public static int process(int N) {
		if (N == 0 || N == 1) {
			return 1;
		}
		int res = 0;
		for (int i = 0; i < N; i++) {
			res += process(i) * process(N - i - 1);
		}
		return res;
	}
}

```

![image-20211227231055343](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227231055343.png)



```java
public static int num(int n) {
    if (n < 2) {
        return 1;
    }
    int[] dp = new int (n + 1);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];

}
```















## 判断是搜索二叉树（套路题）

**中序遍历实现**

中序遍历是有小到大的

```
public class Main {
	public static int lastNum=Integer.MIN_VALUE;
	public static boolean isBST(Node header) {
		if (header.leftNode!=null) {
			if (!isBST(header.leftNode)) {
				return false;
			}
		}
		if (lastNum>header.value) {
			return false;
		}
		lastNum=header.value;
		if (header.rightNode!=null) {
			if (!isBST(header.rightNode)) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

**递归套路实现**

![image-20220117092658302](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092658302.png)



```
public class Main {
	public static TransformData isBST(Node header) {
		if (header == null) {
			return new TransformData(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = isBST(header.leftNode);
		TransformData rightData = isBST(header.rightNode);
		boolean flag = leftData.max < header.value && rightData.min > header.value;
		return new TransformData(flag, Math.max(rightData.max, header.value), Math.min(leftData.min, header.value));
	}

	private static class TransformData {
		boolean sucess;
		int max;
		int min;
		public TransformData(boolean sucess, int max, int min) {
			this.sucess = sucess;
			this.max = max;
			this.min = min;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 子搜索二叉树的节点个数（套路题）

![image-20220117092722704](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092722704.png) 





![image-20220117093905556](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117093905556.png)

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
	//basecase 如果是空节点，也希望传递个上层节点已有能将递归进行下去，所以给最大值和最小值。 	
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		//递归左右子节点获取信息
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		//判断加上目前节点是不是构成一颗二叉搜索树，该节点的值应该大于左子树最大值，小于右子树最小值
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {
			//可能性1，该节点与左右子树构成一颗新的二叉搜索树，左右都得是二叉搜索树
			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
        // 可能性2 ，该节点与左右子树构不成二叉搜索树，就给maxValue赋值最小，minValue赋值最大，保证上层节点无法构成二叉搜索树。然后比较左右子树哪个节点多就返回哪个
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;//以该节点为根节点的子树是不是二叉搜索树
		int childMaxBSTNodeNum;//不管是或者不是，这颗子树拥有的最大的搜索二叉树的节点个数
		int maxValue;// 构成搜索二叉树的最大的值
		int minValue;//构成搜索二叉树最小的值
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```









## 前中序推后序遍历

![image-20220117235316030](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235316030.png)

- 关注在前中后序遍历之间的元素相对位置关系。
- ![image-20220117235951620](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235951620.png)

```java
public class Test {
    public static void main(String[] args) {
        int[] post = genPost(new int[]{1, 2, 4, 5, 3, 6, 7}, new int[]{4, 2, 5, 1, 6, 3, 7});
        System.out.println(Arrays.toString(post));
    }

    public static int[] genPost(int[] pre, int[] in) {
        int[] post = new int[pre.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        genPost(pre, 0, pre.length - 1, in, 0, in.length - 1, post, 0, post.length - 1, map);
        return post;
    }

    private static void genPost(int[] pre, int preStart, int preEnd,
                                int[] in, int medStart, int medEnd,
                                int[] post, int postStart, int postEnd,
                                HashMap<Integer, Integer> map) {
        if (preStart > preEnd) {
            return;
        }
        if (postStart == postEnd) {
            post[postStart] = pre[preStart];
            return;
        }
        //每一轮的前序第一个元素就是后序最后一个元素，在后续的genPost中不能再包含其他元素
        post[postEnd] = pre[preStart];

        //此时寻找pre[preStart]在med中的索引indexStart，那么最后的 indexStart - medStart 就是中间元素个数
        int indexStart = map.get(pre[preStart]);
        
        //以pre中preStart位置的元素为左右分割点,根据 indexStart 确定pre,in,post中的数据范围
        genPost(pre, preStart + 1, preStart + indexStart - medStart,
                in, medStart, indexStart - 1,
                post, postStart, postStart + indexStart - medStart - 1,
                map);
        genPost(pre, preStart + indexStart - medStart + 1, preEnd,
                in, indexStart + 1, medEnd,
                post, postStart + indexStart - medStart, postEnd - 1,
                map);
    }
}

```



## 求完全二叉树的节点的个数

​	

![image-20220118092613612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092613612.png)

![image-20220118093215169](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093215169.png)

求完全二叉树的深度的方法。

![image-20220118092804821](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092804821.png)



![image-20220118093156008](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093156008.png)

![image-20220118093510245](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093510245.png)

看右子树的深度是不是与当前最深度相等，是的，那左子树肯定是满二叉树，如果不是的话，那这个右子树肯定是满二叉树。确定了满二叉树的个数，就可以递归计算另外一个不是满二叉树的子二叉树的个数。base是空或者到了最后一层，肯定没有子树了，返回1。



## 树的最大路径和



![image-20220202154741183](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202154741183.png)

深度优先搜索＋回溯？





# 前缀树

## 文件夹结构



![image-20220111233804077](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111233804077.png)

![image-20220112000055179](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000055179.png)

然后深度优先遍历

![image-20220112000201818](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000201818.png)

![image-20220112003108883](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112003108883.png)



# 纯递归

## 递归实现字符串求值计算

可以用栈做，但是很麻烦。

不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。

![image-20220202172047991](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202172047991.png)

![image-20220202171131832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202171131832.png)



遇见括号就进行递归，让递归计算完括号内的部分，然后返回计算的值和计算到的位置，然后继续往下计算。



```java
public class Main {
	public static void main(String[] args) {
		int a = value("4-(1+2)*3+1");
		System.out.println(a);
	}

	public static int value(String string) {
		if (string == null || string.length() == 0) {
			return 0;
		}
		return value(string.toCharArray(), 0)[0];
	}
    
//请从str[i...]往下算，遇到字符串终止位置或者右括号，就停止
//返回两个值，长度为2的数组
​	// 0)负责的这-段的结果是多少
​	// 1) 负责的这- -段计算到了哪个位置
	private static int[] value(char[] str, int i) {
		LinkedList<String> list = new LinkedList<>();//双端队列，当成栈使用
		int num = 0;
		int[] bra = null;
		while (i < str.length && str[i] != ')') {
			if (str[i] >= '0' && str[i] <= '9') {
				num = num * 10 + str[i++] - '0';
			} else if (str[i] != '(') {
				addNum(list, num);
				list.addLast(String.valueOf(str[i++]));
				num = 0;
			} else {
				bra = value(str, i + 1);
				num = bra[0];
				i = bra[1] + 1;
			}

		}
		addNum(list, num);
		return new int[] { getNum(list), i };
	}
//不带小括号用栈做，只要栈顶是乘或者除号就弹出计算完再入栈。加和减留着最后一起计算结果。
	private static void addNum(LinkedList<String> list, int num) {
		if (!list.isEmpty()) {
			int cur = 0;
			String top = list.pollLast();
			if (top.equals("+") || top.equals("-")) {
				list.addLast(top);
			} else {
				cur = Integer.valueOf(list.pollLast());
				num = top.equals("*") ? (cur * num) : (cur / num);
			}
		}
		list.addLast(String.valueOf(num));

	}

	private static int getNum(LinkedList<String> list) {
		int res = 0;
		boolean add = true;
		String curString = null;
		int num = 0;
		while (!list.isEmpty()) {
			curString = list.pollFirst();
			if (curString.equals("+")) {
				add = true;
			} else if (curString.equals("-")) {
				add = false;
			} else {
				num = Integer.valueOf(curString);
				res += add ? num : (-num);
			}
		}
		return res;
	}
}

```





![image-20220202181603892](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202181603892.png)



# 动态规划

## 类斐波那契数列

先看下数列

![image-20220110232208696](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232208696.png)



![image-20220111091236577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091236577.png)



斐波那契数列第n项的值，根据上面的矩阵得出。

![image-20220111091726036](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091726036.png)



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



可以推广到多项组合的数列



### \01字符串组合

![image-20220110232145674](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232145674.png)





![image-20220111094239894](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094239894.png)



- 第一个为1，第二个为2，的斐波那契数列

  

  ```
  public class Test {
      public static int process(int N) {
          if (N<=0)return 0;
          if (N==1)return 1;
          if (N==2)return 2;
          int a=1;
          int b=2;
          int res=0;
          while (N-2!=0){
              res=a+b;
              a=b;
              b=res;
              N--;
          }
          return res;
      }
  }
  
  ```



### 辗转相除

```
public class Main {
	public static int process(int a, int b) {
		if (b == 0)// 表示上一步的辗转相除结果为0了
			return a;
		return process(b, a % b);
	}
}

```

### exp2

![image-20220111094656196](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094656196.png)

就是在N范围中第一项为1，第二项为2的斐波那契数列个数就是可以保留的个数。

“组成三角形的三条边需满足最长的边小于另外两条边之和,最短的边大于另外两条边之差的绝对值。”

说白了就是斐波那契数在前n有几个的问题

```
public class Main {
	public static int process(int N) {
		if (N <= 3)
			return 0;
		// num记录小于N的类斐波那契数列中元素个数
		int a = 1, b = 2, res = 0, num = 2;
		// 递归的斐波那契数列
		while (true) {
			res = a + b;
			if (res > N)
				return N - num;
			a = b;
			b = res;
			num++;
		}
	}
}

```







![image-20220111215757638](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111215757638.png)

## 咖啡机问题

![image-20220109172318637](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109172318637.png)

### 递归

```java
public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));//比较的是哪个咖啡机先生产出下一杯咖啡
        for (int i : arr) {
            queue.add(new Integer[]{0, i});//o[0]开始做的时间点 o[1]做完咖啡的时间点
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        return sweepAllCup(finishTime, a, b, 0, 0);
    }

    // timePoint清洗机下一次空闲的时间
    private static int sweepAllCup(int[] finishTime, int a, int b, int index, int timePoint) {
        if (index == finishTime.length - 1) {
            //basecase，到最后一杯咖啡时【洗完上一个杯子的时间】和【下一杯咖啡喝完的时间（喝完才能洗）加上洗杯子的时间】取较大的一个，就是洗玩下一个杯子的时间，然后跟喝完下一杯coffee的时间加上自然干净的时间取较小的一个，就是喝完下一杯咖啡并且洗干净杯子的时间。
            return Math.min(Math.max(finishTime[index], timePoint) + a, finishTime[index] + b);
        }
        //咖啡机刷
        int sweepTime = Math.max(timePoint, finishTime[index]) + a;
        int sweepRestFinish = sweepAllCup(finishTime, a, b, index + 1, sweepTime);
        int time1 = Math.max(sweepRestFinish, sweepTime);//刷这个杯子和剩余杯子都完成
        //自己干
        int dryTime = finishTime[index] + a;
        int dryRestFinish = sweepAllCup(finishTime, a, b, index + 1, timePoint);
        int time2 = Math.max(dryRestFinish, dryTime);//自干这个杯子和剩余杯子都完成
        return Math.min(time1, time2);
    }

}

```

### **动态规划**

```java
 public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));
        for (int i : arr) {
            queue.add(new Integer[]{0, i});
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        int M = finishTime[N - 1] + b;
        int[][] dp = new int[N][M + 1];
        for (int i = 0; i <= M; i++) {
            dp[N - 1][i] = Math.min(Math.max(i, finishTime[i]) + a, finishTime[i] + b);
        }
        for (int i = N - 2; i >= 0; i--) {
            for (int j = 0; j < M; j++) {
                int sweepTime = Math.max(finishTime[i], j) + a;
                int time1 = Math.max(sweepTime, dp[i + 1][sweepTime]);
                int dryTime = finishTime[i] + b;
                int time2 = Math.max(dryTime, dp[i][dryTime]);
                dp[i][j] = Math.min(time1, time2);
            }
        }
        return dp[0][0];
    }
}

```



## mirror数

时间复杂度o(n)空间复杂度o1的遍历二叉树的方式，有点像线索二叉树

风 9:00:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA6222916FD12483540696AE21E31DE4.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/4C27099AE86BCE98E709AC5F9CF2538E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8504DEFFA83DB68111285AED30E18B0E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/EED6FE103117301421F4743445C3373B.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C75EE0D5505A484727EA6512F8E86D92.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/72D1C3B3F2016909613C37B70FC62739.jpg)

风 9:00:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0965229D51ED08FB47C5E19C2C823FAA.jpg)

## [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

https://leetcode-cn.com/problems/longest-valid-parentheses/



![image-20211228091332515](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228091332515.png)







```java
class Solution {
    public int longestValidParentheses(String s) {
         int maxans = 0;
        int[] dp = new int[s.length()];
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)==')'){
                if(s.charAt(i-1)=='('){
                    dp[i]=(i >= 2 ? dp[i - 2] : 0) + 2;
                }else if(i-dp[i-1]-1>=0&& s.charAt(i - dp[i - 1] - 1) == '('){
                     dp[i]=dp[i-1]+((i - dp[i - 1]) -2>= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans=Math.max(dp[i],maxans);
            }
        }
        return maxans;

    }
}
```



## 数字解码方法

https://leetcode-cn.com/problems/decode-ways/

![image-20211228230339191](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228230339191.png)





**递归实现**

- 时间复杂度为指数级

  ```
  public class Main {
  	public static int process(String s, int i) {
  		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
  		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
  			return 1;
  		if (s.charAt(i) == '0')
  			return 0;// 没有0开头匹配的元素
  		int res = process(s, i + 1);// 一个字符的
  		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
  			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
  		return res;// 累加的结果返回就行了
  	}
  }
  
  ```

  **动态规划**

  - 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
  - 时间复杂度为O(N)

  

  - ```java
    
    
    public class Main {
    	public static int process(String string) {
    		if (string == null || string.length() == 0) {
    			return 0;
    		}
    		if (string.length() == 1) {
    			return string == "0" ? 0 : 1;
    		}
    		char[] arr = string.toCharArray();
    		int N = arr.length;
    		int[] res = new int[arr.length + 1];
    		res[N] = 1;
    		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
    		for (int i = N - 2; i >= 0; --i) {
    			if (arr[i] == '0') {
    				res[i] = 0;
    			} else {
    				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
    					res[i] = res[i + 1];
    				} else {
    					res[i] = res[i + 1] + res[i + 2];
    				}
    			}
    		}
    		return res[0];
    	}
    }
    
    ```

  - 



## 背包问题（树形）



![image-20220111220832926](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111220832926.png)

https://blog.csdn.net/qq_37438740/article/details/105072492

- 和返回字符串的所有子字符串相似，判断每个物品是否装进了袋子两种选择
- 只需要用递归像树一样遍历所有选择取出最大值即可
- 这样的题可以使用动态规划O(N²),递归O(2^N)



### **暴力递归**

```
public class Main {
    private static int maxBag;
    private static int[] weights;
    private static int[] values;

    public static int process(int[] weights, int[] values, int maxBag) {
        Main.maxBag = maxBag;
        Main.weights = weights;
        Main.values = values;
        return process(maxBag, 0);
    }

    /**
     * @param w 剩余空间
     * @param i 当前已经判断到那个物品了
     * @return 最大价值
     */
    private static int process(int w, int i) {
        if (i == weights.length) return 0;
        if (w < weights[i]) return process(w, i + 1);
        return Math.max(process(w, i + 1), process(w - weights[i], i + 1) + values[i]);
    }
}

```

### **动态规划**

```
public class Main {
    public static int process(int[] weights, int[] values, int maxBag) {
        int[][] dp = new int[weights.length + 1][maxBag + 1];
        for (int i = 1; i <= weights.length; i++) {
            for (int j = 0; j <= maxBag; j++) {
                if (j < weights[i - 1]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j] + values[i - 1]);
            }
        }
        return dp[weights.length][maxBag];
    }
}


public class BackPack01 {

	static int N=6;//物品有五件
	static int W=21;//背包容量为20
	static int weight[]= {0,2,3,4,5,9};//重量 2 3 4 5 9
	static int value[]= {0,3,4,5,8,10};//价值3 4 5 8 10
	
	public static void getValue() {
		int sum[][]= new int[N][W];//sum[i][j]意思是：背包容量为j时，在前i件物品中取小于等于i件物品，此时取得的物品的价值最大
		
		for(int i=1;i<N;i++) {
			for(int j=1;j<W;j++) {
				if(weight[i]>j) {//太重了，拿不了
					sum[i][j]=sum[i-1][j];
				}else {//拿：sum[i-1][j-weight[i]]+value[i]   不拿： sum[i-1][j]
					//拿为什么是k-1？  因为sum[i-1][j-weight[i]]可以理解为此时还没拿第i件的最大价值，当然我们要留weight[i]空间
					sum[i][j]=Math.max(sum[i-1][j-weight[i]]+value[i], sum[i-1][j]);
				}
			}
		}
		
		System.out.println(sum[5][20]);
	}
	
	public static void main(String[] args) {
		getValue();
	}
}



	public static void getValue1() {
		int sum[]= new int[W];
		
		for(int i=1;i<N;i++) {
			for(int j=W-1;j>=1;j--) {
				if(weight[i]<=j) {
					sum[j]=Math.max(sum[j], sum[j-weight[i]]+value[i]);
				}
			}
		}
		
		System.out.println(sum[20]);
	}

```



## 人气值

![image-20220118235953006](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235953006.png)



**错误代码**

- 没有考虑条件结束情况，也就是没有basecase
  ![image-20220119091240024](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119091240024.png)

```
public class Test {
    public static void process1(int start, int x, int y, int z, int end) {
        func(x, y, z, end, start);
    }
    private static int func(int x, int y, int z, int end, int thisNum) {
        if (end == thisNum) {
            return 0;
        }
        int resX = func(x, y, z, end, thisNum + 2) + x;
        int resY = func(x, y, z, end, thisNum * 2) + y;
        int resZ = func(x, y, z, end, thisNum - 2) + z;
        return Math.min(resX, Math.min(resY, resZ));
    }
}

```



**暴力递归**

上面缺少basecase,导致递归无法结束。因此最好的方法

根据题目内容找出一个不是最优解的平凡解作为上限，找出边界条件（比如负值）作为下限，超过这个范围就终止返回错误值。



```java
public class Main {
    public static int x, y, z, target, generalSolution;
    public static int process1(int x, int y, int z, int start, int end) {
        Main.x = x;
        Main.y = y;
        Main.z = z;
        Main.target = end;
        Main.generalSolution = (end - start) / 2 * x;
        //自己推出来的平凡解，该解是该题的一个解 不知道是不是最右，但是最优值定少于等于该值
        return func(start, 0);
    }

    /**
     * @param thisNum  当前人气
     * @param coinsNum 当前消费的硬币量
     * @return 该路径上所消费的硬币数量
     */
    private static int func(int thisNum, int coinsNum) {
        if (target == thisNum) {
            return coinsNum;
        }
        if (coinsNum > generalSolution) {
            return Integer.MAX_VALUE;
        }
        if (coinsNum < 0 ) {
            return Integer.MAX_VALUE;
        }
        int resX = func(thisNum + 2, coinsNum + x);
        int resY = func(thisNum * 2, coinsNum + y);
        int resZ = func(thisNum - 2, coinsNum + z);
        return Math.min(resX, Math.min(resY, resZ));
    }
}

```

















**动态规划**

```java
public class Main {
    public static int process(int x, int y, int z, int start, int target) {
        int generalSolution = (target - start) / 2 * x;//表示每个target对应最大的硬币数，不会超过这个银币数的，

        int max = Math.max(x, Math.max(y, z));
        int[][] dp = new int[target + 1][generalSolution + max + 1];//第一维度表示当前的人气值，第二维度表示当前消费的硬币量
        for (int i = 0; i <= generalSolution; i++) {
            dp[target][i] = i;
        }
        for (int i = generalSolution; i <= generalSolution + max; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = Integer.MAX_VALUE;
            }
        }
        for (int coinsConsume = generalSolution; coinsConsume >= 0; coinsConsume--) {
            for (int thisNum = start; thisNum <= target; thisNum++) {
                dp[thisNum][coinsConsume] = Math.min(dp[thisNum + 2][coinsConsume + x],
                        Math.min(dp[thisNum * 2][coinsConsume + y], dp[thisNum - 2][coinsConsume + z]));
            }
        }
        return dp[start][0];
    }
}

```



![image-20220119093939360](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119093939360.png)





## 数组博弈最值

![image-20220119000120936](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119000120936.png)

**递归实现**

```
public class Main {
    public static int win(int[] arr) {
        return Math.max(f(arr, 0, arr.length - 1), e(arr, 0, arr.length - 1));
    }

    // 先手情况： 当前取值和下一次作为的后手结合的情况取最大值，就剩一个时那么结果直接取走
    public static int f(int[] arr, int l, int r) {
        if (l == r) return arr[l];
        return Math.max(arr[l] + e(arr, l + 1, r), arr[r] + e(arr, l, r - 1));
    }

    // 作为后手进行定是取值最小，剩一个元素就返回0
    public static int e(int[] arr, int l, int r) {
        if (l == r) return 0;
        return Math.min(f(arr, l + 1, r), f(arr, l, r - 1));
    }
}

```

**递归实现**

![image-20220119000151111](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119000151111.png)





```
public class Main {
    public static int process(int[] arr) {
        int N = arr.length;
        int[][] front = new int[N][N];
        for (int i = 0; i < N; i++) {
            front[i][i] = arr[i];
        }
        int[][] end = new int[N][N];
        for (int i = N - 1; i >= 0; i--) {
            for (int j = i + 1; j < N; j++) {
                front[i][j] = Math.max(arr[i] + end[i + 1][j], arr[j] + end[i][j - 1]);
                end[i][j] = Math.min(front[i + 1][j], front[i][j - 1]);
            }
        }
        return Math.max(front[0][N - 1], end[0][N - 1]);
    }
}

```



## 二元运算组合

![image-20220119214113494](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119214113494.png)

相当于给定了数列，我们只能加小括号改变运算的顺序，数字和字符的位置不能变动

![image-20220119215008178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215008178.png)





验证是不是符合要求的字符串

![image-20220119214904682](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119214904682.png)

basecase：L=R的时候，只有一个字符

![image-20220119215346885](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215346885.png)
![image-20220119215724416](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215724416.png)
![image-20220119215802512](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119215802512.png)



改成动态规划

一个三维表，三个变量。

或者搞两个表，一个是true表，一个是false表

![image-20220119220612585](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220612585.png)







![image-20220119220735669](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220735669.png)

![image-20220119220808599](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119220808599.png)



## 最长无重复子串

![image-20220119225152149](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119225152149.png)



**看到子串和子数组的问题，直接就选择以每个位置为结尾会怎么怎么样就好了**



```java
public class Main {
    public static int process(String s) {
        if (s == null || s.length() == 0) {
            return 0;
        }
        char[] array = s.toCharArray();
        int[] map = new int[256];//下标表示字符，值表示字符上一次出现的位置下标
        Arrays.fill(map, -1);
        int left = -1, maxLen = 0;// left表示此时向左延伸的最左位置，不包括array[left],包括array[right]
        for (int right = 0; right < array.length; right++) {
            left = Math.max(left, map[array[right]]);// 上次最左位置和array[right]上次出现的位置取最右的下标
            maxLen = Math.max(maxLen, right - left);// 更新结果
            map[array[right]] = right;// 更新上次出现的位置索引
        }
        return maxLen;
    }
}

```

## 字符串转换代价问题

![image-20220119230624915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119230624915.png)

- 该题主要是从什么地方下手，我们采用从字符串最后的地方下手，对于每一次决策进行三种选择，取最小值。

一个字符串作为行，一个字符串作为列

![image-20220119231341055](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220119231341055.png)

`dp[i][j]`表示str1的前i个转换为str2的前j个字符串的代价是多少，str2为0的时候相当于str1一直删除。str1位0的时候相当于一直插入到str2.

对于`dp[i][j]`的值，有三种操作：

1. 执行一次更改：

​		`1.1 str1[i] == str[j],dp[i][j] = dp[i-1][j-1]`

​		`1.2 str1[i] != str[j],dp[i][j] = dp[i-1][j-1]+1` 更改一次的操作

2. 执行一次删除
   `dp[i][j] = dp[i][j]+1`
3. 执行一次添加
   `dp[i][j] = dp[i][j-1]+1`



**暴力递归**

暴力基本跟动态规划的几种情况差不多

```java
public class Main {
    public static char[] str1, str2;
    public static int ic, dc, rc;

    public static int process(char[] s1, char[] s2, int i, int d, int r) {
        str1 = s1;
        str2 = s2;
        ic = i;
        dc = d;
        rc = r;
        return process(str1.length - 1, str2.length - 1);
    }

    public static int process(int str1_len, int str2_len) {
        if (str1_len == 0 && str2_len == 0) {
            return 0;
        } else if (str1_len == 0) {
            return ic * str2_len;
        } else if (str2_len == 0) {
            return dc * str1_len;
        }
        int replace;
        if (str1[str1_len - 1] == str2[str2_len - 1]) {
            replace = process(str1_len - 1, str2_len - 1);
        } else {
            replace = process(str1_len - 1, str2_len - 1) + rc;
        }
        int delete = process(str1_len - 1, str2_len) + dc;
        int add = process(str1_len, str2_len - 1) + ic;
        return Math.min(Math.min(delete, add), replace);
    }

}

```

**动态规划**

basecase 第一列，变为空串直接删除就好

```java
public class Main {
    public static int process(String str1, String str2, int ic, int dc, int rc) {
        if (str1 == null || str2 == null) {
            return 0;
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int row = chs1.length + 1;
        int col = chs2.length + 1;
        int[][] dp = new int[row][col];
        //0个字符变成i个的添加代价
        for (int i = 1; i < row; i++) {
            dp[i][0] = dc * i;
        }
        //j个字符变成0个的删除代价
        for (int j = 1; j < col; j++) {
            dp[0][j] = ic * j;
        }
        for (int i = 1; i < row; i++) {
            for (int j = 1; j < col; j++) {
                //替换代价
                if (chs1[i - 1] == chs2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = dp[i - 1][j - 1] + rc;
                }
                /*
                 dp[i][j - 1] + ic：
                            i个转化成j-1长度的代价+一个添加代价
                            
                 dp[i - 1][j] + dc：
                            i-1个转化成j长度的代价+一个删除代价
                 */
                          
                dp[i][j] = Math.min(dp[i][j], dp[i][j - 1] + ic);
                dp[i][j] = Math.min(dp[i][j], dp[i - 1][j] + dc);
            }
        }
        return dp[row - 1][col - 1];
    }
}

```



## 最小字典序

![image-20220121093108649](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093108649.png)



![image-20220121093035083](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093035083.png)

![image-20220121093017011](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093017011.png)

![image-20220121092910294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121092959349.png)



- 当第一次某字符最后一次出现（下标记作 i ）时，就选择当前i位置前面的所有字符中ASCLL最小的值（下标记作 j ）作为结果的一部分，然后将后面出现 s.charAt( j ) 的字符去掉再根据 j 后的串进行进行递归

```
public class Main {
    public static String process(String s) {
        if (s==null||s.length()<2)return s;
        int []map=new int[256];
        for (int i=0;i<s.length();i++){
            map[s.charAt(i)]++;
        }
        int minASCLLIndex=0;
        for (int i=0;i<s.length();i++){
                // 记录前面ASCLL最小的位置
                minASCLLIndex=s.charAt(minASCLLIndex)<s.charAt(i)?minASCLLIndex:i;
            if (--map[s.charAt(i)]==0){// 第一次发生一个字符的最后一次出现
                break;
            }
        }
        // minASCLLIndex后的字符串去掉s.charAt(minASCLLIndex)的字符串向后继续
        return  s.charAt(minASCLLIndex)+process(s.substring(minASCLLIndex+1).replaceAll(String.valueOf(s.charAt(minASCLLIndex)),""));
    }
}

```



- 一直入栈，判断peek元素比当前大并且后面还存在和peek相同的字符，那么就从栈中删除栈顶元素。

```
class Solution {
    public String removeDuplicateLetters(String s) {
        int N = s.length();
        if (N <= 1) return s;
        char[] chars = s.toCharArray();
        Deque<Character> stack = new LinkedList<>();
        int[] lastIndex = new int[26];
        boolean[] isVisited = new boolean[26];
        for (int i = 0; i < N; i++) {
            lastIndex[chars[i] - 'a'] = i;
        }
        for (int i = 0; i < N; i++) {
            if (isVisited[chars[i] - 'a']) continue;
            while (!stack.isEmpty() && stack.peek() > chars[i] && lastIndex[stack.peek() - 'a'] > i) {
                isVisited[stack.pop() - 'a'] = false;
            }
            stack.push(chars[i]);
            isVisited[chars[i] - 'a'] = true;
        }
        StringBuffer stringBuffer = new StringBuffer();
        for (Character ch : stack) {
            stringBuffer.append(ch);
        }
        return stringBuffer.reverse().toString();
    }
}

```



## 字符串转换问题



![image-20220121092936819](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121092936819.png)



## 字符串编码

![image-20220121093607212](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121093607212.png)



![image-20220121094036917](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220121094036917.png)





## 异或和为0的区间个数

网易的题目

![image-20220124231247965](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124231247965.png)

异或，英文为exclusive OR，缩写成xor

如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。

只有在两个比较的位不同时其结果是1，否则结果为0

即“两个输入相同时为0，不同则为1”！

| a    | b    | a⊕b  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 0    | 1    | 1    |
| 1    | 0    | 1    |
| 1    | 1    | 0    |

两个相同数异或的结果为0

任何数与0异或，结果都是那个数

![image-20220124232237022](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124232237022.png)

![image-20220124234457717](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124234457717.png)

![image-20220124235901697](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124235901697.png)

### 一般解

- 前序累计异或，根据从左向右的动态规划思想进行最大值的判断和记录。
- 初始值：位置为0的时候，0前面的-1位置默认为dp[-1] = 0
- dp[i]表示，以i位置（包含i位置）结尾的子字符串，最多能有几个异或为0的区间个数。
  对于dp[i]来说，i位置有两种情况：
  1. dp[i] 与前面的数字没有异或成0，因此这个数字相当于废掉的，他如果不为0的话，他就不起作用，单独就不是0.他的值直接等于dp[i-1]， 
  2. dp[i]与前面的数字进行异或构成一个异或为0的子区间。参考**两个相同数异或的结果为0**，因此只需要找这个数字前面最近的异或等于改为数字的区间的起始值就好。假设为j(包含j位置)，则dp[i]这种情况的值为 1+dp[j-1]，
  3. 然后比较两种情况的最大值，就能确定dp[i]位置最好的值
- 因此需要一个map。记录从头往后遍历数字，一直进行异或，记录每个异或以后的结果，key为结果，val为最近一次达到这个值的位置。在进行上面第二步的时候直接查。如果有就直接用来计算第二部，然后更新这个值的最近的位置为i。
- 如果从0位置异或到i位置为1000，如何找到含有i位置的最近的区间异或结果为0的位置？只要找到上一个距离i位置最近的从0异或到j位置的值为1000的j就好，这样从j+1异或到i的值就是0了，因为只有0异或1000的结果才是1000。这样就找到从j+1开始到i位置异或的结果为0，符合上面那个（2）条件了
- 这个就是前缀和，只不过是异或和



```java
public class Main {
	public static int process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		// 存储前面所有元素的累计异或结果
		int[] preSum = new int[arr.length];
		preSum[0] = arr[0];
		// 计算累计异或结果
		for (int i = 1; i < preSum.length; i++) {
			preSum[i] = preSum[i - 1] ^ arr[i];
		}
		// 存储每个位置前的最多的亦或者为零的个数
		int[] preMaxNum = new int[arr.length];
		for (int i = 1; i < arr.length; ++i) {
			// 初始化当前结果值
			preMaxNum[i] = preSum[i] == 0 ? 1 : 0;
			// 后面的值根据前面的更新，需要判断两个累计亦或结果相同，那么这其中异或和定为0
			for (int j = i - 1; j >= 0; --j) {
				if (preSum[j] == preSum[i]) {//如果preSum[j] == preSum[i]，则说明arr[j+1---i]的异或值为0，因为一个数异或0才等于这个数的值。
					// arr[i……j]之间的的数组成一个亦或为0的值然后加上preMaxNum[j]就该结合的结果值
					// 这里实际上若preMaxNum[j] + 1大的话可以直接退出该层循环。
					preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[j] + 1);
				}
			}
			// 使用arr[i]作为亦或为零的一部分和不用arr[i]的两种情况取最大值
			preMaxNum[i] = Math.max(preMaxNum[i], preMaxNum[i - 1]);
		}
		return preMaxNum[preMaxNum.length - 1];
	}
}

```

### 优化解法

- 上一种解法中提到，当满足preMaxNum[j] + 1 > preMaxNum[i] 时就可以退出循环，说明我们只是找到一个满足更新条件即可

```java
public class Test {
    public static int mostEOR(int[] arr) {
        if (arr==null||arr.length==0)return 0;
        int ans = 0;
        int xor = 0;
        int[] mosts = new int[arr.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        map.put(0, -1);//初始值，默认-1位置的值为0，这样跟0位置异或的结果就是0位置的值
        for (int i = 0; i < arr.length; i++) {
            xor ^= arr[i];
            //若存在，说明已经出现，那么之间的数字的异或和为0
            //这种方式下就是上次出现该值前的个数+1就是当前个数
            if (map.containsKey(xor)) {
                int pre = map.get(xor);
                mosts[i] = pre == -1 ? 1 : (mosts[pre] + 1);
            }
            if (i > 0) {
                //判断    在次数分割和抛弃改次以上一次的方案哪个为最优解
                //为了防止pre...i中出现多个异或和为0的情况
                mosts[i] = Math.max(mosts[i - 1], mosts[i]);
            }
            //更新或添加此时xor的索引
            map.put(xor, i);
            //ans实际上最后也是mosts的最后一个值，也可以在最后直接返回mosts[mosts.length-1]
            ans = Math.max(ans, mosts[i]);
        }
        return ans;
    }
}

```



![image-20220125001628190](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125001628190.png)





## 纸币组合情况数

https://leetcode-cn.com/problems/coin-change-2/

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for(int coin:coins){
            for(int i = coin;i<=amount;i++){
                dp[i]+=dp[i-coin];
            }
        }
        return dp[amount];

    }
}
```



问题：**给定数组arr，数据为面值种类，组成res的总值，每种面值可以任意使用，问共有多少种组合方式**

**暴力递归**

```
public class Main {
    public static int[] coins;

    public static int process(int[] arr, int res) {
        coins = arr;
        return process(0, res);
    }

    private static int process(int index, int curRes) {
        if (curRes == 0) return 1;//已经找到了一种组合，返回数量1
        if (index == coins.length) return 0;//已经到了最后一种面值的货币，没法继续往下递归了，看钱数rest是不是0，如果是返回1，说明组合出一种
        int res = 0;
        //相当于是01背包问题的变形体，每个位置其实是0-res/arr[i]的背包问题，全排列往下组合就完事
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        return res;
    }
}

```



![image-20211217091538083](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211217091538083.png)



**记忆化搜索**

```
public class Main {
    public static int[] coins;
    public  static int[][] dp;
    public static int process(int[] arr, int res) {
        coins = arr;
        dp=new int[arr.length+1][res+1];
        for (int[] i:dp){
            Arrays.fill(i,-1);
        }
        return process(0, res);
    }

    public static int process(int index, int curRes) {
        if (dp[index][curRes]!=-1)return dp[index][curRes];
        if (curRes == 0) {
            dp[index][curRes]=1;
            return 1;
        }
        if (index == coins.length) {
            dp[index][curRes]=0;
            return 0;
        }
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        dp[index][curRes]=res;
        return res;
    }
}

```

**严格表结构**

```
public class Main {
    public static int process( int res,int[] coins) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                int ways = 0;
                // coins[coinIndex]硬币使用了thisCoinNum个
                for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curRes; thisCoinNum++) {
                    ways += dp[coinIndex + 1][curRes - thisCoinNum * coins[coinIndex]];
                }
                dp[coinIndex][curRes] = ways;
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```

**枚举的斜率优化**

![image-20211214220414721](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220414721.png)



```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                // 该位置结果就是：
                //          dp[coinIndex+1][curRes] ( coins[coinIndex]硬币使用了0个 )
                //                      +
                //          dp[coinIndex][curRes-coins[coinIndex]] (coins[coinIndex]硬币使用了1个 )
                dp[coinIndex][curRes] = dp[coinIndex + 1][curRes];
                if (curRes - coins[coinIndex] >= 0) {
                    dp[coinIndex][curRes] += dp[coinIndex][curRes - coins[coinIndex]];
                }
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```



## 纸币组合最小个数问题

题目：**给定数组arr，里面的每个值表示一种面值，可随意使用，问组成aim所需要的最小张数，并返回**

**递归实现**





```
public class Main {
    public static int[] coins;

    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        Main.coins = coins;
        return process(0, res);
    }
	// 当前考虑的面值是arr[i]，还剩rest的钱需要找零
	// 如果返回-1说明自由使用arr[i..N-1]面值的情况下，无论如何也无法找零rest
	// 如果返回不是-1，代表自由使用arr[i..N-1]面值的情况下，找零rest需要的最少张数
    private static int process(int coinIndex, int curNum) {
    	// base case：
		// 已经没有面值能够考虑了
		// 如果此时剩余的钱为0，返回0张
		// 如果此时剩余的钱不是0，返回-1
        if (curNum == 0) {
            return 0;
        }
        if (coinIndex == coins.length) {
            return -1;
        }
		// 最少张数，初始时为-1，因为还没找到有效解
        int minNum = -1;
		// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过rest
        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {
			// 使用了k张arr[i]，剩下的钱为rest - k * arr[i]
			// 交给剩下的面值去搞定(arr[i+1..N-1])
            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);
            if (next != -1) {
                minNum = minNum == -1 ? next+thisCoinNum : Math.min(next + thisCoinNum, minNum);
            }
        }
        return minNum;
    }

}

```

**记忆化搜索**



```
public class Main {
    public static int[] coins;
    public static int[][] dp;

    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        Main.coins = coins;
        dp = new int[coins.length + 1][res + 1];
        for (int[] i : dp) {
            Arrays.fill(i, -2);
        }
        return process(0, res);
    }

    private static int process(int coinIndex, int curNum) {
        if (dp[coinIndex][curNum] != -2) return dp[coinIndex][curNum];
        if (curNum == 0) {
            dp[coinIndex][curNum] = 0;
            return 0;
        }
        if (coinIndex == coins.length) {
            dp[coinIndex][curNum] = -1;
            return -1;
        }
        int minNum = -1;
        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {
            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);
            if (next != -1) {
                minNum = minNum == -1 ? next + thisCoinNum : Math.min(next + thisCoinNum, minNum);
            }
        }
        dp[coinIndex][curNum] = minNum;
        return minNum;
    }
}

```



**严格表结构**

```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 1; i <= res; i++) {
            dp[coins.length][i] = -1;
        }
        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {
            for (int curNum = 0; curNum <= res; curNum++) {
                dp[coinIndex][curNum] = -1;// 初始化值，若是0.表示0张就可以完成，所以不合理
                for (int coinNum = 0; coins[coinIndex] * coinNum <= curNum; coinNum++) {// 对于coins[coinIndex]的硬币进行每个个数的遍历
                    int restIndex = curNum - coins[coinIndex] * coinNum;
                    if (dp[coinIndex + 1][restIndex] != -1) {// 若该值 dp[coinIndex + 1][restIndex] 不能完成，就直接跳过
                        // 取出最小值，注意最小值前要进行判断dp[coinIndex][curNum]是否为-1，表示此前没有方法出现
                        dp[coinIndex][curNum] = dp[coinIndex][curNum] == -1 ? dp[coinIndex + 1][restIndex] + coinNum :
                                Math.min(dp[coinIndex + 1][restIndex] + coinNum, dp[coinIndex][curNum]);
                    }
                }
            }
        }
        return dp[0][res];
    }

}

```

**斜率优化**

```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 1; i <= res; i++) {
            dp[coins.length][i] = -1;
        }
        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {
            for (int curNum = 0; curNum <= res; curNum++) {
                // 初始化值,继承第一个，因为定存在coins[coinIndex]一个不用的情况
                dp[coinIndex][curNum]=dp[coinIndex+1][curNum];
                if (coins[coinIndex]<=curNum){// 若存在可以用>=1个coins[coinIndex]进行计算
                    int rest=curNum-coins[coinIndex];
                    if (dp[coinIndex][rest]!=-1){// 该情况存在值
                        // 取出最小值注意判断当前dp[coinIndex][curNum]是否为-1
                        dp[coinIndex][curNum]=dp[coinIndex][curNum]==-1?dp[coinIndex][rest]+1:
                        Math.min(dp[coinIndex][rest]+1,dp[coinIndex][curNum]);
                    }
                }
            }
        }
        return dp[0][res];
    }
}

```









## 硬币结合动归

![image-20220125222729980](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125222729980.png)



```java
public class Main {
    public static int moneyWays(int[] arbitrary, int[] onlyOne, int money) {
        int[][] arbDp = getArbDp(arbitrary, money);
        int[][] onlyDp = getOnDp(onlyOne, money);
        //arbDp和onlyDp第一行就是所想要的情况数
        int result = 0;
        for (int i = 0; i <= money; i++) {
            result += arbDp[0][i] * onlyDp[0][money - i];
        }
        return result;
    }

    //01背包问题
    private static int[][] getOnDp(int[] onlyOne, int money) {
        int[][] dp = new int[onlyOne.length + 1][money + 1];//列表示用的硬币数，行表示组成的金额，单元格表示有几种组合方法。之所以加一是假设最后一行，都为0，相当于没有使用硬币的一行。
        //填写第一列，表示凑成总和为0都只有一种方法
        for (int i = 0; i < onlyOne.length; i++) {
            dp[i][0] = 1;
        }
        //从下往上，从左往右，依次填写单元格
        for (int coinIndex = onlyOne.length - 1; coinIndex >= 0; coinIndex--) {
            for (int resMoney = 0; resMoney <= money; resMoney++) {
                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];//首先不使用该位置的硬币，也就是相当于这个硬币前面组合的个数。
                if (resMoney > onlyOne[coinIndex]) {// 倘若可以挑选当前的一个硬币，钱币数大于当前硬币面额
                    dp[coinIndex][resMoney] += dp[coinIndex + 1][resMoney - onlyOne[coinIndex]];//因为每个硬币只能选一次，因此只能等于前一行的硬币的组合
                }
            }
        }
        return dp;
    }

    //动态规划
    private static int[][] getArbDp(int[] arbitrary, int money) {
        int[][] dp = new int[arbitrary.length + 1][money + 1];
        for (int i = 0; i <= arbitrary.length; i++) {
            dp[i][0] = 1;
        }
        for (int coinIndex = arbitrary.length - 1; coinIndex >= 0; coinIndex--) {
            for (int resMoney = 0; resMoney <= money; resMoney++) {
                dp[coinIndex][resMoney] = dp[coinIndex + 1][resMoney];//不用coinIndex位置的钱币的组合数
                if (resMoney > arbitrary[coinIndex]) {// 倘若可以挑选当前的一个硬币
                    dp[coinIndex][resMoney] += dp[coinIndex][resMoney - arbitrary[coinIndex]];//因为可以选择多个同面额硬币，因此可以选择同一行的位置
                }

            }
        }
        return dp;
    }
}

```





## 能力蛇最大长度问题![image-20220202161741538](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202161741538.png)

![image-20220202162345377](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202162345377.png)



**递归实现**

```
class Main {
	public static int walk1(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
		int res = Integer.MIN_VALUE;
		for (int i = 0; i < matrix.length; i++) {
			int[] ans = process(matrix, i, 0);
			res = Math.max(res, Math.max(ans[0], ans[1]));
		}
		return res;
	}

	public static int fun(int[][] m) {
		int res = Integer.MIN_VALUE;
		for (int i = 0; i < m.length; i++) {
			int ans = fun(m, i, 0, 0, false);
			res = Math.max(res, ans);
		}
		return res;
	}

	// 从(i,j)出发一直走到最右侧的旅程中
	// 0) 在没有使用过能力的情况下，返回路径最大和
	// 1) 在使用过能力的情况下，返回路径最大和
	public static int[] process(int[][] m, int i, int j) {
		if (j == m[0].length - 1) {
			return new int[] { m[i][j], -m[i][j] };
		}
		int[] restAns = process(m, i, j + 1);
		int restUnuse = restAns[0];
		int restUse = restAns[1];
		if (i - 1 >= 0) {
			restAns = process(m, i - 1, j + 1);
			restUnuse = Math.max(restUnuse, restAns[0]);
			restUse = Math.max(restUse, restAns[1]);
		}
		if (i + 1 < m.length) {
			restAns = process(m, i + 1, j + 1);
			restUnuse = Math.max(restUnuse, restAns[0]);
			restUse = Math.max(restUse, restAns[1]);
		}
		int no = m[i][j] + restUnuse;
		int yes = Math.max(m[i][j] + restUse, -m[i][j] + restUnuse);
		return new int[] { no, yes };
	}
}

```

**动态规划**

写的有问题，没有判断前一个位置为负数的情况。如果前一个位置为负数，说明游戏结束，下一个位置不应该到达。

```java
class Main {
	public static int walk2(int[][] matrix) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
			return 0;
		}
		int[][][] dp = new int[matrix.length][matrix[0].length][2];
		for (int i = 0; i < dp.length; i++) {
			dp[i][matrix[0].length - 1][0] = matrix[i][matrix[0].length - 1];
			dp[i][matrix[0].length - 1][1] = -matrix[i][matrix[0].length - 1];
		}
		for (int j = matrix[0].length - 2; j >= 0; j--) {
			for (int i = 0; i < matrix.length; i++) {
				int restUnuse = dp[i][j + 1][0];
				int restUse = dp[i][j + 1][1];
				if (i - 1 >= 0) {
					restUnuse = Math.max(restUnuse, dp[i - 1][j + 1][0]);
					restUse = Math.max(restUse, dp[i - 1][j + 1][1]);
				}
				if (i + 1 < matrix.length) {
					restUnuse = Math.max(restUnuse, dp[i + 1][j + 1][0]);
					restUse = Math.max(restUse, dp[i + 1][j + 1][0]);
				}
				dp[i][j][0] = matrix[i][j] + restUnuse;
				dp[i][j][1] = Math.max(matrix[i][j] + restUse, -matrix[i][j] + restUnuse);
			}
		}

		int res = Integer.MIN_VALUE;
		for (int i = 0; i < matrix.length; i++) {
			res = Math.max(res, Math.max(dp[i][0][0], dp[i][0][1]));
		}
		return res;
	}
}

```

## 相同子字符串

![image-20220202184008673](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220202184008673.png)

![image-20220204215111322](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204215111322.png)

第一行第一列

![image-20220204220538864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204220538864.png)



然后根据该位置相不相等，相等就左上角的格子值加一，不等就是0

**动态规划**

```
public class Main {
	public static String lcst1(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int[][] dp = getdp(chs1, chs2);
		int end = 0;
		int max = 0;
		// 记录最长子串
		for (int i = 0; i < chs1.length; i++) {
			for (int j = 0; j < chs2.length; j++) {
				if (dp[i][j] > max) {
					end = i;
					max = dp[i][j];
				}
			}
		}
		return str1.substring(end - max + 1, end + 1);
	}

	public static int[][] getdp(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		for (int i = 0; i < str1.length; i++) {
			if (str1[i] == str2[0]) {
				dp[i][0] = 1;
			}
		}
		for (int j = 1; j < str2.length; j++) {
			if (str1[0] == str2[j]) {
				dp[0][j] = 1;
			}
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				if (str1[i] == str2[j]) {
					dp[i][j] = dp[i - 1][j - 1] + 1;
				}
			}
		}
		return dp;
	}
}

```

**空间压缩**

![image-20220204231051332](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220204231051332.png)

因为每个位置只与左上角的值相关，因此可以定义一个变量斜着计算就可以了。

```
class Main {
	public static String lcst2(String str1, String str2) {
		if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
			return "";
		}
		char[] chs1 = str1.toCharArray();
		char[] chs2 = str2.toCharArray();
		int row = 0;
		int col = chs2.length - 1;
		int max = 0;
		int end = 0;
		while (row < chs1.length) {
			int i = row;
			int j = col;
			int len = 0;
			while (i < chs1.length && j < chs2.length) {
				if (chs1[i] != chs2[j]) {
					len = 0;
				} else {
					len++;
				}
				if (len > max) {
					end = i;
					max = len;
				}
				i++;
				j++;
			}
			if (col > 0) {
				col--;
			} else {
				row++;
			}
		}
		return str1.substring(end - max + 1, end + 1);
	}
}

```

## 相同最长子序列



![image-20220205174438624](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205174438624.png)

可能性分类：四种情况，以i/j结尾的情况

![image-20220205191437590](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205191437590.png)

dp数组的状态就是到str的0到i的子字符串和str2的子字符串0到j，最长能构成的相同子序列的长度，

base case，第一行和第一列，因为都只有一个子字符串，因此可以根据两个字符串的第一个位置是否相等，也就是`dp[0][0]` 的值，如果相等，后续都为1，如果不等，就是0，然后往后推。或者扩大一行和一列，也就是第0行和第0列，表示两个字符串的其中一个为0的时候，都为0，按照这个`dp`的逻辑，直接往下走。

```
public class Main {
    public static String lcse(String str1, String str2) {
        if (str1 == null || str2 == null || str1.equals("") || str2.equals("")) {
            return "";
        }
        char[] chs1 = str1.toCharArray();
        char[] chs2 = str2.toCharArray();
        int[][] dp = getdp(chs1, chs2);

        // 根据dp表格还原计算出公共的字符序列
        int m = chs1.length - 1;
        int n = chs2.length - 1;
        char[] res = new char[dp[m][n]];
        int index = res.length - 1;
        while (index >= 0) {
            // dp[m][n]是根据那个值进行推出，是dp[m][n-1],dp[m-1][n]还是dp[m-1][n-1]
            if (n > 0 && dp[m][n] == dp[m][n - 1]) {
                n--;
            } else if (m > 0 && dp[m][n] == dp[m - 1][n]) {
                m--;
            } else {
                res[index--] = chs1[m];
                m--;
                n--;
            }
        }
        return String.valueOf(res);
    }

    private static int[][] getdp(char[] str1, char[] str2) {
        int[][] dp = new int[str1.length][str2.length];
        dp[0][0] = str1[0] == str2[0] ? 1 : 0;
        //初始化条件
        for (int i = 1; i < str1.length; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
        }
        for (int j = 1; j < str2.length; j++) {
            dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
        }
        //根据str1[0...i]和str2[0...j]比较是三种情况
        //				i不当前str1子序列末尾结果，j为str2当前子序列最后元素
        //				i在当前str1子序列末尾结果，j不为str2当前子序列最后元素
        //				i是当前str1子序列末尾结果，j是str2当前子序列最后元素，存在条件为：str1[i] == str2[j] 成立
        for (int i = 1; i < str1.length; i++) {
            for (int j = 1; j < str2.length; j++) {
                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
                if (str1[i] == str2[j]) {
                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
                }
            }
        }
        return dp;
    }
}

```



## 添加最少字符组成回文串



![image-20220205174605513](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205174605513.png)



```
public class PalindromeMinAdd {

	public static String getPalindrome1(String str) {
		if (str == null || str.length() < 2) {
			return str;
		}
		char[] chas = str.toCharArray();
		int[][] dp = getDP(chas);
		char[] res = new char[chas.length + dp[0][chas.length - 1]];
		int i = 0;
		int j = chas.length - 1;
		int resl = 0;
		int resr = res.length - 1;
		while (i <= j) {
			if (chas[i] == chas[j]) {
				res[resl++] = chas[i++];
				res[resr--] = chas[j--];
			} else if (dp[i][j - 1] < dp[i + 1][j]) {
				res[resl++] = chas[j];
				res[resr--] = chas[j--];
			} else {
				res[resl++] = chas[i];
				res[resr--] = chas[i++];
			}
		}
		return String.valueOf(res);
	}

	public static int[][] getDP(char[] str) {
		int[][] dp = new int[str.length][str.length];
		for (int j = 1; j < str.length; j++) {
			dp[j - 1][j] = str[j - 1] == str[j] ? 0 : 1;
			for (int i = j - 2; i > -1; i--) {
				if (str[i] == str[j]) {
					dp[i][j] = dp[i + 1][j - 1];
				} else {
					dp[i][j] = Math.min(dp[i + 1][j], dp[i][j - 1]) + 1;
				}
			}
		}
		return dp;
	}
}

```



## 最长回文子序列

![image-20220205223706137](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223706137.png)

- 求逆序串和该串的最长公共子序列,就是该字符串的最长回文子序列

```java
class PalindromeSubsequence {

	public static int maxLen(String str) {
		if (str == null || str.length() == 0) {
			return 0;
		}
		char[] str1 = str.toCharArray();
		char[] str2 = reverse(str1);
		return lcse(str1, str2);
	}

	private static char[] reverse(char[] str) {
		char[] reverse = new char[str.length];
		for (int i = 0; i < reverse.length; i++) {
			reverse[i] = str[str.length - 1 - i];
		}
		return reverse;
	}

	private static int lcse(char[] str1, char[] str2) {
		int[][] dp = new int[str1.length][str2.length];
		dp[0][0] = str1[0] == str2[0] ? 1 : 0;
		for (int i = 1; i < str1.length; i++) {
			dp[i][0] = Math.max(dp[i - 1][0], str1[i] == str2[0] ? 1 : 0);
		}
		for (int j = 1; j < str2.length; j++) {
			dp[0][j] = Math.max(dp[0][j - 1], str1[0] == str2[j] ? 1 : 0);
		}
		for (int i = 1; i < str1.length; i++) {
			for (int j = 1; j < str2.length; j++) {
				dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);
				if (str1[i] == str2[j]) {
					dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);
				}
			}
		}
		return dp[str1.length - 1][str2.length - 1];
	}
}

```













# 有序表

![image-20211219180032411](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219180032411.png)















# 大数据问题

有限的空间找到几十亿条数据中没有出现的数

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3FDC6603989FCA68399CFD474D160126.jpg)

风 9:00:23
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9E73E41834A98DDD73670482DB8BD9DB.jpg)









# 回溯法

1.确定base case，也就是递归的终止条件或者出口

2.确定递归方法的固定参数和可变参数，以及局部输出结果，也就是下一个节点要走的结果，相当于黑盒子，

3.然后搜集子递归过程，返回给上游，最上游输出的结果就是递归的结果



优化为记忆化搜索的过程：

将子问题的结果记录在一个数组中，别的递归调用到相同的参数 的时候可以重复使用，然后就可以转为记忆化搜索的过程

## 矩阵中的路径
题目 : 请设计请设计一个函数用来判断在矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个位置开始，每部可以在矩阵中的上下左右四个方向移动，如果一条路径已经经过了矩阵的某一个格子，那么该路径就不能够再次进入该格子。

对于每个格子均有可能是起始节点，并且每个路径和其他路径没有太多可利用关系，所以要进行所有的格子作为起始结点来判断。
由于要进行方向定位，像迷宫一样进行递归回缩。

```java 
public class Main {
	public static boolean process(char[][] matrix, char[] str) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0 || str.length == 0) {
			return false;
		}
		int rows = matrix.length;
		int line = matrix[0].length;
		// 用于记录是否走过该路径
		boolean[][] isVisited = new boolean[rows][line];
		int pathLen = 0;
		// 对于每一个元素进行起始的判断
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < line; j++) {
				if (hasSuccessPath(matrix, i, j, str, 0, isVisited)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * @param matrix    元素矩阵
	 * @param row       判断matrix中行位置元素
	 * @param line      判断matrix中列位置元素
	 * @param str       寻找的目标串
	 * @param index     目标串的第几个元素
	 * @param isVisited 记录是否走过的表格
	 * @return			该路径是否可行
	 */
	private static boolean hasSuccessPath(char[][] matrix, int row, int line, char[] str, int index,
			boolean[][] isVisited) {
		// 此时说明index前面的所有元素均已经匹配成功
		if (str.length == index) {
			return true;
		}
		// 不符合条件返回不通行
		if (row >= matrix.length || line == matrix[0].length || row < 0 || line < 0 || isVisited[row][line]
				|| matrix[row][line] != str[index]) {
			return false;
		}
		++index;
		// 标记该路已经走过
		isVisited[row][line] = true;
		// 向四个方向均进行尝试
		boolean hasPath = hasSuccessPath(matrix, row + 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line + 1, str, index, isVisited)
				|| hasSuccessPath(matrix, row - 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line - 1, str, index, isVisited);
		// 若没有成功将isVisited值进行还原避免影响后续判断，若为真那么在该步骤结束时循环，不会对后来的产生影响
		if (!hasPath) {
			isVisited[row][line] = false;
		}
		return hasPath;
	}
}

```


## 机器人的运动范围
题目： 地上有一个M行N列的方格，一个机器人从坐标( 0, 0 )的个格子开始移动，他每次可向左右上下四个方向移动一个格子，但不能进入行坐标和列坐标的各个位数之和大于K值，并且到达每个格子之前必定可以通过其他格子到达该格子。例如： k=18,机器人可以进入（35，37），3+5+3+7=18<=18能进入,（36，38），3+6+3+8=20>18,不能进入。

该题目实际上和上一题本质相同，仅仅是改变了限制条件和起始范围
该题的起始范围已经给定（0，0），只需要向上下左右进行递归回溯，另外在递归时要记录路径个数。

```
public class Main {
	public static int process(int k, int rows, int lines) {
		if (k < 0 || rows <= 0 || lines <= 0) {
			return 0;
		}
		boolean[][] isVisited = new boolean[rows][lines];
		return movingCount(k, rows, lines, 0, 0, isVisited);

	}

	/**
	 * @param k         限制条件k
	 * @param rows      矩阵总行数
	 * @param lines     矩阵总列数
	 * @param i         当前元素行数量
	 * @param j         当前元素列数量
	 * @param isVisited 是否已经访问过
	 * @return 可以选择的个数
	 */
	private static int movingCount(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		int count = 0;
		// 如果满足限制条件就进行标记，并以此为展开进行递归搜索
		if (canVisited(k, rows, lines, i, j, isVisited)) {
			isVisited[rows][lines] = true;
			count += movingCount(k, rows, lines, i + 1, j, isVisited)
					+ movingCount(k, rows, lines, i - 1, j, isVisited)
					+ movingCount(k, rows, lines, i, j + 1, isVisited)
					+ movingCount(k, rows, lines, i, j - 1, isVisited);
		}
		return count;
	}

	private static boolean canVisited(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		if (i >= 0 && i < rows && j >= 0 && j < lines && !isVisited[i][j] && getDigitSum(i) + getDigitSum(j) <= k) {
			return true;
		}
		return false;
	}

	// 计算num和各位数字之和
	private static int getDigitSum(int num) {
		int sum = 0;
		while (num > 0) {// 不能 = 0
			sum += num % 10;
			num /= 10;
		}
		return sum;
	}
}

```

## 机器人到达某个位置的路径数量

## 机器人运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**

**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
    public static int[][] dp;
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20211214220219521](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220219521.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



加个二维数组记录位置的结果，记忆化搜索的优化

![image-20211214091329206](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091329206.png)



![image-20211214091359467](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091359467.png)

改为动态规划的版本：

​	二维数组，行代表在哪个位置，列代表该位置还有几部可以走。
​	首先初始化第一行，也就是basecase，然后分析下一个位置。



![image-20211214092524034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214092524034.png)





## 飞棋盘

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```

**严格表结构**

```
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围 三维分别是 x坐标、y坐标、走了几步
        dp[1][1][0] = 1;// 递归结束条件 起始位置，走0步到1,1的方式有一种
        // 递归的意识是，走了k步到达i,j位置的方式有几种
        for (int k = 1; k <= K; k++) {// 步数 
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```



## 整数分裂

![image-20211214220703594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220703594.png)

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes) return 0;
        int ways = 0;
        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }

}

```

**记忆化搜索**

```
public class Main {
    public static int[][] dp;
    public static int process(int res) {
        if (res < 1) return 0;
        dp=new int[res+1][res+1];
        for (int[]i:dp){
            Arrays.fill(i,-1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (dp[pre][curRes]!=-1)return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes]=1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes]=0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes]=ways;
        return ways;
    }

}

```

**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                for (int i = pre; i <= curRes; i++) {// 所有情况累加
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

**斜率优化**

- 枚举行为推导

![image-20211214220817010](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220817010.png)



```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        dp[res][res]=1;// 根据下一层退出结果，所以要先对最后一层就行添值
        for (int pre = res-1; pre >= 1; pre--) {// 前驱
            for (int curRes = pre ; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                dp[pre][curRes]=dp[pre+1][curRes]+dp[pre][curRes-pre];// 分析的关系
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

## bob活着

题目：**给定范围横向N，纵向M，从（i，j）开始走K步（只能上下左右走，且概率相同）没有超过给定范围那么就是活着，如果在过程中超过了范围则死了，返回活着的概率。**

**递归实现**

```
public class Main {

    public static int N, M;

    public static String process(int n, int m, int i, int j, int k) {
        N = n;
        M = m;
        int live = process(i, j, k);// 活着的情况
        int all = (int) Math.pow(4, k);// 一共存在的情况
        int gcb = gcb(all, live);// 求最大公约数
        return live / gcb + " / " + all / gcb;
    }

    private static int gcb(int m, int n) {
        if (n == 0) return m;
        return gcb(n, m % n);
    }

    // 计算活着的情况数
    public static int process(int i, int j, int K) {
        if (i < 1 || i > N || j < 1 || j > M) return 0;
        if (K == 0) return 1;
        return process(i + 1, j, K - 1) +
                process(i - 1, j, K - 1) +
                process(i, j + 1, K - 1) +
                process(i, j - 1, K - 1);
    }
}

```

**严格表结构**

```
class U {
    public static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    public static String bob2(int N, int M, int i, int j, int K) {
        int[][][] dp = new int[N + 2][M + 2][K + 1];  //x坐标，y坐标，还有几步没走到达
        //如果剩下0步的时候能走到row,col位置就是存活，否则就是死去了。
        for (int row = 1; row <= N; row++) {//初始化数据
            for (int col = 1; col <= M; col++) {
                dp[row][col][0] = 1;
            }
        }
        for (int rest = 1; rest <= K; rest++) {
            for (int row = 1; row <= N; row++) {
                for (int col = 1; col <= M; col++) {
                	//递归依赖
                    dp[row][col][rest] = dp[row - 1][col][rest - 1];
                    dp[row][col][rest] += dp[row + 1][col][rest - 1];
                    dp[row][col][rest] += dp[row][col - 1][rest - 1];
                    dp[row][col][rest] += dp[row][col + 1][rest - 1];
                }
            }
        }
        long all = (long) Math.pow(4, K);
        long live = dp[i + 1][j + 1][K];
        long gcd = gcd(all, live);
        return (live / gcd) + "/" + (all / gcd);
    }
}

```

## 数字转化成字母（树形）

![image-20211214220923610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220923610.png)

**递归实现**

- 时间复杂度为指数级

```
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```

**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。

- 时间复杂度为O(N)

  ```
  public class Main {
  	public static int process(String string) {
  		if (string == null || string.length() == 0) {
  			return 0;
  		}
  		if (string.length() == 1) {
  			return string == "0" ? 0 : 1;
  		}
  		char[] arr = string.toCharArray();
  		int N = arr.length;
  		int[] res = new int[arr.length + 1];
  		res[N] = 1;
  		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
  		for (int i = N - 2; i >= 0; --i) {
  			if (arr[i] == '0') {
  				res[i] = 0;
  			} else {
  				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
  					res[i] = res[i + 1];
  				} else {
  					res[i] = res[i + 1] + res[i + 2];
  				}
  			}
  		}
  		return res[0];
  	}
  }
  
  ```




## 数字转为字符串

![image-20211228093016742](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093016742.png)







## 字符串的全排列

![image-20211228093104568](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093104568.png)

1. 我们通常都思路都是将所有字符依次放在最前面，例如ABC，第一位为A，B,C，然后判断第二位，那么我们如何在字符串中标记该字符已经被我们安排在前面了？

2. 若我们使用下标的方式，那么在每次选择都会产生一个下标，这样会很乱。

3. 于是我们可以通过将欲放在前面的字符就直接放在前面（将字符一次和后面的交换），用一个下标指引我们前面已经定了多少的元素。

4. 但是若我们交换后在后续调用时，数据顺序已经打乱，我们可能会造成重复情况，所以我们在每次运行后再将数据交换变成原来位置。

5. 但是当数据有重复字符时，会出现重复的全排列，这是我们就要判断交换的字符是否和之前交换的相同，若相同，就不用交换

   ```java
   class Main {
   	public static List<String> list = new ArrayList<>();
   
   	public static void process(String string) {
   		char[] chars = string.toCharArray();
   		process(chars, 0);
   	}
   
   	private static void process(char[] chars, int i) {
   		if (i == chars.length) {// 结果
   			list.add(new String(chars));
   			return;
   		}
   		boolean[] isVisited = new boolean[26];// 默认只有大写字母
   		for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
   			if (!isVisited[chars[j] - 'A']) {// 是否重复
   				isVisited[chars[j] - 'A'] = true;
   				swap(chars, i, j);// 交换
   				process(chars, i + 1);// 递归
   				swap(chars, i, j);// 恢复
   			}
   		}
   	}
   
   	private static void swap(char[] chars, int i, int j) {
   		char c = chars[i];
   		chars[i] = chars[j];
   		chars[j] = c;
   	}
   }
   ```

   https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

   ```
   class Solution {
       List<String> res = new LinkedList<>();
       char[] c;
       public String[] permutation(String s) {
           c = s.toCharArray();
           dfs(0);
           return res.toArray(new String[res.size()]);
       }
       void dfs(int x) {
           if(x == c.length - 1) {
               res.add(String.valueOf(c));      // 添加排列方案
               return;
           }
           HashSet<Character> set = new HashSet<>();
           for(int i = x; i < c.length; i++) {
               if(set.contains(c[i])) continue; // 重复，因此剪枝
               set.add(c[i]);
               swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
               dfs(x + 1);                      // 开启固定第 x + 1 位字符
               swap(i, x);                      // 恢复交换
           }
       }
       void swap(int a, int b) {
           char tmp = c[a];
           c[a] = c[b];
           c[b] = tmp;
       }
   }
   ```

   

# 数组和字符串





## 组合硬币

一个硬币面值的组合，求出组合出给定金额最少的硬币数量。（这里的硬币应该不能重复选择）

版本一：

![image-20211214093158864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214093158864.png)





风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/236A5BAB3F15EC1CFE7543BC4AD930F5.jpg)

风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/679EB9A15ABE065485A2F0C6E4BCEB5C.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/F053027ABF6D72F8DA642609570B7F18.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/2652636A6206EFAC6C497FAD064A9C05.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8B8C6B0EC745DD699DDE0AB2F0560E34.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/1CD84ADF351B6BD4CD3B89469CDA68E7.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D764CDCB4B0138B2632C491A539C891.jpg)

风 21:57:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DF7DFA8B5B3FCE158CE3A8FB03048F00.jpg)

风 21:57:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0793EB962C13F0F83AB76AEF75E228A6.jpg)



## 最长递增子序列

![image-20220118225641094](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225641094.png)

- 贪心思想：从左向右的经典贪心，一直寻找对应位置序列前的最优位置。
- 每个位置前的最长子序列根据该位置前的数据的最长子序列得出，这样一来每个数位置对应的最长序列就会都依赖之前的数，也就是可以根据较小的数据个数推出较多数据的结果。



![image-20220118225702034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225702034.png)



![image-20220118225716109](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225716109.png)

![image-20220118225728920](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118225728920.png)

### O（N^2）

```
public class Main {
	public static int process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] preMax = new int[arr.length];// 记录下标为i位置前最长序列。
		int resMax = 0;
		for (int i = 0; i < arr.length; i++) {
			int curMax = 0;// 计算当前i位置前序列最长的值，不包括arr[i]
			for (int j = i - 1; j >= 0; --j) {
				if (arr[j] < arr[i]) {
					curMax = Math.max(curMax, preMax[j]);// 更新最大值
				}
			}
			// 记录最大值
			preMax[i] = curMax + 1;
			// 更新整体最长序列
			resMax = Math.max(preMax[i], resMax);
		}
		return resMax;
	}
}

```



### 优化算法O（N*logN）



![image-20220118230704870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118230704870.png)

```java
public class Main {
	/**
	 * 之前我们取的是直接存储某位置之前所存在的最长序列的个数，时间复杂度为O(N^2)
	 * 该种方法，我们可以了解到，当前面的值有存在序列最长值大于等于其他值，并且该值较小
	 * 那么比该值大且前面的子序列个数还较少，这些值就不可能成为我们的最终选的结果。
	 * 
	 * 我们现在选择一种方式，就是抛弃上述过程中存在的这些值，用下标位置索引表示当前的子序列长度。复杂度O(N*logN)
	 * 就像indexIsMaxNumArr[maxNumIndex]表示：
	 * 前面存在最长子序列长度为maxNumIndex时，满足该条件下的最小值为indexIsMaxNumArr[maxNumIndex]
	 */
	public static int process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return 0;
		}
		int[] indexIsMaxNumArr = new int[arr.length];
		int maxNumIndex = -1;// 存在最长长度索引
		for (int value : arr) {
			if (maxNumIndex == -1 || indexIsMaxNumArr[maxNumIndex] < value) {
				// 之前不存在值或者该值大于之前所有值，此时肯定比之前最长索引大1，所以maxNumIndex加上1
				indexIsMaxNumArr[++maxNumIndex] = value;
			} else {
				// 查找indexIsMaxNumArr[0…………maxNumIndex]范围中，值大于或等于value的最小值索引。
				int index = biggerThanValueLeftestIndex(indexIsMaxNumArr, value, maxNumIndex);
				// 更新该值
				indexIsMaxNumArr[index] = value;
			}
		}
		return maxNumIndex + 1;
	}

	/**
	 * 该函数在查找时总结过
	 * 
	 * @param indexIsMaxNumArr 数组
	 * @param value            目标值
	 * @param right            右端索引
	 * @return 值大于或等于value的最小值索引
	 */
	private static int biggerThanValueLeftestIndex(int[] indexIsMaxNumArr, int value, int right) {
		int left = 0;
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			if (indexIsMaxNumArr[med] == value) {
				return med;
			} else if (indexIsMaxNumArr[med] > value) {
				right = med;
			} else {
				left = med + 1;
			}
		}
		return right;
	}
}

```



## 数组中没有出现的数

![image-20220118234729600](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118234729600.png)





力扣原题

![image-20220118235433067](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118235433067.png)













# 贪心算法

## 绳子覆盖问题

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/60e968bcb3e94c07b3d48db38b220c81.png)



#### 定右二分向左查找O(N*logN)

- 最主要还是二分的实现，**详见查找深度探索二分查找**

```java
public class Main {
	public static int process(int[] arr, int L) {
		if (arr == null || arr.length == 0 || L <= 0) {
			return 0;
		}
		int res = 1;
		for (int i = 0; i < arr.length; i++) {
			int index = bRNum(arr, i, arr[i] + L);
			res = Math.max(res, index - i + 1);
		}
		return res;
	}
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```



#### 滑动窗口的解法

```java
两个值，从左往右，一个是开始位置l，一个是右边界r，保证arr[r]-arr[l]>=L，记录下r-l+1的值
```



## 前后缀差点最大值

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/cacd1046d8a0429a996570d3eccc6007.png)

一般思路：数据预处理建立两个从左右两端的最值数组，再遍历求解。
极限贪心思维：直接获取最大值和左右两端的差值
两个最大值数中定存在一个整体的最大值。
在满足将最大值放在一左端，无论怎么选择, 右一半的最大值一定大于等于最右端的元素。所以右侧最值最小只能是最右边的元素。
在满足将最大值放在一右端时同理，只需要这两种情况下取最值即可。

```java 
public class Test {
    public static int num(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        int max=arr[0];
        for (int i = 1;i < arr.length; i++){
            max = Math.max( max, arr[i]);
        }
        return Math.max(max-arr[0],max-arr[arr.length-1]);
    }
}
```



子数组累计和最大值

## magic操作

![image-20211227234337115](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234337115.png)



需要将平均值大的集合里面，拿出去介于两个平均值的值的数字到平均值小的集合里面。
尽量拿靠近平均值小的数字移动。也就是拿最小的

![image-20211227234858672](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234858672.png)
![image-20211227235542296](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235542296.png)

![image-20211227235737178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235737178.png)


因为magic操作会将两个集合的平均值都变大，所以每个可以操作数之前的数可以不用在下一轮选数里面考虑了。

## 括号深度

![image-20211228000346795](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228000346795.png)



遇到（ count++，遇到）count--，count最大的值就是深度。



## 超级洗衣机

https://leetcode-cn.com/problems/super-washing-machines/



![image-20211229085418463](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229085418463.png)



![90f2d42ebf6e4514aa4ea839f36ec099](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/90f2d42ebf6e4514aa4ea839f36ec099.png)



![image-20211229091620577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229091620577.png)



因为每次只能放到相邻的位置，相当于分成两半以后，每次只能通过选定位置传送一件衣服到另一半。

```java
public class Test {
    public static int minPoint(int[] machines) {
        if (machines == null || machines.length == 0) return -1;
        int N = machines.length;
        int allSum = 0;
        for (int i : machines) {
            allSum += i;
        }
        if (allSum % N != 0) return -1;
        int average = allSum / N;
        int leftSum = 0;
        int res = 0;
        for (int i = 0; i < N; i++) {
            int leftRest = leftSum - average * i;
            int rightRest = (allSum - leftSum - machines[i]) - (N - 1 - i) * average;
            if (leftRest < 0 && rightRest < 0) {
                res = Math.max(res, Math.abs(leftRest) + Math.abs(rightRest));
            } else {
                res = Math.max(res, Math.max(Math.abs(leftRest), Math.abs(rightRest)));
            }
            leftSum += machines[i];
        }
        return res;
    }
}

```

## 找工作

![image-20220111230320313](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111230320313.png)



![image-20220111231245062](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111231245062.png)

```java
public class Test {
    public static int[] process(Job[] jobs, int[] ability) {
        Arrays.sort(jobs, (o1, o2) -> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money));
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(jobs[0].hard, jobs[0].money);
        Job j = jobs[0];
        // 将同 hard 情况下 money 最多的进入map
        for (Job job : jobs) {
            if (job.hard != j.hard && job.money > j.money) {
                j = job;
                map.put(j.hard, j.money);
            }
        }
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            // 小于或等于ability[i]的最大键值
            Integer key = map.floorKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }
    static class Job {
    	int hard;
    	int money;
	}
}

```



**java treemap_Java TreeMap floorKey（）方法与示例**

**floorKey()方法**用于返回小于或等于给定键元素(key_ele)的最大键元素(如果存在)，否则，当不存在该键元素时返回null。**floorKey()方法**是一种非静态方法，只能通过类对象访问，如果尝试使用类名称访问该方法，则会收到错误消息。



## 子数组累计和最大值



![image-20220117094756580](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117094756580.png)



![image-20220117213014775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117213014775.png)

```
public class Test {
    public static int maxLenNum(int[] arr){
        int max=Integer.MIN_VALUE;
        int cur=0;
        for (int i : arr) {
            cur+=i;
            max=Math.max(max,cur);
            cur=Math.max(cur, 0);
        }
        return max;
    }
}

```

## 子矩阵累计和最大值(压缩数组)

![image-20220117214128825](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214128825.png)



![image-20220117214111768](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214111768.png)



- 子矩阵往往考虑是否可以转换成字数组的问题，就是将多行转化成一行或者多列转化成多列
- 转化之后思考一维情况下的解决思路，看看是否能应用到矩阵中。
  求出

0-0行 0-1行 0-2行。。0-n行，1-1行1-2行。。。1-n行 ，2-2行。。。。n-n行，将这些区间行对应列的值加在一起成为一行，然后用上面的方法求出最大值，最终的最大值就是子矩阵的最大值

这是**行压缩的方法**

```java
public class Test {
    public static int maxAreaNum(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int cur;
        int[] sumArr;
        for (int i = 0; i != arr.length; i++) {
            sumArr = new int[arr[0].length];
            for (int j = i; j != arr.length; j++) {
                cur = 0;
                for (int k = 0; k != sumArr.length; k++) {
                    sumArr[k] += arr[j][k];
                    cur += sumArr[k];
                    max = Math.max(max, cur);
                    cur = Math.max(cur, 0);
                }
            }
        }
        return max;
    }
}

```

## 安路灯

![image-20220117233125057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117233125057.png)





- 一个简单的贪心思想，将路灯尽量安装在需要安装的第二个位置。

- ```java
  public class Test {
      public static int minNum(String s) {
          char[] arr = s.toCharArray();
          int minNum = 0;
          int index = 0;
          while (index < arr.length) {
              if (arr[index] == 'X') {
               //不点灯
                  index++;
              } else {
                   //这个位置需要点亮，前面都是亮的，因此可以放在这个位置，也可以放在这个位置的下一个。
                  minNum++;
                  if (index + 1 == arr.length) {
                      break;.
                    //下一个是x，就直接去下下一个看
                  } else if (arr[index + 1] == 'X') {
                      index += 2;
                  } else {
                      //下一个不是x，相当于是...或者..*，将灯放在第二个点，然后直接去下下下个位置，这个位置需要点亮，这个位置以前的都是亮的。
                      index += 3;
                  }
              }
          }
          return minNum;
      }
  }
  
  ```

- 



## 排序相邻最大差值

- 构造一个差值范围，使差值在该范围内的所有数据都放弃考虑，从减小了大量的情况。

![image-20220124224846491](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124224846491.png)

- 用分桶的方法，将n个数分到n+1个桶中，每个桶只记录最大值和最小值。用一个boolean数组记录桶里面是否有数字，一个数组记录最大值，一个数组记录最小值

- 然后挨个计算相邻桶的差值（后一个桶的最小值和前一个桶的最大值），求出最大值就是结果

- 尤其要注意看一个数字分去哪个桶的算法。
  n+1个桶，每个桶间隔的数字gap= (max-min)/n。

  数字a应该去哪个桶？ (a-min)/gap =(a-min)*len/(max-min)
  如果a==min,则该去0号桶。
  如果a == max，应该去len号桶，而不是len-1号桶。因此上面的三个数组都要创建(len+1)的长度才能切分。

风 22:47:30
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/21B1F7EE322861D11A11DF35E1C3B291.png)



![image-20220124225001279](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225001279.png)

![image-20220124225029666](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220124225029666.png)



```java
public class Main {
	public static int maxGap(int[] nums) {
		if (nums == null || nums.length < 2) {
			return 0;
		}
		int len = nums.length;
		int min = Integer.MAX_VALUE;
		int max = Integer.MIN_VALUE;
		for (int i = 0; i < len; i++) {
			min = Math.min(min, nums[i]);
			max = Math.max(max, nums[i]);
		}
		if (min == max) {
			return 0;
		}
		// 记录桶中是否存在值
		boolean[] hasNum = new boolean[len + 1];
		int[] maxs = new int[len + 1];
		int[] mins = new int[len + 1];
		int bid = 0;
        // 由于多一个桶，那么其中一个桶定为空，最大差值定比一个桶的范围大
        // 最大差值定比的两个数定在不同的桶中，选出每个桶中的最大值最小值
		for (int i = 0; i < len; i++) {
			bid = bucket(nums[i], len, min, max);// 该数应该在桶中的下标
			// 更新桶中的最大最小值
			mins[bid] = hasNum[bid] ? Math.min(mins[bid], nums[i]) : nums[i];
			maxs[bid] = hasNum[bid] ? Math.max(maxs[bid], nums[i]) : nums[i];
			hasNum[bid] = true;
		}
		int res = 0;
		int lastMax = maxs[0];

		// 最大差值定存在于不同的桶中
		for (int i = 1; i <= len; i++) {
			if (hasNum[i]) {
				res = Math.max(res, mins[i] - lastMax);
				lastMax = maxs[i];// 记录该桶的最大值，用于后续不同桶的最大差值的比较
			}
		}
		return res;
	}
	// 计算桶的下标索引
	public static int bucket(long num, long len, long min, long max) {
		return (int) ((num - min) * len / (max - min));
	}
}

```




![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/04030C2E7169D2A81FE489D649658BA0.png)



## 过河

![image-20220205201539832](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205201539832.png)



- 贪心思想：将最小的和较大的放在一条上，若能就放一条上，否则让较大的自己一条。

- ![image-20220205205653104](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205205653104.png)

- ![image-20220205211557507](C:/Program%20Files/Typora/image-20220205211557507.png)

- ![image-20220205212541779](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212541779.png)
  ![image-20220205212639057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205212639057.png)
  ![image-20220205223114248](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220205223114248.png)

- 

  ```java
  public class Main {
  	public static int minBo(int[] arr, int weight) {
  		if (arr == null || arr.length == 0) {
  			return 0;
  		}
  		Arrays.sort(arr);
  		if (arr[arr.length-1]>weight) {
  			return Integer.MAX_VALUE;
  		}
  		int left = 0;
  		int right = arr.length - 1;
  		int boatNum = 0;
  		while (left <= right) {
  			if (arr[right] + arr[left] <= weight) {
  				++left;
  			}
  			--right;
  			++boatNum;
  		}
  		return boatNum;
  	}
  }
  
  ```

  











# 打表法

- 出现和倍数相关的问题时，可以考虑通过一般方法解题后的结果是否存在某种特殊的规律，通过直观的答案直接进行代码的书写，不需要关注本质含义。

## 整体装袋



![image-20211219220615833](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219220615833.png)

**一般思路**

可以发现，超过6和8的最小公约数以后，构成的差值一直是3/5/1循环，超过24以后，也就是8的倍数，每个rest都可以映射到减去24的某个rest。

如果超过rest超过24以后，就没必要尝试试了，因为24是6和8的最小公倍数

107个苹果

107/8=13

8的包数 	rest	mod6余数  

13				3		3

12				11		5

11				19		1

10				27		3

9					35		5

8					43		1	

```
public class Main {
	public static int num(int apple) {
		if (apple % 8 == 0)
			return apple / 8;
		int n8 = apple / 8;
		int m = apple % 8;
		while (m < 24 && n8 >= 0) {
			if (m % 6 == 0)
				return n8 + m / 6;
			--n8;
			m += 8;
		}
		return -1;
	}
}

```





**打表代码**
![image-20211219232123273](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232123273.png)

- 18前无规律，18后单为-1，双为一个值，每增加8个就增加1

```
public class Main {
	public static int daBiao(int apple) {
		if (apple < 18)
			return apple == 0 ? 0
					: (apple == 6 || apple == 8) ? 1 
						: (apple == 12 || apple == 14 || apple == 16) ? 2 
							: -1;
		if (apple % 2 == 1)
			return -1;
		return (apple - 18) / 8 + 3;
	}
}

```

2*8=16

3*6=18

差值是2，当大于18以后，多的2可以通过这个转换转换为8或者6的袋子，因此奇数肯定不可能凑成，大于18的偶数可以凑成。

## 幂次方吃草

![sdgdfgfdgdfgdrg](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA44CMIDI1JyBoIOOAjQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

不是看谁吃得多，而是看谁最后吃不了剩下的草算输



```
public class Main {
	public static String winner(int N) {
		if (N <= 4)
			return N == 0 || N == 2 ? "羊羊" : "牛牛";
		int eatTest = 1;
		while (eatTest <= N) {
			if (winner(N - eatTest).equals("羊羊"))
				return "牛牛";
			eatTest *= 4;
		}
		return "羊羊";
	}
}

```

![image-20211219232823835](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232823835.png)

![image-20211219232220642](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232220642.png)



```
public static String win(int N){
    return (N)%5==0||(N)%5==2?"羊羊":"牛牛";
}

```





# 枚举

### 矩阵最大正方形

![image-20211221215153594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211221215153594.png)

- 还是若我们直接对于单个起始位置寻找，对于每个其实位置进行判断的话时间复杂度就会比较高
- 由此我们要单向记录连续1的个数

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(maxLen(new int[][]{
        		{0, 1, 1, 1, 1, 1},
                {0, 1, 0, 0, 1, 1},
                {0, 1, 0, 0, 1, 0},
                {1, 1, 1, 1, 1, 1},
                {0, 1, 0, 1, 1, 1}}));
    }

    public static void show(int[][] a) {
        for (int[] aa : a) {
            System.out.println(Arrays.toString(aa));
        }
        System.out.println();
    }

    public static int maxLen(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        show(arr);
        
        //*******************生成向横向的累计连续数值******************
        int[][] rightArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = arr[0].length - 1; j >= 0; j--) {
                rightArr[i][j] = arr[i][j] == 0 ? 0 : j == arr[0].length - 1 ? 1 : rightArr[i][j + 1] + 1;
            }
        }
        show(rightArr);

        //*******************生成向纵向的累计连续数值******************
        int[][] downArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < arr[0].length; i++) {
            for (int j = arr.length - 1; j >= 0; j--) {
                downArr[j][i] = arr[j][i] == 0 ? 0 : j == arr.length - 1 ? 1 : downArr[j + 1][i] + 1;
            }
        }
        show(downArr);

        //*************************从小到大看看多大的正方形存在**************************8
        for (int size = Math.min(arr.length, arr[0].length); size != 0; size--) {
            if (hasSizeOfBorder(size, rightArr, downArr)) {
                return size;
            }
        }
        return 0;
    }

    private static boolean hasSizeOfBorder(int size, int[][] rightArr, int[][] downArr) {
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = 0; j < rightArr[0].length; j++) {
                if (rightArr[i][j] >= size && downArr[i][j + size - 1] >= size &&
                        downArr[i][j] >= size && rightArr[i + size - 1][j] >= size)
                    return true;
            }
        }
        return false;
    }
}

```









### 括号字符

![image-20211227233419037](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233419037.png)

![image-20211227233649531](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233649531.png)

```

```



### 差值为k的去重数字对

![image-20211227233908870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233908870.png)



使用hashset记录每个元素，然后遍历arr，找个一个数，加上k看这个值在不在hashset里面，在的话就加1。











# 业务题

## 被3整除的数的个数

![image-20220118233659667](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118233659667.png)





```

```

# 查找

## 深度探索二分查找

- **注意med的取法和R或L的调整方式**

### 经典二分查找



```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```

### 查找大于该值的最小值

```
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med + 1;
			} else {
				R = med;
			}
		}
		return L;
	}
}

```

### 查找大于等于目标值的最右值

```
public class Main {
	// 返回大于等于target的最右元素
    private int rightest(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = (left + right + 1) / 2;
            if (nums[mid] == target) left = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

### 查找小于该值的最大值

````
public class Main {
	public static int binarySearch(int[] arr, int L, int R, int value) {
		while (L < R) {
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

````

### 查找小于等于目标值的最左值

```
class Main {
	// 返回小于等于target最左元素
    private int leftest(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) right = mid;
            else if (nums[mid] < target) left = mid + 1;
            else right = mid - 1;
        }
        return left;
    }
}

```

## 查找极小值

题目：
极值定义该值比左右的值都小，如果是在数组两侧则只比较一点即可。
在无序数组中找到该极小值。

```
public class Main {
	private static Integer process(int[] arr) {
		if (arr == null || arr.length == 0) {
			return null;
		}
		int N = arr.length;
		if (N == 1) {
			return arr[0];
		}
		// 最左侧
		if (arr[0] < arr[1]) {
			return arr[0];
		}
		// 最右侧
		if (arr[N - 1] < arr[N - 2]) {
			return arr[N - 1];
		}
		int left = 1;
		int right = N - 2;
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			// right=med+1和left=med这种情况是在判断条件为arr[med]>arr[med-1]时
			if (arr[med] < arr[med + 1]) {
				right = med;
			} else {
				left = med + 1;
			}
		}
		return arr[left];
	}
}

```



## 两个有序数组寻找第k大的值

![image-20220125233334064](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220125233334064.png)



类似的题目

[剑指 Offer II 076. 数组中的第 k 大的数字](https://leetcode-cn.com/problems/xx4gT2/)--



### 归并排序子过程O(logk)

### 二分判定O(log(m)*log(n))

### O(log(min{n,m}))

```
public class Test {
    public static int findKthNum(int[] arr1, int[] arr2, int kth) {
        if (arr1 == null || arr2 == null) {
            throw new RuntimeException("Your arr is invalid!");
        }
        if (kth < 1 || kth > arr1.length + arr2.length) {
            throw new RuntimeException("K is invalid!");
        }
        int[] longs = arr1.length >= arr2.length ? arr1 : arr2;
        int[] shorts = arr1.length < arr2.length ? arr1 : arr2;
        int l = longs.length;
        int s = shorts.length;
        if (kth <= s) {
            return getUpMedian(shorts, 0, kth - 1, longs, 0, kth - 1);
        }
        if (kth > l) {
            if (shorts[kth - l - 1] >= longs[l - 1]) {
                return shorts[kth - l - 1];
            }
            if (longs[kth - s - 1] >= shorts[s - 1]) {
                return longs[kth - s - 1];
            }
            return getUpMedian(shorts, kth - l, s - 1, longs, kth - s, l - 1);
        }
        if (longs[kth - s - 1] >= shorts[s - 1]) {
            return longs[kth - s - 1];
        }
        return getUpMedian(shorts, 0, s - 1, longs, kth - s, kth - 1);
    }

    public static int getUpMedian(int[] a1, int s1, int e1, int[] a2, int s2,
                                  int e2) {
        int mid1 = 0;
        int mid2 = 0;
        int offset = 0;
        while (s1 < e1) {
            mid1 = (s1 + e1) / 2;
            mid2 = (s2 + e2) / 2;
            offset = ((e1 - s1 + 1) & 1) ^ 1;
            if (a1[mid1] > a2[mid2]) {
                e1 = mid1;
                s2 = mid2 + offset;
            } else if (a1[mid1] < a2[mid2]) {
                s1 = mid1 + offset;
                e2 = mid2;
            } else {
                return a1[mid1];
            }
        }
        return Math.min(a1[s1], a2[s2]);
    }
}

```



# 其他

## 1 比较器

  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }

你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 2 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2



## 求解最小公倍数





## 二分法





## 快速排序





## 利用二分法寻找最某个值或者最大于某个值的最小值



```
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
```



## 判定数字某位二进制的值是不是1



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



## 自定义大顶堆&小顶堆





大顶堆

```
  PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });


```

插入元素  `  pq.offer(new int[]{nums[i], i});`

查看堆顶元素 `pq.peek()[1] <= i - k`

弹出堆顶元素 `pq.poll()`



## 双端队列

定义：`Deque<Integer> deque = new LinkedList<Integer>();`

当队列使用：
				尾部弹出 ` deque.pollLast();`

​		查看尾部元素`deque.peekLast()`	

​		查看头部元素 `deque.peekFirst()`

​		尾部插入 ` deque.offerLast(i);`





## 二分法查找值大于或等于value的最小值索引

```
	/**
	 * 该函数在查找时总结过
	 * 
	 * @param indexIsMaxNumArr 数组
	 * @param value            目标值
	 * @param right            右端索引
	 * @return 值大于或等于value的最小值索引
	 */
	private static int biggerThanValueLeftestIndex(int[] indexIsMaxNumArr, int value,int left, int right) {
		while (left < right) {
			int med = ((right - left) >> 1) + left;
			if (indexIsMaxNumArr[med] == value) {
				return med;
			} else if (indexIsMaxNumArr[med] > value) {
				right = med;//这里不能等于med-1，因为有可能med-1的位置就小于value的值了，只要等于med就行。普通的二分法可以这么做
			} else {
				left = med + 1;
			}
		}
		return right;
	}
```



# 整体思想

### [ 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)



### 旋转字符串

![image-20220107001832841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001832841.png)

- 一般思路：尝试所有的情况，看是否存在相同的
- 优化思路：见代码

```
public class Test {
    public static boolean isRoa(String s,String r){
        if (s.length()!=r.length())return false;
        String ss= s + s;
        return ss.contains(r);
    }
}

```





### zigzag方式打印矩阵

![image-20211229093821968](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229093821968.png)

- 只关注单趟循环，分离宏观控制和循环过程

- ```java
  public class Main {
  	public static void print(int[][] arr) {
  		int N = arr.length - 1;
  		int M = arr[0].length - 1;
  		int firstRow = 0, firstLine = 0, secondRow = 0, secondLine = 0;
  		boolean flag = false; // 控制打印方向
  		while (secondLine != M + 1) {
  			print(arr, firstRow, firstLine, secondRow, secondLine, flag);
  			if (firstLine != M)
  				firstLine++;
  			else
  				firstRow++;
  			if (secondRow != N)
  				secondRow++;
  			else
  				secondLine++;
  			flag = !flag;
  		}
  	}
  
  	private static void print(int[][] arr, int firstRow, int firstLine, int secondRow, int secondLine, boolean flag) {
  		if (flag) {
  			while (firstLine >= secondLine) {
  				System.out.print(arr[firstRow++][firstLine--] + " ");
  			}
  		} else {
  			while (secondLine <= firstLine) {
  				System.out.print(arr[secondRow--][secondLine++] + " ");
  			}
  		}
  	}
  }
  
  ```

  ### 

  ### 



### 90度旋转

https://leetcode-cn.com/problems/rotate-matrix-lcci/submissions/



![image-20211230000012145](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230000012145.png)

1.先水平翻转，再根据主对角线翻转得到：

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

。
```

2.原地旋转

一组四个对角转一下，借助一个临时变量就够了



```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}

```

https://pic.leetcode-cn.com/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif

![194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif)

3.暴力方法

`对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。`

![image-20211230001116999](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230001116999.png)

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] matrix_new = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
    }
}

```







# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623

