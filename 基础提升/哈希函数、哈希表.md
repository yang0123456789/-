

# 数学计算

## 数组相邻积能被4整除

![image-20220109181842536](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109181842536.png)

![image-20220109182228294](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109182228294.png)

## 只有两个键的键盘


![image-20220107000747053](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000747053.png)

https://leetcode-cn.com/problems/2-keys-keyboard/solution/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/

两个题目有点像。
如果n是个质数，那么操作数只能是n-1次，也就相当于操作第二步。不然的话，无法凑成n（质数：只有1和自己的因数的的数。）
如果b不是个质数，则把n分解成`x*Y*z*...`等几个质数的乘积，需要的最少操作数就是子质数之和减去质数的个数。
因此可以用动态规划做。
初试条件s已经有了a了，因此dp的边界条件dp[1] = 0.
![image](https://user-images.githubusercontent.com/43565774/147913317-7f29fccd-8cf6-4214-8447-c75ad5465732.png)

![image](https://user-images.githubusercontent.com/43565774/147913626-a29d5f15-e26a-4bc1-bbf9-0185afa2b3e6.png)

```
class Solution {
    public int minSteps(int n) {
        int[] dp=new int[n+1];
        for(int i = 2;i<=n;i++){
            dp[i] = Integer.MAX_VALUE;
            for(int j = 1;j*j<=i;j++){
                if(i%j==0){
                    // 下面两个顺序不能换
                    dp[i]=Math.min(dp[i],dp[j]+i/j);
                dp[i]=Math.min(dp[i],dp[i/j]+j);
                 
            }
            }
        }
        return dp[n];
    }
}


##  判断是不是质数素数
```
public boolean isPrime(int n)

{undefined

if(n < 2) return false;

for(int i = 2; i < n; ++i)

if(n%i == 0) return false;

return true;

}
```


## 自定义比较器
https://blog.csdn.net/whing123/article/details/77851737

 Comparator

```

class Teacher{  
    int num;  
    double salary;  

    public Teacher(int num, double salary) {  
        this.num = num;  
        this.salary = salary;  
    }  
    
    @Override  
    public String toString() {  
        return "\r\tnum:"+num+" salary:"+salary+"\r";  
    }      
}  

class StudentComparator implements Comparator{  

    public int compare(Object o1, Object o2) {  
        Teacher t1 = (Teacher) o1;  
        Teacher t2 = (Teacher) o2;  
        int result = t1.num > t2.num ? 1 : (t1.num == t2.num ? 0 : -1);  
        return result = result == 0 ?(t1.salary<t2.salary ? 1 : -1) : result;  
    }   
}  


```
Comparable

```
import java.util.ArrayList;  
import java.util.Collections;  
import java.util.Comparator;  
import java.util.List;  

public class CompareTest {  
    public static void main(String[] args) {  
        List<Student> list = new ArrayList<Student>(10);  
        list.add(new Student(1,"jj"));  
        list.add(new Student(0,"ww"));  
        list.add(new Student(0,"kk"));  
        list.add(new Student(2,"ll"));  
        Collections.sort(list); // 内部比较器:要排序的类实现Comparable接口,可以对自身进行比较  
        System.out.println(list);  

        List<Teacher> t = new ArrayList<Teacher>(10);  
        t.add(new Teacher(1,12));  
        t.add(new Teacher(0,13));  
        t.add(new Teacher(0,14));  
        t.add(new Teacher(2,15));  
        Collections.sort(t,new StudentComparator()); //外部比较器:通过额外的类来实现Comparator接口  
        System.out.println(t);  
    }  
}  
	
	
	

```
	
```
	class Student implements Comparable {  
	int num;  
	String name;  
	
	public Student(int num, String name) {  
	    this.num = num;  
	    this.name = name;  
	}  
	
	@Override  
	public String toString() {  
	    return "\r\tnum:"+num+" name:"+name+"\r";  
	}  
	
	public int compareTo(Object o) {  
	    Student tmp = (Student) o;  
	    int result = tmp.num > num ? 1 : (tmp.num==num ? 0 : -1);  
	    if (result == 0) {  
	        result = tmp.name.indexOf(0) > name.indexOf(0) ? 1 : -1;  
	    }  
	    return result;  
	}  
}  
	
	```

# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位

 ![image](https://user-images.githubusercontent.com/43565774/144262216-121ffafc-12ef-4094-a838-e9ef2f034ba4.png)

![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整



## 一致性哈希









# 并查集

融合

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8CF8D66817018FBB3E968AB8FACBB42B.jpg)

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C15EF7866196C79D418DCECBC4D33358.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/69490C61145109D46C98A19C56B204BD.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0DAF1C2D9659D76ED8EE873A64431511.jpg)

风 23:46:16
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/AC53BA985C9A6E9E5B79F90A72375321.jpg)

## 岛屿数量



多cpu情况



![image-20211202232412841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202232412841.png)





# kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)





## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

## 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





# 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算





## 接雨水



### 1.单调栈

```
class Solution {
    public int trap(int[] height) {
        int n = height.length;
        if (n == 0) {
            return 0;
        }

        int[] leftMax = new int[n];
        leftMax[0] = height[0];
        for (int i = 1; i < n; ++i) {
            leftMax[i] = Math.max(leftMax[i - 1], height[i]);
        }

        int[] rightMax = new int[n];
        rightMax[n - 1] = height[n - 1];
        for (int i = n - 2; i >= 0; --i) {
            rightMax[i] = Math.max(rightMax[i + 1], height[i]);
        }

        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += Math.min(leftMax[i], rightMax[i]) - height[i];
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### 双指针

```
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int left = 0, right = height.length - 1;
        int leftMax = 0, rightMax = 0;
        while (left < right) {
        // 先更新指针的值，再进行计算雨水，再移动指针较小的端的指针。
            leftMax = Math.max(leftMax, height[left]);
            rightMax = Math.max(rightMax, height[right]);
            if (height[left] < height[right]) {
                ans += leftMax - height[left];
                ++left;
            } else {
                ans += rightMax - height[right];
                --right;
            }
        }
        return ans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode-solution-tuvc/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```











### 最大分段最大值的差

![image-20220107000935422](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107000935422.png)



找到最大值，然后减去两头的值，哪个小减去哪个。因为两段以后必然包含端点的值。
![image-20220107001615368](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001615368.png)







# 树形dp





风 9:11:52
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8137EC9804C17A0400E254509CD5AD74.jpg)

风 9:11:53
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/759C819ADFCB16E2CA56D2AEED307D6A.jpg)

## 树节点最远距离

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3D9B73ED255C5D81E3CC844F11CB856B.jpg)

风 9:11:55
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C361F70153593EABDE8588C7F7D23CF3.jpg)

风 9:11:56
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/325332F68C65A9A217E9F07DE2527361.jpg)



![image-20211209092409856](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211209092409856.png)



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D95FBD3D6DD4FF2CBDAA5A9011CCC7E.jpg)



***递归套路：***

- 根据子树最大深度计算出经过当前节点的最长距离
- 向上传递子树和经过当前节点最长距离 的最大值
- 最长距离需要子树深度
- 所以递归数据包括最大距离和最大深度





```java

public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}



```



## 树节点最远距离（套路题）

![image-20211228222749514](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228222749514.png)

递归套路：

根据子树最大深度计算出经过当前节点的最长距离
向上传递子树和经过当前节点最长距离 的最大值
最长距离需要子树深度
所以递归数据包括最大距离和最大深度

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```
}





## 员工的快乐值



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/513BBF7364AF9B669F89CB5E33521B1C.jpg)


![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/36AEC04043D12E4DD4B9DD9B070B6BE8.jpg)

***递归套路：***

- 最大值和每个节点是否去有关，就是取 **当前节点不去（0）+子节点去或不去的最大值** 和 **当前节点去（happy）+子节点不去的最大值**
- 每个节点的去和不去都会直接影响父类节点，间接影响祖宗节点。
- 只要递归传递该节点去和不去的最大值信息即可。

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxHappy(header);
		return Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
	}

	private static TransformData maxHappy(Node header) {
		if (header.nexts == null) {
			return new TransformData(0, header.happyNum);
		}
		int dontWent = 0;
		int went = 0;
		for (Node nextNode : header.nexts) {
			TransformData data = maxHappy(nextNode);
			went += data.thisNodeDontWentSumHappy;
			dontWent += Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
		}
		return new TransformData(dontWent, went);
	}

	public static class TransformData {
		int thisNodeDontWentSumHappy;
		int thisNodeWentSumHappy;
		public TransformData(int thisNodeDontWentSumHappy, int thisNodeWentSumHappy) {
			this.thisNodeDontWentSumHappy = thisNodeDontWentSumHappy;
			this.thisNodeWentSumHappy = thisNodeWentSumHappy;
		}

	}

	public static class Node {
		int happyNum;
		Node[] nexts;
	}
}

```



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/052E9D9096F34CEC4809DB9CA1D60FD0.jpg)

风 9:12:03
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/116215E06216BC9B2D6E0E6BE249E6C7.jpg)



## 树结构转成链表（套路题）

![]()

- 将左右子树构建好的结果通过本节点链接，就是递归对数据就是链接起始和结束节点。



```java
public class Main {
    public static Data process(Node x) {
        if (x == null) {
            return new Data(null, null);
        }
        // 将x作为中间节点，x.leftNode为创建x的前面的链表，x.rightNode为创建后面的链表。
        Data leftData = process(x.leftNode);
        Data rightData = process(x.rightNode);
        // 前后创建的链表和中间节点x链接，因为是双向链表，所以要有四句链接
        if (leftData.end != null) {
            leftData.end.rightNode = x;
        }
        x.leftNode = leftData.end;
        if (rightData.start != null) {
            rightData.start.leftNode = x;
        }
        x.rightNode = rightData.start;
        // 创建好后重新分装返回起始节点和尾节点
        return new Data(leftData.start != null ? leftData.start : x,
                rightData.end != null ? rightData.end : x);
    }

    static class Data {
        Node start;
        Node end;
        public Data(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 子搜索二叉树的节点个数（套路题）



![image-20220113001019144](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220113001019144.png)







## 二叉树的个数

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/adea57019f814883a17071344d4f5f96.png)

```java
public class Main {
	public static int process(int N) {
		if (N == 0 || N == 1) {
			return 1;
		}
		int res = 0;
		for (int i = 0; i < N; i++) {
			res += process(i) * process(N - i - 1);
		}
		return res;
	}
}

```

![image-20211227231055343](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227231055343.png)



```java
public static int num(int n) {
    if (n < 2) {
        return 1;
    }
    int[] dp = new int (n + 1);
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        for (int j = 1; j <= i; j++) {
            dp[i]+=dp[j-1]*dp[i-j];
        }
    }
    return dp[n];

}
```















## 判断是搜索二叉树（套路题）

**中序遍历实现**

中序遍历是有小到大的

```
public class Main {
	public static int lastNum=Integer.MIN_VALUE;
	public static boolean isBST(Node header) {
		if (header.leftNode!=null) {
			if (!isBST(header.leftNode)) {
				return false;
			}
		}
		if (lastNum>header.value) {
			return false;
		}
		lastNum=header.value;
		if (header.rightNode!=null) {
			if (!isBST(header.rightNode)) {
				return false;
			}
		}
		return true;
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```

**递归套路实现**

![image-20220117092658302](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092658302.png)



```
public class Main {
	public static TransformData isBST(Node header) {
		if (header == null) {
			return new TransformData(true, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		TransformData leftData = isBST(header.leftNode);
		TransformData rightData = isBST(header.rightNode);
		boolean flag = leftData.max < header.value && rightData.min > header.value;
		return new TransformData(flag, Math.max(rightData.max, header.value), Math.min(leftData.min, header.value));
	}

	private static class TransformData {
		boolean sucess;
		int max;
		int min;
		public TransformData(boolean sucess, int max, int min) {
			this.sucess = sucess;
			this.max = max;
			this.min = min;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```





## 子搜索二叉树的节点个数（套路题）

![image-20220117092722704](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117092722704.png) 





![image-20220117093905556](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117093905556.png)

```java
public class Main {
	public static boolean process(Node header) {
		if (header == null) {
			return true;
		}
		TransformData data = maxChildBSTree(header);
		return data.isBST;
	}

	private static TransformData maxChildBSTree(Node header) {
	//basecase 如果是空节点，也希望传递个上层节点已有能将递归进行下去，所以给最大值和最小值。 	
		if (header == null) {
			return new TransformData(true, 0, Integer.MIN_VALUE, Integer.MAX_VALUE);
		}
		//递归左右子节点获取信息
		TransformData leftData = maxChildBSTree(header.leftNode);
		TransformData rightData = maxChildBSTree(header.rightNode);
		//判断加上目前节点是不是构成一颗二叉搜索树，该节点的值应该大于左子树最大值，小于右子树最小值
		if (leftData.isBST && rightData.isBST && header.value > leftData.maxValue
				&& header.value < rightData.maxValue) {
			//可能性1，该节点与左右子树构成一颗新的二叉搜索树，左右都得是二叉搜索树
			return new TransformData(true, leftData.childMaxBSTNodeNum + rightData.childMaxBSTNodeNum + 1,
					Math.max(header.value, rightData.maxValue), Math.min(leftData.minValue, leftData.minValue));
		}
        // 可能性2 ，该节点与左右子树构不成二叉搜索树，就给maxValue赋值最小，minValue赋值最大，保证上层节点无法构成二叉搜索树。然后比较左右子树哪个节点多就返回哪个
		return new TransformData(false, Math.max(leftData.childMaxBSTNodeNum, rightData.childMaxBSTNodeNum),
				Integer.MIN_VALUE, Integer.MAX_VALUE);

	}

	public static class TransformData {
		boolean isBST;//以该节点为根节点的子树是不是二叉搜索树
		int childMaxBSTNodeNum;//不管是或者不是，这颗子树拥有的最大的搜索二叉树的节点个数
		int maxValue;// 构成搜索二叉树的最大的值
		int minValue;//构成搜索二叉树最小的值
		public TransformData(boolean isBST, int num, int max, int min) {
			this.isBST = isBST;
			this.childMaxBSTNodeNum = num;
			this.maxValue = max;
			this.minValue = min;
		}

	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```









## 前中序推后序遍历

![image-20220117235316030](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235316030.png)

- 关注在前中后序遍历之间的元素相对位置关系。
- ![image-20220117235951620](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117235951620.png)

```java
public class Test {
    public static void main(String[] args) {
        int[] post = genPost(new int[]{1, 2, 4, 5, 3, 6, 7}, new int[]{4, 2, 5, 1, 6, 3, 7});
        System.out.println(Arrays.toString(post));
    }

    public static int[] genPost(int[] pre, int[] in) {
        int[] post = new int[pre.length];
        HashMap<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < in.length; i++) {
            map.put(in[i], i);
        }
        genPost(pre, 0, pre.length - 1, in, 0, in.length - 1, post, 0, post.length - 1, map);
        return post;
    }

    private static void genPost(int[] pre, int preStart, int preEnd,
                                int[] in, int medStart, int medEnd,
                                int[] post, int postStart, int postEnd,
                                HashMap<Integer, Integer> map) {
        if (preStart > preEnd) {
            return;
        }
        if (postStart == postEnd) {
            post[postStart] = pre[preStart];
            return;
        }
        //每一轮的前序第一个元素就是后序最后一个元素，在后续的genPost中不能再包含其他元素
        post[postEnd] = pre[preStart];

        //此时寻找pre[preStart]在med中的索引indexStart，那么最后的 indexStart - medStart 就是中间元素个数
        int indexStart = map.get(pre[preStart]);
        
        //以pre中preStart位置的元素为左右分割点,根据 indexStart 确定pre,in,post中的数据范围
        genPost(pre, preStart + 1, preStart + indexStart - medStart,
                in, medStart, indexStart - 1,
                post, postStart, postStart + indexStart - medStart - 1,
                map);
        genPost(pre, preStart + indexStart - medStart + 1, preEnd,
                in, indexStart + 1, medEnd,
                post, postStart + indexStart - medStart, postEnd - 1,
                map);
    }
}

```



## 完全二叉树的个数

​	

![image-20220118092613612](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092613612.png)

![image-20220118093215169](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093215169.png)

求完全二叉树的深度的方法。

![image-20220118092804821](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118092804821.png)



![image-20220118093156008](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093156008.png)

![image-20220118093510245](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220118093510245.png)

看右子树的深度是不是与当前最深度相等，是的，那左子树肯定是满二叉树，如果不是的话，那这个右子树肯定是满二叉树。确定了满二叉树的个数，就可以递归计算另外一个不是满二叉树的子二叉树的个数。base是空或者到了最后一层，肯定没有子树了，返回1。

# 前缀树

## 文件夹结构



![image-20220111233804077](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111233804077.png)

![image-20220112000055179](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000055179.png)

然后深度优先遍历

![image-20220112000201818](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112000201818.png)

![image-20220112003108883](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220112003108883.png)



# 动态规划

## 类斐波那契数列

先看下数列

![image-20220110232208696](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232208696.png)



![image-20220111091236577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091236577.png)



斐波那契数列第n项的值，根据上面的矩阵得出。

![image-20220111091726036](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111091726036.png)



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



可以推广到多项组合的数列



### \01字符串组合

![image-20220110232145674](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220110232145674.png)





![image-20220111094239894](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094239894.png)



- 第一个为1，第二个为2，的斐波那契数列

  

  ```
  public class Test {
      public static int process(int N) {
          if (N<=0)return 0;
          if (N==1)return 1;
          if (N==2)return 2;
          int a=1;
          int b=2;
          int res=0;
          while (N-2!=0){
              res=a+b;
              a=b;
              b=res;
              N--;
          }
          return res;
      }
  }
  
  ```



### 辗转相除

```
public class Main {
	public static int process(int a, int b) {
		if (b == 0)// 表示上一步的辗转相除结果为0了
			return a;
		return process(b, a % b);
	}
}

```

### exp2

![image-20220111094656196](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111094656196.png)

就是在N范围中第一项为1，第二项为2的斐波那契数列个数就是可以保留的个数。

“组成三角形的三条边需满足最长的边小于另外两条边之和,最短的边大于另外两条边之差的绝对值。”

说白了就是斐波那契数在前n有几个的问题

```
public class Main {
	public static int process(int N) {
		if (N <= 3)
			return 0;
		// num记录小于N的类斐波那契数列中元素个数
		int a = 1, b = 2, res = 0, num = 2;
		// 递归的斐波那契数列
		while (true) {
			res = a + b;
			if (res > N)
				return N - num;
			a = b;
			b = res;
			num++;
		}
	}
}

```







![image-20220111215757638](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111215757638.png)

## 咖啡机问题

![image-20220109172318637](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220109172318637.png)

### 递归

```java
public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));//比较的是哪个咖啡机先生产出下一杯咖啡
        for (int i : arr) {
            queue.add(new Integer[]{0, i});//o[0]开始做的时间点 o[1]做完咖啡的时间点
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        return sweepAllCup(finishTime, a, b, 0, 0);
    }

    // timePoint清洗机下一次空闲的时间
    private static int sweepAllCup(int[] finishTime, int a, int b, int index, int timePoint) {
        if (index == finishTime.length - 1) {
            //basecase，到最后一杯咖啡时【洗完上一个杯子的时间】和【下一杯咖啡喝完的时间（喝完才能洗）加上洗杯子的时间】取较大的一个，就是洗玩下一个杯子的时间，然后跟喝完下一杯coffee的时间加上自然干净的时间取较小的一个，就是喝完下一杯咖啡并且洗干净杯子的时间。
            return Math.min(Math.max(finishTime[index], timePoint) + a, finishTime[index] + b);
        }
        //咖啡机刷
        int sweepTime = Math.max(timePoint, finishTime[index]) + a;
        int sweepRestFinish = sweepAllCup(finishTime, a, b, index + 1, sweepTime);
        int time1 = Math.max(sweepRestFinish, sweepTime);//刷这个杯子和剩余杯子都完成
        //自己干
        int dryTime = finishTime[index] + a;
        int dryRestFinish = sweepAllCup(finishTime, a, b, index + 1, timePoint);
        int time2 = Math.max(dryRestFinish, dryTime);//自干这个杯子和剩余杯子都完成
        return Math.min(time1, time2);
    }

}

```

### **动态规划**

```java
 public class Main {
    public static int sweepAllCup(int[] arr, int N, int a, int b) {
        PriorityQueue<Integer[]> queue = new PriorityQueue<>(Comparator.comparingInt(o -> o[0] + o[1]));
        for (int i : arr) {
            queue.add(new Integer[]{0, i});
        }
        int[] finishTime = new int[N];
        for (int i = 0; i < N; i++) {
            Integer[] integers = queue.poll();
            integers[0] += integers[1];
            finishTime[i] = integers[0];
            queue.add(integers);
        }
        int M = finishTime[N - 1] + b;
        int[][] dp = new int[N][M + 1];
        for (int i = 0; i <= M; i++) {
            dp[N - 1][i] = Math.min(Math.max(i, finishTime[i]) + a, finishTime[i] + b);
        }
        for (int i = N - 2; i >= 0; i--) {
            for (int j = 0; j < M; j++) {
                int sweepTime = Math.max(finishTime[i], j) + a;
                int time1 = Math.max(sweepTime, dp[i + 1][sweepTime]);
                int dryTime = finishTime[i] + b;
                int time2 = Math.max(dryTime, dp[i][dryTime]);
                dp[i][j] = Math.min(time1, time2);
            }
        }
        return dp[0][0];
    }
}

```



## mirror数

时间复杂度o(n)空间复杂度o1的遍历二叉树的方式，有点像线索二叉树

风 9:00:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA6222916FD12483540696AE21E31DE4.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/4C27099AE86BCE98E709AC5F9CF2538E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8504DEFFA83DB68111285AED30E18B0E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/EED6FE103117301421F4743445C3373B.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C75EE0D5505A484727EA6512F8E86D92.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/72D1C3B3F2016909613C37B70FC62739.jpg)

风 9:00:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0965229D51ED08FB47C5E19C2C823FAA.jpg)

## [最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

https://leetcode-cn.com/problems/longest-valid-parentheses/



![image-20211228091332515](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228091332515.png)







```java
class Solution {
    public int longestValidParentheses(String s) {
         int maxans = 0;
        int[] dp = new int[s.length()];
        for(int i=1;i<s.length();i++){
            if(s.charAt(i)==')'){
                if(s.charAt(i-1)=='('){
                    dp[i]=(i >= 2 ? dp[i - 2] : 0) + 2;
                }else if(i-dp[i-1]-1>=0&& s.charAt(i - dp[i - 1] - 1) == '('){
                     dp[i]=dp[i-1]+((i - dp[i - 1]) -2>= 0 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans=Math.max(dp[i],maxans);
            }
        }
        return maxans;

    }
}
```



## 数字解码方法

https://leetcode-cn.com/problems/decode-ways/

![image-20211228230339191](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228230339191.png)





**递归实现**

- 时间复杂度为指数级

  ```
  public class Main {
  	public static int process(String s, int i) {
  		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
  		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
  			return 1;
  		if (s.charAt(i) == '0')
  			return 0;// 没有0开头匹配的元素
  		int res = process(s, i + 1);// 一个字符的
  		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
  			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
  		return res;// 累加的结果返回就行了
  	}
  }
  
  ```

  **动态规划**

  - 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。
  - 时间复杂度为O(N)

  

  - ```java
    
    
    public class Main {
    	public static int process(String string) {
    		if (string == null || string.length() == 0) {
    			return 0;
    		}
    		if (string.length() == 1) {
    			return string == "0" ? 0 : 1;
    		}
    		char[] arr = string.toCharArray();
    		int N = arr.length;
    		int[] res = new int[arr.length + 1];
    		res[N] = 1;
    		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
    		for (int i = N - 2; i >= 0; --i) {
    			if (arr[i] == '0') {
    				res[i] = 0;
    			} else {
    				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
    					res[i] = res[i + 1];
    				} else {
    					res[i] = res[i + 1] + res[i + 2];
    				}
    			}
    		}
    		return res[0];
    	}
    }
    
    ```

  - 



## 背包问题（树形）



![image-20220111220832926](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111220832926.png)

https://blog.csdn.net/qq_37438740/article/details/105072492

- 和返回字符串的所有子字符串相似，判断每个物品是否装进了袋子两种选择
- 只需要用递归像树一样遍历所有选择取出最大值即可
- 这样的题可以使用动态规划O(N²),递归O(2^N)



### **暴力递归**

```
public class Main {
    private static int maxBag;
    private static int[] weights;
    private static int[] values;

    public static int process(int[] weights, int[] values, int maxBag) {
        Main.maxBag = maxBag;
        Main.weights = weights;
        Main.values = values;
        return process(maxBag, 0);
    }

    /**
     * @param w 剩余空间
     * @param i 当前已经判断到那个物品了
     * @return 最大价值
     */
    private static int process(int w, int i) {
        if (i == weights.length) return 0;
        if (w < weights[i]) return process(w, i + 1);
        return Math.max(process(w, i + 1), process(w - weights[i], i + 1) + values[i]);
    }
}

```

### **动态规划**

```
public class Main {
    public static int process(int[] weights, int[] values, int maxBag) {
        int[][] dp = new int[weights.length + 1][maxBag + 1];
        for (int i = 1; i <= weights.length; i++) {
            for (int j = 0; j <= maxBag; j++) {
                if (j < weights[i - 1]) dp[i][j] = dp[i - 1][j];
                else dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j] + values[i - 1]);
            }
        }
        return dp[weights.length][maxBag];
    }
}


public class BackPack01 {

	static int N=6;//物品有五件
	static int W=21;//背包容量为20
	static int weight[]= {0,2,3,4,5,9};//重量 2 3 4 5 9
	static int value[]= {0,3,4,5,8,10};//价值3 4 5 8 10
	
	public static void getValue() {
		int sum[][]= new int[N][W];//sum[i][j]意思是：背包容量为j时，在前i件物品中取小于等于i件物品，此时取得的物品的价值最大
		
		for(int i=1;i<N;i++) {
			for(int j=1;j<W;j++) {
				if(weight[i]>j) {//太重了，拿不了
					sum[i][j]=sum[i-1][j];
				}else {//拿：sum[i-1][j-weight[i]]+value[i]   不拿： sum[i-1][j]
					//拿为什么是k-1？  因为sum[i-1][j-weight[i]]可以理解为此时还没拿第i件的最大价值，当然我们要留weight[i]空间
					sum[i][j]=Math.max(sum[i-1][j-weight[i]]+value[i], sum[i-1][j]);
				}
			}
		}
		
		System.out.println(sum[5][20]);
	}
	
	public static void main(String[] args) {
		getValue();
	}
}



	public static void getValue1() {
		int sum[]= new int[W];
		
		for(int i=1;i<N;i++) {
			for(int j=W-1;j>=1;j--) {
				if(weight[i]<=j) {
					sum[j]=Math.max(sum[j], sum[j-weight[i]]+value[i]);
				}
			}
		}
		
		System.out.println(sum[20]);
	}

```





# 有序表

![image-20211219180032411](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219180032411.png)















# 大数据问题

有限的空间找到几十亿条数据中没有出现的数

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3FDC6603989FCA68399CFD474D160126.jpg)

风 9:00:23
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9E73E41834A98DDD73670482DB8BD9DB.jpg)









# 回溯法

1.确定base case，也就是递归的终止条件或者出口

2.确定递归方法的固定参数和可变参数，以及局部输出结果，也就是下一个节点要走的结果，相当于黑盒子，

3.然后搜集子递归过程，返回给上游，最上游输出的结果就是递归的结果



优化为记忆化搜索的过程：

将子问题的结果记录在一个数组中，别的递归调用到相同的参数 的时候可以重复使用，然后就可以转为记忆化搜索的过程

## 矩阵中的路径
题目 : 请设计请设计一个函数用来判断在矩阵中是否存在一条包含某字符串所有字符的路径，路径可以从矩阵中的任意一个位置开始，每部可以在矩阵中的上下左右四个方向移动，如果一条路径已经经过了矩阵的某一个格子，那么该路径就不能够再次进入该格子。

对于每个格子均有可能是起始节点，并且每个路径和其他路径没有太多可利用关系，所以要进行所有的格子作为起始结点来判断。
由于要进行方向定位，像迷宫一样进行递归回缩。

```java 
public class Main {
	public static boolean process(char[][] matrix, char[] str) {
		if (matrix == null || matrix.length == 0 || matrix[0].length == 0 || str.length == 0) {
			return false;
		}
		int rows = matrix.length;
		int line = matrix[0].length;
		// 用于记录是否走过该路径
		boolean[][] isVisited = new boolean[rows][line];
		int pathLen = 0;
		// 对于每一个元素进行起始的判断
		for (int i = 0; i < rows; i++) {
			for (int j = 0; j < line; j++) {
				if (hasSuccessPath(matrix, i, j, str, 0, isVisited)) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * @param matrix    元素矩阵
	 * @param row       判断matrix中行位置元素
	 * @param line      判断matrix中列位置元素
	 * @param str       寻找的目标串
	 * @param index     目标串的第几个元素
	 * @param isVisited 记录是否走过的表格
	 * @return			该路径是否可行
	 */
	private static boolean hasSuccessPath(char[][] matrix, int row, int line, char[] str, int index,
			boolean[][] isVisited) {
		// 此时说明index前面的所有元素均已经匹配成功
		if (str.length == index) {
			return true;
		}
		// 不符合条件返回不通行
		if (row >= matrix.length || line == matrix[0].length || row < 0 || line < 0 || isVisited[row][line]
				|| matrix[row][line] != str[index]) {
			return false;
		}
		++index;
		// 标记该路已经走过
		isVisited[row][line] = true;
		// 向四个方向均进行尝试
		boolean hasPath = hasSuccessPath(matrix, row + 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line + 1, str, index, isVisited)
				|| hasSuccessPath(matrix, row - 1, line, str, index, isVisited)
				|| hasSuccessPath(matrix, row, line - 1, str, index, isVisited);
		// 若没有成功将isVisited值进行还原避免影响后续判断，若为真那么在该步骤结束时循环，不会对后来的产生影响
		if (!hasPath) {
			isVisited[row][line] = false;
		}
		return hasPath;
	}
}

```


## 机器人的运动范围
题目： 地上有一个M行N列的方格，一个机器人从坐标( 0, 0 )的个格子开始移动，他每次可向左右上下四个方向移动一个格子，但不能进入行坐标和列坐标的各个位数之和大于K值，并且到达每个格子之前必定可以通过其他格子到达该格子。例如： k=18,机器人可以进入（35，37），3+5+3+7=18<=18能进入,（36，38），3+6+3+8=20>18,不能进入。

该题目实际上和上一题本质相同，仅仅是改变了限制条件和起始范围
该题的起始范围已经给定（0，0），只需要向上下左右进行递归回溯，另外在递归时要记录路径个数。

```
public class Main {
	public static int process(int k, int rows, int lines) {
		if (k < 0 || rows <= 0 || lines <= 0) {
			return 0;
		}
		boolean[][] isVisited = new boolean[rows][lines];
		return movingCount(k, rows, lines, 0, 0, isVisited);

	}

	/**
	 * @param k         限制条件k
	 * @param rows      矩阵总行数
	 * @param lines     矩阵总列数
	 * @param i         当前元素行数量
	 * @param j         当前元素列数量
	 * @param isVisited 是否已经访问过
	 * @return 可以选择的个数
	 */
	private static int movingCount(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		int count = 0;
		// 如果满足限制条件就进行标记，并以此为展开进行递归搜索
		if (canVisited(k, rows, lines, i, j, isVisited)) {
			isVisited[rows][lines] = true;
			count += movingCount(k, rows, lines, i + 1, j, isVisited)
					+ movingCount(k, rows, lines, i - 1, j, isVisited)
					+ movingCount(k, rows, lines, i, j + 1, isVisited)
					+ movingCount(k, rows, lines, i, j - 1, isVisited);
		}
		return count;
	}

	private static boolean canVisited(int k, int rows, int lines, int i, int j, boolean[][] isVisited) {
		if (i >= 0 && i < rows && j >= 0 && j < lines && !isVisited[i][j] && getDigitSum(i) + getDigitSum(j) <= k) {
			return true;
		}
		return false;
	}

	// 计算num和各位数字之和
	private static int getDigitSum(int num) {
		int sum = 0;
		while (num > 0) {// 不能 = 0
			sum += num % 10;
			num /= 10;
		}
		return sum;
	}
}

```

## 机器人到达某个位置的路径数量

## 机器人运动问题

题目：
**参数N：1~N个位置
参数S：初始位置
参数E：终点位置
参数K：要走的步数
机器人在E位置要用K步走到S有几种选择**

**递归形式**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        return left + right;
    }
}

```

**记忆搜索动态规划**

```
public class Main {
    /**
     * @param N 参数N：1~N个位置
     * @param E 当前位置
     * @param S 终点位置
     * @param K 要走的步数
     * @return 种类
     */
    public static int function(int N, int E, int S, int K) {
        dp = new int[N + 1][K + 1];
        for (int[] ints : dp) {
            Arrays.fill(ints, -1);// 标记-1表示未计算过
        }
        process(N, E, S, K);// 填充dp
        return dp[E][K];
    }
    public static int[][] dp;
    private static int process(int N, int E, int S, int K) {
        if (K == 0) return E == S ? 1 : 0;
        if (dp[E][K] != -1) return dp[E][K];// 已存在就直接返回
        int left = 0, right = 0;
        if (E != 1) left = process(N, E - 1, S, K - 1);// 不等于1就可以向左走
        if (E != N) right = process(N, E + 1, S, K - 1);// 不等于N就可以向右走
        dp[E][K] = left + right;// 填充dp
        return dp[E][K];
    }
}

```

**严格表结构动态规划**

![image-20211214220219521](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220219521.png)



- 确定变量以及变量范围
- 标出目标位置，为返回结果
- 递归结束条件（最终结果）
- 确定依赖关系
- 根据依赖按照合适填补的顺序填补

```
public class Main {
    public static int process(int N, int E, int S, int K) {
        int[][] dp = new int[K + 1][N + 1];// 递归变量个数和变化范围决定了dp的维度和大小
        dp[0][S] = 1;// 递归的结束条件时dp的前提条件
        for (int k = 1; k <= K; k++) {
            for (int e = 1; e <= N; e++) {
                // 递归内容决定dp的数据填充链接，进而确定填充顺序
                if (e == 1) dp[k][e] = dp[k - 1][e + 1];
                else if (e == N) dp[k][e] = dp[k - 1][e - 1];
                else dp[k][e] = dp[k - 1][e + 1] + dp[k - 1][e - 1];
            }
        }
        // 返回结果
        return dp[K][E];
    }
}

```



加个二维数组记录位置的结果，记忆化搜索的优化

![image-20211214091329206](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091329206.png)



![image-20211214091359467](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214091359467.png)

改为动态规划的版本：

​	二维数组，行代表在哪个位置，列代表该位置还有几部可以走。
​	首先初始化第一行，也就是basecase，然后分析下一个位置。



![image-20211214092524034](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214092524034.png)





## 飞棋盘

问题：**在像棋盘上给定起始位置问用K步从起始位置到（1，1）有几种选择**

**递归实现**

```
public class Main {
    public static int process(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        if (K == 0) return (x == 1 && y == 1) ? 1 : 0;// 步数结束，是否到达位置
        // 向八方搜索
        return process(x - 1, y - 2, K - 1) +
                process(x - 1, y + 2, K - 1) +
                process(x + 1, y - 2, K - 1) +
                process(x + 1, y + 2, K - 1) +
                process(x - 2, y + 1, K - 1) +
                process(x - 2, y - 1, K - 1) +
                process(x + 2, y - 1, K - 1) +
                process(x + 2, y + 1, K - 1);

    }
}

```

**严格表结构**

```
public class Main {
    public static int[][][] dp;
    public static int process(int x, int y, int K) {
        dp = new int[10 + 1][9 + 1][K + 1];// 递归变量以及范围 三维分别是 x坐标、y坐标、走了几步
        dp[1][1][0] = 1;// 递归结束条件 起始位置，走0步到1,1的方式有一种
        // 递归的意识是，走了k步到达i,j位置的方式有几种
        for (int k = 1; k <= K; k++) {// 步数 
            for (int i = 1; i <= 10; i++) {// 横坐标
                for (int j = 1; j <= 9; j++) { // 纵坐标
                    dp[i][j][k] += getValue(i - 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i - 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j + 2, k - 1);
                    dp[i][j][k] += getValue(i + 1, j - 2, k - 1);
                    dp[i][j][k] += getValue(i + 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i + 2, j + 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j - 1, k - 1);
                    dp[i][j][k] += getValue(i - 2, j + 1, k - 1);
                }
            }
        }
        return dp[x][y][K];
    }

    private static int getValue(int x, int y, int K) {
        if (x < 1 || x > 10 || y < 1 || y > 9) return 0;// 出界
        return dp[x][y][K];
    }
}

```



## 纸币组合情况数

https://leetcode-cn.com/problems/coin-change-2/

```java
class Solution {
    public int change(int amount, int[] coins) {
        int[] dp = new int[amount+1];
        dp[0] = 1;
        for(int coin:coins){
            for(int i = coin;i<=amount;i++){
                dp[i]+=dp[i-coin];
            }
        }
        return dp[amount];

    }
}
```



问题：**给定数组arr，数据为面值种类，组成res的总值，每种面值可以任意使用，问共有多少种组合方式**

**暴力递归**

```
public class Main {
    public static int[] coins;

    public static int process(int[] arr, int res) {
        coins = arr;
        return process(0, res);
    }

    private static int process(int index, int curRes) {
        if (curRes == 0) return 1;//已经找到了一种组合，返回数量1
        if (index == coins.length) return 0;//已经到了最后一种面值的货币，没法继续往下递归了，看钱数rest是不是0，如果是返回1，说明组合出一种
        int res = 0;
        //相当于是01背包问题的变形体，每个位置其实是0-res/arr[i]的背包问题，全排列往下组合就完事
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        return res;
    }
}

```



![image-20211217091538083](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211217091538083.png)



**记忆化搜索**

```
public class Main {
    public static int[] coins;
    public  static int[][] dp;
    public static int process(int[] arr, int res) {
        coins = arr;
        dp=new int[arr.length+1][res+1];
        for (int[] i:dp){
            Arrays.fill(i,-1);
        }
        return process(0, res);
    }

    public static int process(int index, int curRes) {
        if (dp[index][curRes]!=-1)return dp[index][curRes];
        if (curRes == 0) {
            dp[index][curRes]=1;
            return 1;
        }
        if (index == coins.length) {
            dp[index][curRes]=0;
            return 0;
        }
        int res = 0;
        for (int num = 0; num * coins[index] <= curRes; ++num) {
            res += process(index + 1, curRes - num * coins[index]);
        }
        dp[index][curRes]=res;
        return res;
    }
}

```

**严格表结构**

```
public class Main {
    public static int process( int res,int[] coins) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                int ways = 0;
                // coins[coinIndex]硬币使用了thisCoinNum个
                for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curRes; thisCoinNum++) {
                    ways += dp[coinIndex + 1][curRes - thisCoinNum * coins[coinIndex]];
                }
                dp[coinIndex][curRes] = ways;
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```

**枚举的斜率优化**

![image-20211214220414721](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220414721.png)



```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) return 0;
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 0; i <= coins.length; i++) {
            dp[i][0] = 1;// 递归结束条件
        }
        // 根据递归形式顺序进行填表
        for (int coinIndex = coins.length - 1; coinIndex >= 0; coinIndex--) {
            for (int curRes = 0; curRes <= res; curRes++) {
                // 该位置结果就是：
                //          dp[coinIndex+1][curRes] ( coins[coinIndex]硬币使用了0个 )
                //                      +
                //          dp[coinIndex][curRes-coins[coinIndex]] (coins[coinIndex]硬币使用了1个 )
                dp[coinIndex][curRes] = dp[coinIndex + 1][curRes];
                if (curRes - coins[coinIndex] >= 0) {
                    dp[coinIndex][curRes] += dp[coinIndex][curRes - coins[coinIndex]];
                }
            }
        }
        // 返回目标值
        return dp[0][res];
    }

}

```



## 纸币组合最小个数问题

题目：**给定数组arr，里面的每个值表示一种面值，可随意使用，问组成aim所需要的最小张数，并返回**

**递归实现**





```
public class Main {
    public static int[] coins;

    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        Main.coins = coins;
        return process(0, res);
    }
	// 当前考虑的面值是arr[i]，还剩rest的钱需要找零
	// 如果返回-1说明自由使用arr[i..N-1]面值的情况下，无论如何也无法找零rest
	// 如果返回不是-1，代表自由使用arr[i..N-1]面值的情况下，找零rest需要的最少张数
    private static int process(int coinIndex, int curNum) {
    	// base case：
		// 已经没有面值能够考虑了
		// 如果此时剩余的钱为0，返回0张
		// 如果此时剩余的钱不是0，返回-1
        if (curNum == 0) {
            return 0;
        }
        if (coinIndex == coins.length) {
            return -1;
        }
		// 最少张数，初始时为-1，因为还没找到有效解
        int minNum = -1;
		// 依次尝试使用当前面值(arr[i])0张、1张、k张，但不能超过rest
        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {
			// 使用了k张arr[i]，剩下的钱为rest - k * arr[i]
			// 交给剩下的面值去搞定(arr[i+1..N-1])
            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);
            if (next != -1) {
                minNum = minNum == -1 ? next+thisCoinNum : Math.min(next + thisCoinNum, minNum);
            }
        }
        return minNum;
    }

}

```

**记忆化搜索**



```
public class Main {
    public static int[] coins;
    public static int[][] dp;

    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        Main.coins = coins;
        dp = new int[coins.length + 1][res + 1];
        for (int[] i : dp) {
            Arrays.fill(i, -2);
        }
        return process(0, res);
    }

    private static int process(int coinIndex, int curNum) {
        if (dp[coinIndex][curNum] != -2) return dp[coinIndex][curNum];
        if (curNum == 0) {
            dp[coinIndex][curNum] = 0;
            return 0;
        }
        if (coinIndex == coins.length) {
            dp[coinIndex][curNum] = -1;
            return -1;
        }
        int minNum = -1;
        for (int thisCoinNum = 0; thisCoinNum * coins[coinIndex] <= curNum; thisCoinNum++) {
            int next = process(coinIndex + 1, curNum - coins[coinIndex] * thisCoinNum);
            if (next != -1) {
                minNum = minNum == -1 ? next + thisCoinNum : Math.min(next + thisCoinNum, minNum);
            }
        }
        dp[coinIndex][curNum] = minNum;
        return minNum;
    }
}

```



**严格表结构**

```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 1; i <= res; i++) {
            dp[coins.length][i] = -1;
        }
        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {
            for (int curNum = 0; curNum <= res; curNum++) {
                dp[coinIndex][curNum] = -1;// 初始化值，若是0.表示0张就可以完成，所以不合理
                for (int coinNum = 0; coins[coinIndex] * coinNum <= curNum; coinNum++) {// 对于coins[coinIndex]的硬币进行每个个数的遍历
                    int restIndex = curNum - coins[coinIndex] * coinNum;
                    if (dp[coinIndex + 1][restIndex] != -1) {// 若该值 dp[coinIndex + 1][restIndex] 不能完成，就直接跳过
                        // 取出最小值，注意最小值前要进行判断dp[coinIndex][curNum]是否为-1，表示此前没有方法出现
                        dp[coinIndex][curNum] = dp[coinIndex][curNum] == -1 ? dp[coinIndex + 1][restIndex] + coinNum :
                                Math.min(dp[coinIndex + 1][restIndex] + coinNum, dp[coinIndex][curNum]);
                    }
                }
            }
        }
        return dp[0][res];
    }

}

```

**斜率优化**

```
public class Main {
    public static int process(int[] coins, int res) {
        if (coins == null || coins.length == 0 || res <= 0) {
            return 0;
        }
        int[][] dp = new int[coins.length + 1][res + 1];
        for (int i = 1; i <= res; i++) {
            dp[coins.length][i] = -1;
        }
        for (int coinIndex = coins.length - 1; coinIndex >= 0; --coinIndex) {
            for (int curNum = 0; curNum <= res; curNum++) {
                // 初始化值,继承第一个，因为定存在coins[coinIndex]一个不用的情况
                dp[coinIndex][curNum]=dp[coinIndex+1][curNum];
                if (coins[coinIndex]<=curNum){// 若存在可以用>=1个coins[coinIndex]进行计算
                    int rest=curNum-coins[coinIndex];
                    if (dp[coinIndex][rest]!=-1){// 该情况存在值
                        // 取出最小值注意判断当前dp[coinIndex][curNum]是否为-1
                        dp[coinIndex][curNum]=dp[coinIndex][curNum]==-1?dp[coinIndex][rest]+1:
                        Math.min(dp[coinIndex][rest]+1,dp[coinIndex][curNum]);
                    }
                }
            }
        }
        return dp[0][res];
    }
}

```

## 整数分裂

![image-20211214220703594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220703594.png)

**暴力递归**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (curRes == 0) return 1;
        if (pre > curRes) return 0;
        int ways = 0;
        // 从pre向curRes尝试
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        return ways;
    }

}

```

**记忆化搜索**

```
public class Main {
    public static int[][] dp;
    public static int process(int res) {
        if (res < 1) return 0;
        dp=new int[res+1][res+1];
        for (int[]i:dp){
            Arrays.fill(i,-1);
        }
        return process(1, res);
    }

    private static int process(int pre, int curRes) {// pre前驱值，保证后续分裂不小于pre
        if (dp[pre][curRes]!=-1)return dp[pre][curRes];
        if (curRes == 0) {
            dp[pre][curRes]=1;
            return 1;
        }
        if (pre > curRes) {
            dp[pre][curRes]=0;
            return 0;
        }
        int ways = 0;
        for (int rest = pre; rest <= curRes; rest++) {
            ways += process(rest, curRes - rest);
        }
        dp[pre][curRes]=ways;
        return ways;
    }

}

```

**动态规划**

```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        for (int pre = res; pre >= 1; pre--) {// 前驱
            for (int curRes = pre; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                for (int i = pre; i <= curRes; i++) {// 所有情况累加
                    dp[pre][curRes] += dp[i][curRes - i];
                }
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

**斜率优化**

- 枚举行为推导

![image-20211214220817010](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220817010.png)



```
public class Main {
    public static int process(int res) {
        if (res < 1) return 0;
        int[][] dp = new int[res + 1][res + 1];
        for (int i = 0; i <= res; i++) {// 递归结束条件
            dp[i][0] = 1;
        }
        dp[res][res]=1;// 根据下一层退出结果，所以要先对最后一层就行添值
        for (int pre = res-1; pre >= 1; pre--) {// 前驱
            for (int curRes = pre ; curRes <= res; curRes++) {// 保证剩余值不小于前驱
                dp[pre][curRes]=dp[pre+1][curRes]+dp[pre][curRes-pre];// 分析的关系
            }
        }
        // 返回前驱1，合成res的结果
        return dp[1][res];
    }
}

```

## bob活着

题目：**给定范围横向N，纵向M，从（i，j）开始走K步（只能上下左右走，且概率相同）没有超过给定范围那么就是活着，如果在过程中超过了范围则死了，返回活着的概率。**

**递归实现**

```
public class Main {

    public static int N, M;

    public static String process(int n, int m, int i, int j, int k) {
        N = n;
        M = m;
        int live = process(i, j, k);// 活着的情况
        int all = (int) Math.pow(4, k);// 一共存在的情况
        int gcb = gcb(all, live);// 求最大公约数
        return live / gcb + " / " + all / gcb;
    }

    private static int gcb(int m, int n) {
        if (n == 0) return m;
        return gcb(n, m % n);
    }

    // 计算活着的情况数
    public static int process(int i, int j, int K) {
        if (i < 1 || i > N || j < 1 || j > M) return 0;
        if (K == 0) return 1;
        return process(i + 1, j, K - 1) +
                process(i - 1, j, K - 1) +
                process(i, j + 1, K - 1) +
                process(i, j - 1, K - 1);
    }
}

```

**严格表结构**

```
class U {
    public static long gcd(long m, long n) {
        return n == 0 ? m : gcd(n, m % n);
    }

    public static String bob2(int N, int M, int i, int j, int K) {
        int[][][] dp = new int[N + 2][M + 2][K + 1];  //x坐标，y坐标，还有几步没走到达
        //如果剩下0步的时候能走到row,col位置就是存活，否则就是死去了。
        for (int row = 1; row <= N; row++) {//初始化数据
            for (int col = 1; col <= M; col++) {
                dp[row][col][0] = 1;
            }
        }
        for (int rest = 1; rest <= K; rest++) {
            for (int row = 1; row <= N; row++) {
                for (int col = 1; col <= M; col++) {
                	//递归依赖
                    dp[row][col][rest] = dp[row - 1][col][rest - 1];
                    dp[row][col][rest] += dp[row + 1][col][rest - 1];
                    dp[row][col][rest] += dp[row][col - 1][rest - 1];
                    dp[row][col][rest] += dp[row][col + 1][rest - 1];
                }
            }
        }
        long all = (long) Math.pow(4, K);
        long live = dp[i + 1][j + 1][K];
        long gcd = gcd(all, live);
        return (live / gcd) + "/" + (all / gcd);
    }
}

```

## 数字转化成字母（树形）

![image-20211214220923610](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214220923610.png)

**递归实现**

- 时间复杂度为指数级

```
public class Main {
	public static int process(String s, int i) {
		// 若一个不剩或这还剩一个，就返回1（保证剩的不为0），若此时不返回，说明还剩至少两个字符
		if (s.length() == i || (s.length() == i + 1 && s.charAt(i) != '0'))
			return 1;
		if (s.charAt(i) == '0')
			return 0;// 没有0开头匹配的元素
		int res = process(s, i + 1);// 一个字符的
		if (Integer.parseInt(s.substring(i, i + 2)) <= 26)
			res += process(s, i + 2);// 若满足匹配条件，进行两个字符的
		return res;// 累加的结果返回就行了
	}
}

```

**动态规划**

- 变参数个数为一个，表示当前值作为转化字母的开始数字，然后向后判断存在几种情况。

- 时间复杂度为O(N)

  ```
  public class Main {
  	public static int process(String string) {
  		if (string == null || string.length() == 0) {
  			return 0;
  		}
  		if (string.length() == 1) {
  			return string == "0" ? 0 : 1;
  		}
  		char[] arr = string.toCharArray();
  		int N = arr.length;
  		int[] res = new int[arr.length + 1];
  		res[N] = 1;
  		res[N - 1] = arr[N - 1] == '0' ? 0 : 1;
  		for (int i = N - 2; i >= 0; --i) {
  			if (arr[i] == '0') {
  				res[i] = 0;
  			} else {
  				if (arr[i] > '2' || (arr[i] == '2' && arr[i] > '6')) {
  					res[i] = res[i + 1];
  				} else {
  					res[i] = res[i + 1] + res[i + 2];
  				}
  			}
  		}
  		return res[0];
  	}
  }
  
  ```




## 数字转为字符串

![image-20211228093016742](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093016742.png)







## 字符串的全排列

![image-20211228093104568](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228093104568.png)

1. 我们通常都思路都是将所有字符依次放在最前面，例如ABC，第一位为A，B,C，然后判断第二位，那么我们如何在字符串中标记该字符已经被我们安排在前面了？

2. 若我们使用下标的方式，那么在每次选择都会产生一个下标，这样会很乱。

3. 于是我们可以通过将欲放在前面的字符就直接放在前面（将字符一次和后面的交换），用一个下标指引我们前面已经定了多少的元素。

4. 但是若我们交换后在后续调用时，数据顺序已经打乱，我们可能会造成重复情况，所以我们在每次运行后再将数据交换变成原来位置。

5. 但是当数据有重复字符时，会出现重复的全排列，这是我们就要判断交换的字符是否和之前交换的相同，若相同，就不用交换

   ```java
   class Main {
   	public static List<String> list = new ArrayList<>();
   
   	public static void process(String string) {
   		char[] chars = string.toCharArray();
   		process(chars, 0);
   	}
   
   	private static void process(char[] chars, int i) {
   		if (i == chars.length) {// 结果
   			list.add(new String(chars));
   			return;
   		}
   		boolean[] isVisited = new boolean[26];// 默认只有大写字母
   		for (int j = i; j < chars.length; j++) {// 一定是从i开始，不能是i+1，因为不交换也是一种情况
   			if (!isVisited[chars[j] - 'A']) {// 是否重复
   				isVisited[chars[j] - 'A'] = true;
   				swap(chars, i, j);// 交换
   				process(chars, i + 1);// 递归
   				swap(chars, i, j);// 恢复
   			}
   		}
   	}
   
   	private static void swap(char[] chars, int i, int j) {
   		char c = chars[i];
   		chars[i] = chars[j];
   		chars[j] = c;
   	}
   }
   ```

   https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/

   ```
   class Solution {
       List<String> res = new LinkedList<>();
       char[] c;
       public String[] permutation(String s) {
           c = s.toCharArray();
           dfs(0);
           return res.toArray(new String[res.size()]);
       }
       void dfs(int x) {
           if(x == c.length - 1) {
               res.add(String.valueOf(c));      // 添加排列方案
               return;
           }
           HashSet<Character> set = new HashSet<>();
           for(int i = x; i < c.length; i++) {
               if(set.contains(c[i])) continue; // 重复，因此剪枝
               set.add(c[i]);
               swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
               dfs(x + 1);                      // 开启固定第 x + 1 位字符
               swap(i, x);                      // 恢复交换
           }
       }
       void swap(int a, int b) {
           char tmp = c[a];
           c[a] = c[b];
           c[b] = tmp;
       }
   }
   ```

   

# 数组和字符串





## 组合硬币

一个硬币面值的组合，求出组合出给定金额最少的硬币数量。（这里的硬币应该不能重复选择）

版本一：

![image-20211214093158864](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211214093158864.png)





风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/236A5BAB3F15EC1CFE7543BC4AD930F5.jpg)

风 21:57:17
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/679EB9A15ABE065485A2F0C6E4BCEB5C.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/F053027ABF6D72F8DA642609570B7F18.jpg)

风 21:57:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/2652636A6206EFAC6C497FAD064A9C05.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8B8C6B0EC745DD699DDE0AB2F0560E34.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/1CD84ADF351B6BD4CD3B89469CDA68E7.jpg)

风 21:57:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D764CDCB4B0138B2632C491A539C891.jpg)

风 21:57:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DF7DFA8B5B3FCE158CE3A8FB03048F00.jpg)

风 21:57:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0793EB962C13F0F83AB76AEF75E228A6.jpg)





# 贪心算法

### 绳子覆盖问题

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/60e968bcb3e94c07b3d48db38b220c81.png)



#### 定右二分向左查找O(N*logN)

- 最主要还是二分的实现，**详见查找深度探索二分查找**

```java
public class Main {
	public static int process(int[] arr, int L) {
		if (arr == null || arr.length == 0 || L <= 0) {
			return 0;
		}
		int res = 1;
		for (int i = 0; i < arr.length; i++) {
			int index = bRNum(arr, i, arr[i] + L);
			res = Math.max(res, index - i + 1);
		}
		return res;
	}
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
}

```



#### 滑动窗口的解法

```java
两个值，从左往右，一个是开始位置l，一个是右边界r，保证arr[r]-arr[l]>=L，记录下r-l+1的值
```



### 前后缀差点最大值

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/cacd1046d8a0429a996570d3eccc6007.png)

一般思路：数据预处理建立两个从左右两端的最值数组，再遍历求解。
极限贪心思维：直接获取最大值和左右两端的差值
两个最大值数中定存在一个整体的最大值。
在满足将最大值放在一左端，无论怎么选择, 右一半的最大值一定大于等于最右端的元素。所以右侧最值最小只能是最右边的元素。
在满足将最大值放在一右端时同理，只需要这两种情况下取最值即可。

```java 
public class Test {
    public static int num(int[] arr) {
        if (arr == null || arr.length == 0) return 0;
        int max=arr[0];
        for (int i = 1;i < arr.length; i++){
            max = Math.max( max, arr[i]);
        }
        return Math.max(max-arr[0],max-arr[arr.length-1]);
    }
}
```



子数组累计和最大值

### magic操作

![image-20211227234337115](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234337115.png)



需要将平均值大的集合里面，拿出去介于两个平均值的值的数字到平均值小的集合里面。
尽量拿靠近平均值小的数字移动。也就是拿最小的

![image-20211227234858672](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227234858672.png)
![image-20211227235542296](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235542296.png)

![image-20211227235737178](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227235737178.png)


因为magic操作会将两个集合的平均值都变大，所以每个可以操作数之前的数可以不用在下一轮选数里面考虑了。

### 括号深度

![image-20211228000346795](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211228000346795.png)



遇到（ count++，遇到）count--，count最大的值就是深度。



### 超级洗衣机

https://leetcode-cn.com/problems/super-washing-machines/



![image-20211229085418463](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229085418463.png)



![90f2d42ebf6e4514aa4ea839f36ec099](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/90f2d42ebf6e4514aa4ea839f36ec099.png)



![image-20211229091620577](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229091620577.png)



因为每次只能放到相邻的位置，相当于分成两半以后，每次只能通过选定位置传送一件衣服到另一半。

```java
public class Test {
    public static int minPoint(int[] machines) {
        if (machines == null || machines.length == 0) return -1;
        int N = machines.length;
        int allSum = 0;
        for (int i : machines) {
            allSum += i;
        }
        if (allSum % N != 0) return -1;
        int average = allSum / N;
        int leftSum = 0;
        int res = 0;
        for (int i = 0; i < N; i++) {
            int leftRest = leftSum - average * i;
            int rightRest = (allSum - leftSum - machines[i]) - (N - 1 - i) * average;
            if (leftRest < 0 && rightRest < 0) {
                res = Math.max(res, Math.abs(leftRest) + Math.abs(rightRest));
            } else {
                res = Math.max(res, Math.max(Math.abs(leftRest), Math.abs(rightRest)));
            }
            leftSum += machines[i];
        }
        return res;
    }
}

```

### 找工作

![image-20220111230320313](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111230320313.png)



![image-20220111231245062](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111231245062.png)

```java
public class Test {
    public static int[] process(Job[] jobs, int[] ability) {
        Arrays.sort(jobs, (o1, o2) -> o1.hard != o2.hard ? (o1.hard - o2.hard) : (o2.money - o1.money));
        TreeMap<Integer, Integer> map = new TreeMap<>();
        map.put(jobs[0].hard, jobs[0].money);
        Job j = jobs[0];
        // 将同 hard 情况下 money 最多的进入map
        for (Job job : jobs) {
            if (job.hard != j.hard && job.money > j.money) {
                j = job;
                map.put(j.hard, j.money);
            }
        }
        int[] ans = new int[ability.length];
        for (int i = 0; i < ability.length; i++) {
            // 小于或等于ability[i]的最大键值
            Integer key = map.floorKey(ability[i]);
            ans[i] = key != null ? map.get(key) : 0;
        }
        return ans;
    }
    static class Job {
    	int hard;
    	int money;
	}
}

```



**java treemap_Java TreeMap floorKey（）方法与示例**

**floorKey()方法**用于返回小于或等于给定键元素(key_ele)的最大键元素(如果存在)，否则，当不存在该键元素时返回null。**floorKey()方法**是一种非静态方法，只能通过类对象访问，如果尝试使用类名称访问该方法，则会收到错误消息。



### 子数组累计和最大值



![image-20220117094756580](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117094756580.png)



![image-20220117213014775](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117213014775.png)

```
public class Test {
    public static int maxLenNum(int[] arr){
        int max=Integer.MIN_VALUE;
        int cur=0;
        for (int i : arr) {
            cur+=i;
            max=Math.max(max,cur);
            cur=Math.max(cur, 0);
        }
        return max;
    }
}

```

### 子矩阵累计和最大值(压缩数组)

![image-20220117214128825](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214128825.png)



![image-20220117214111768](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117214111768.png)



- 子矩阵往往考虑是否可以转换成字数组的问题，就是将多行转化成一行或者多列转化成多列
- 转化之后思考一维情况下的解决思路，看看是否能应用到矩阵中。
  求出

0-0行 0-1行 0-2行。。0-n行，1-1行1-2行。。。1-n行 ，2-2行。。。。n-n行，将这些区间行对应列的值加在一起成为一行，然后用上面的方法求出最大值，最终的最大值就是子矩阵的最大值

这是**行压缩的方法**

```java
public class Test {
    public static int maxAreaNum(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        int max = Integer.MIN_VALUE;
        int cur;
        int[] sumArr;
        for (int i = 0; i != arr.length; i++) {
            sumArr = new int[arr[0].length];
            for (int j = i; j != arr.length; j++) {
                cur = 0;
                for (int k = 0; k != sumArr.length; k++) {
                    sumArr[k] += arr[j][k];
                    cur += sumArr[k];
                    max = Math.max(max, cur);
                    cur = Math.max(cur, 0);
                }
            }
        }
        return max;
    }
}

```

### 安路灯

![image-20220117233125057](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220117233125057.png)





- 一个简单的贪心思想，将路灯尽量安装在需要安装的第二个位置。

- ```java
  public class Test {
      public static int minNum(String s) {
          char[] arr = s.toCharArray();
          int minNum = 0;
          int index = 0;
          while (index < arr.length) {
              if (arr[index] == 'X') {
               //不点灯
                  index++;
              } else {
                   //这个位置需要点亮，前面都是亮的，因此可以放在这个位置，也可以放在这个位置的下一个。
                  minNum++;
                  if (index + 1 == arr.length) {
                      break;.
                    //下一个是x，就直接去下下一个看
                  } else if (arr[index + 1] == 'X') {
                      index += 2;
                  } else {
                      //下一个不是x，相当于是...或者..*，将灯放在第二个点，然后直接去下下下个位置，这个位置需要点亮，这个位置以前的都是亮的。
                      index += 3;
                  }
              }
          }
          return minNum;
      }
  }
  
  ```

- 









# 打表法

- 出现和倍数相关的问题时，可以考虑通过一般方法解题后的结果是否存在某种特殊的规律，通过直观的答案直接进行代码的书写，不需要关注本质含义。

## 整体装袋



![image-20211219220615833](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219220615833.png)

**一般思路**

可以发现，超过6和8的最小公约数以后，构成的差值一直是3/5/1循环，超过24以后，也就是8的倍数，每个rest都可以映射到减去24的某个rest。

如果超过rest超过24以后，就没必要尝试试了，因为24是6和8的最小公倍数

107个苹果

107/8=13

8的包数 	rest	mod6余数  

13				3		3

12				11		5

11				19		1

10				27		3

9					35		5

8					43		1	

```
public class Main {
	public static int num(int apple) {
		if (apple % 8 == 0)
			return apple / 8;
		int n8 = apple / 8;
		int m = apple % 8;
		while (m < 24 && n8 >= 0) {
			if (m % 6 == 0)
				return n8 + m / 6;
			--n8;
			m += 8;
		}
		return -1;
	}
}

```





**打表代码**
![image-20211219232123273](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232123273.png)

- 18前无规律，18后单为-1，双为一个值，每增加8个就增加1

```
public class Main {
	public static int daBiao(int apple) {
		if (apple < 18)
			return apple == 0 ? 0
					: (apple == 6 || apple == 8) ? 1 
						: (apple == 12 || apple == 14 || apple == 16) ? 2 
							: -1;
		if (apple % 2 == 1)
			return -1;
		return (apple - 18) / 8 + 3;
	}
}

```

2*8=16

3*6=18

差值是2，当大于18以后，多的2可以通过这个转换转换为8或者6的袋子，因此奇数肯定不可能凑成，大于18的偶数可以凑成。

## 幂次方吃草

![sdgdfgfdgdfgdrg](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA44CMIDI1JyBoIOOAjQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

不是看谁吃得多，而是看谁最后吃不了剩下的草算输



```
public class Main {
	public static String winner(int N) {
		if (N <= 4)
			return N == 0 || N == 2 ? "羊羊" : "牛牛";
		int eatTest = 1;
		while (eatTest <= N) {
			if (winner(N - eatTest).equals("羊羊"))
				return "牛牛";
			eatTest *= 4;
		}
		return "羊羊";
	}
}

```

![image-20211219232823835](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232823835.png)

![image-20211219232220642](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211219232220642.png)



```
public static String win(int N){
    return (N)%5==0||(N)%5==2?"羊羊":"牛牛";
}

```





# 枚举

### 矩阵最大正方形

![image-20211221215153594](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211221215153594.png)

- 还是若我们直接对于单个起始位置寻找，对于每个其实位置进行判断的话时间复杂度就会比较高
- 由此我们要单向记录连续1的个数

```java
public class Test {
    public static void main(String[] args) {
        System.out.println(maxLen(new int[][]{
        		{0, 1, 1, 1, 1, 1},
                {0, 1, 0, 0, 1, 1},
                {0, 1, 0, 0, 1, 0},
                {1, 1, 1, 1, 1, 1},
                {0, 1, 0, 1, 1, 1}}));
    }

    public static void show(int[][] a) {
        for (int[] aa : a) {
            System.out.println(Arrays.toString(aa));
        }
        System.out.println();
    }

    public static int maxLen(int[][] arr) {
        if (arr == null || arr.length == 0 || arr[0].length == 0) return 0;
        show(arr);
        
        //*******************生成向横向的累计连续数值******************
        int[][] rightArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = arr[0].length - 1; j >= 0; j--) {
                rightArr[i][j] = arr[i][j] == 0 ? 0 : j == arr[0].length - 1 ? 1 : rightArr[i][j + 1] + 1;
            }
        }
        show(rightArr);

        //*******************生成向纵向的累计连续数值******************
        int[][] downArr = new int[arr.length][arr[0].length];
        for (int i = 0; i < arr[0].length; i++) {
            for (int j = arr.length - 1; j >= 0; j--) {
                downArr[j][i] = arr[j][i] == 0 ? 0 : j == arr.length - 1 ? 1 : downArr[j + 1][i] + 1;
            }
        }
        show(downArr);

        //*************************从小到大看看多大的正方形存在**************************8
        for (int size = Math.min(arr.length, arr[0].length); size != 0; size--) {
            if (hasSizeOfBorder(size, rightArr, downArr)) {
                return size;
            }
        }
        return 0;
    }

    private static boolean hasSizeOfBorder(int size, int[][] rightArr, int[][] downArr) {
        for (int i = 0; i < rightArr.length; i++) {
            for (int j = 0; j < rightArr[0].length; j++) {
                if (rightArr[i][j] >= size && downArr[i][j + size - 1] >= size &&
                        downArr[i][j] >= size && rightArr[i + size - 1][j] >= size)
                    return true;
            }
        }
        return false;
    }
}

```









### 括号字符

![image-20211227233419037](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233419037.png)

![image-20211227233649531](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233649531.png)

```

```



### 差值为k的去重数字对

![image-20211227233908870](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211227233908870.png)



使用hashset记录每个元素，然后遍历arr，找个一个数，加上k看这个值在不在hashset里面，在的话就加1。











# 业务题



# 其他

## 1 比较器

  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }

你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2



## 求解最小公倍数





## 二分法





## 快速排序





## 利用二分法寻找最某个值或者最大于某个值的最小值



```
	// 查找arr[L...]元素中小于等于value中最大的元素索引
	private static int bRNum(int[] arr, int L, int value) {
		int R = arr.length - 1;
		while (L < R) {
			// 注意med取值方法，若没有+1可能死循环
			int med = ((R - L + 1) >> 1) + L;
			if (arr[med] == value) {
				return med;
			} else if (arr[med] < value) {
				L = med;// 注意这里不+1，防止跳过
			} else {
				R = med - 1;
			}
		}
		return L;
	}
```



## 判定数字某位二进制的值是不是1



右移一位再与1&就能得到这个数字的二进制上面的位置是不是1.

![image-20220111092003540](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220111092003540.png)



## 自定义大顶堆&小顶堆





大顶堆

```
  PriorityQueue<int[]> pq = new PriorityQueue<int[]>(new Comparator<int[]>() {
            public int compare(int[] pair1, int[] pair2) {
                return pair1[0] != pair2[0] ? pair2[0] - pair1[0] : pair2[1] - pair1[1];
            }
        });


```

插入元素  `  pq.offer(new int[]{nums[i], i});`

查看堆顶元素 `pq.peek()[1] <= i - k`

弹出堆顶元素 `pq.poll()`



## 双端队列

定义：`Deque<Integer> deque = new LinkedList<Integer>();`

当队列使用：
				尾部弹出 ` deque.pollLast();`

​		查看尾部元素`deque.peekLast()`	

​		查看头部元素 `deque.peekFirst()`

​		尾部插入 ` deque.offerLast(i);`



# 整体思想

### [ 螺旋矩阵](https://leetcode-cn.com/problems/spiral-matrix/)



### 旋转字符串

![image-20220107001832841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20220107001832841.png)

- 一般思路：尝试所有的情况，看是否存在相同的
- 优化思路：见代码

```
public class Test {
    public static boolean isRoa(String s,String r){
        if (s.length()!=r.length())return false;
        String ss= s + s;
        return ss.contains(r);
    }
}

```





### zigzag方式打印矩阵

![image-20211229093821968](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211229093821968.png)

- 只关注单趟循环，分离宏观控制和循环过程

- ```java
  public class Main {
  	public static void print(int[][] arr) {
  		int N = arr.length - 1;
  		int M = arr[0].length - 1;
  		int firstRow = 0, firstLine = 0, secondRow = 0, secondLine = 0;
  		boolean flag = false; // 控制打印方向
  		while (secondLine != M + 1) {
  			print(arr, firstRow, firstLine, secondRow, secondLine, flag);
  			if (firstLine != M)
  				firstLine++;
  			else
  				firstRow++;
  			if (secondRow != N)
  				secondRow++;
  			else
  				secondLine++;
  			flag = !flag;
  		}
  	}
  
  	private static void print(int[][] arr, int firstRow, int firstLine, int secondRow, int secondLine, boolean flag) {
  		if (flag) {
  			while (firstLine >= secondLine) {
  				System.out.print(arr[firstRow++][firstLine--] + " ");
  			}
  		} else {
  			while (secondLine <= firstLine) {
  				System.out.print(arr[secondRow--][secondLine++] + " ");
  			}
  		}
  	}
  }
  
  ```

  ### 

  ### 



### 90度旋转

https://leetcode-cn.com/problems/rotate-matrix-lcci/submissions/



![image-20211230000012145](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230000012145.png)

1.先水平翻转，再根据主对角线翻转得到：

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 水平翻转
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < n; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - i - 1][j];
                matrix[n - i - 1][j] = temp;
            }
        }
        // 主对角线翻转
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < i; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }
    }
}

。
```

2.原地旋转

一组四个对角转一下，借助一个临时变量就够了



```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        for (int i = 0; i < n / 2; ++i) {
            for (int j = 0; j < (n + 1) / 2; ++j) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
}

```

https://pic.leetcode-cn.com/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif

![194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/194630bf90343475a07278a0840d93ad891206acd50be1b81e75eb357d1e2c07-rotate.gif)

3.暴力方法

`对于矩阵中第 i 行的第 j 个元素，在旋转后，它出现在倒数第 i 列的第 j 个位置。`

![image-20211230001116999](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211230001116999.png)

```
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] matrix_new = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
    }
}

```







# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623

