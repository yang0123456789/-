# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位

 ![image](https://user-images.githubusercontent.com/43565774/144262216-121ffafc-12ef-4094-a838-e9ef2f034ba4.png)

![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整



## 一致性哈希









# 并查集

融合

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8CF8D66817018FBB3E968AB8FACBB42B.jpg)

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C15EF7866196C79D418DCECBC4D33358.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/69490C61145109D46C98A19C56B204BD.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0DAF1C2D9659D76ED8EE873A64431511.jpg)

风 23:46:16
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/AC53BA985C9A6E9E5B79F90A72375321.jpg)

## 岛屿数量



多cpu情况



![image-20211202232412841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202232412841.png)





# kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)





## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

## 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





# 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算















# 树形dp





风 9:11:52
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8137EC9804C17A0400E254509CD5AD74.jpg)

风 9:11:53
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/759C819ADFCB16E2CA56D2AEED307D6A.jpg)

## 树节点最远距离

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3D9B73ED255C5D81E3CC844F11CB856B.jpg)

风 9:11:55
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C361F70153593EABDE8588C7F7D23CF3.jpg)

风 9:11:56
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/325332F68C65A9A217E9F07DE2527361.jpg)



![image-20211209092409856](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211209092409856.png)



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7D95FBD3D6DD4FF2CBDAA5A9011CCC7E.jpg)



***递归套路：***

- 根据子树最大深度计算出经过当前节点的最长距离
- 向上传递子树和经过当前节点最长距离 的最大值
- 最长距离需要子树深度
- 所以递归数据包括最大距离和最大深度





```java

public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxLenPath(header);
		return data.maxLen;
	}

	private static TransformData maxLenPath(Node header) {
		if (header == null) {
			return new TransformData(0, 0);
		}
		TransformData leftData = maxLenPath(header.leftNode);
		TransformData rightData = maxLenPath(header.rightNode);
		return new TransformData(
				Math.max(leftData.maxHeight + rightData.maxHeight + 1, Math.max(leftData.maxLen, rightData.maxLen)),
				Math.max(leftData.maxHeight, rightData.maxHeight) + 1);

	}

	public static class TransformData {
		int maxLen;
		int maxHeight;
		public TransformData(int maxLen, int maxHeight) {
			this.maxLen = maxLen;
			this.maxHeight = maxHeight;
		}
	}

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}



```

## 员工的快乐值



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/513BBF7364AF9B669F89CB5E33521B1C.jpg)


![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/36AEC04043D12E4DD4B9DD9B070B6BE8.jpg)

***递归套路：***

- 最大值和每个节点是否去有关，就是取 **当前节点不去（0）+子节点去或不去的最大值** 和 **当前节点去（happy）+子节点不去的最大值**
- 每个节点的去和不去都会直接影响父类节点，间接影响祖宗节点。
- 只要递归传递该节点去和不去的最大值信息即可。

```java
public class Main {
	public static int process(Node header) {
		if (header == null) {
			return 0;
		}
		TransformData data = maxHappy(header);
		return Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
	}

	private static TransformData maxHappy(Node header) {
		if (header.nexts == null) {
			return new TransformData(0, header.happyNum);
		}
		int dontWent = 0;
		int went = 0;
		for (Node nextNode : header.nexts) {
			TransformData data = maxHappy(nextNode);
			went += data.thisNodeDontWentSumHappy;
			dontWent += Math.max(data.thisNodeDontWentSumHappy, data.thisNodeWentSumHappy);
		}
		return new TransformData(dontWent, went);
	}

	public static class TransformData {
		int thisNodeDontWentSumHappy;
		int thisNodeWentSumHappy;
		public TransformData(int thisNodeDontWentSumHappy, int thisNodeWentSumHappy) {
			this.thisNodeDontWentSumHappy = thisNodeDontWentSumHappy;
			this.thisNodeWentSumHappy = thisNodeWentSumHappy;
		}

	}

	public static class Node {
		int happyNum;
		Node[] nexts;
	}
}

```



![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/052E9D9096F34CEC4809DB9CA1D60FD0.jpg)

风 9:12:03
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/116215E06216BC9B2D6E0E6BE249E6C7.jpg)



## 树结构转成链表（套路题）

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA44CMIDI1JyBoIOOAjQ==,size_20,color_FFFFFF,t_70,g_se,x_16.png)

- 将左右子树构建好的结果通过本节点链接，就是递归对数据就是链接起始和结束节点。



```java
public class Main {
    public static Data process(Node x) {
        if (x == null) {
            return new Data(null, null);
        }
        // 将x作为中间节点，x.leftNode为创建x的前面的链表，x.rightNode为创建后面的链表。
        Data leftData = process(x.leftNode);
        Data rightData = process(x.rightNode);
        // 前后创建的链表和中间节点x链接，因为是双向链表，所以要有四句链接
        if (leftData.end != null) {
            leftData.end.rightNode = x;
        }
        x.leftNode = leftData.end;
        if (rightData.start != null) {
            rightData.start.leftNode = x;
        }
        x.rightNode = rightData.start;
        // 创建好后重新分装返回起始节点和尾节点
        return new Data(leftData.start != null ? leftData.start : x,
                rightData.end != null ? rightData.end : x);
    }

    static class Data {
        Node start;
        Node end;
        public Data(Node start, Node end) {
            this.start = start;
            this.end = end;
        }
    }

	public static class Node {
		int value;
		Node leftNode;
		Node rightNode;
	}
}

```



## 树的个数

![在这里插入图片描述](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/adea57019f814883a17071344d4f5f96.png)

```java
public class Main {
	public static int process(int N) {
		if (N == 0 || N == 1) {
			return 1;
		}
		int res = 0;
		for (int i = 0; i < N; i++) {
			res += process(i) * process(N - i - 1);
		}
		return res;
	}
}

```

## mirror数

时间复杂度o(n)空间复杂度o1的遍历二叉树的方式，有点像线索二叉树

风 9:00:18
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA6222916FD12483540696AE21E31DE4.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/4C27099AE86BCE98E709AC5F9CF2538E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8504DEFFA83DB68111285AED30E18B0E.jpg)

风 9:00:19
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/EED6FE103117301421F4743445C3373B.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C75EE0D5505A484727EA6512F8E86D92.jpg)

风 9:00:20
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/72D1C3B3F2016909613C37B70FC62739.jpg)

风 9:00:21
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0965229D51ED08FB47C5E19C2C823FAA.jpg)

# 大数据问题

有限的空间找到几十亿条数据中没有出现的数

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/3FDC6603989FCA68399CFD474D160126.jpg)

风 9:00:23
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9E73E41834A98DDD73670482DB8BD9DB.jpg)







# 其他

## 1 比较器

  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }

你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2




# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623

