# 哈希

## o(1)插入和删除
![image](https://user-images.githubusercontent.com/43565774/144258696-34983f48-2269-445f-a78c-41604eef3331.png)
两个hash表，一个记录str-index，一个记录index-str，然后randm获取一个0-index的整数，就是等概率获取。
![image](https://user-images.githubusercontent.com/43565774/144259288-c406b5d4-43b0-4a68-978e-0dbc9eee9db5.png)
如果要删除一个记录，删除完了以后，将最后的index填补到删除的位置，index-1，这样相当于index还是连续的。
![image](https://user-images.githubusercontent.com/43565774/144259930-8ae784e1-fcf2-4a38-acb0-3a0dd11a153e.png)
![image](https://user-images.githubusercontent.com/43565774/144260064-23435878-dd96-45fd-bfde-4e8a4986c920.png)

## 布隆过滤器

![image](https://user-images.githubusercontent.com/43565774/144261607-facb5fa1-e3b8-4524-9c29-894de54e23b7.png)
 178/32表示在哪个数上面找178这个bit的状态
 178%32表示在这个32位的数上的哪一个bit位

 ![image](https://user-images.githubusercontent.com/43565774/144262216-121ffafc-12ef-4094-a838-e9ef2f034ba4.png)

![image-20211201232934628](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211201232934628.png)

这里还得再好好看一看。失误率什么的。

样本量和失误率

![image-20211202000919915](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202000919915.png)

只需要确认占用空间m和多少个哈希函数，就可以设计出布隆过滤器，计算出失误率

m表示空间，k表示有多少个哈希函数，向上取整



## 一致性哈希









# 并查集

融合

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/8CF8D66817018FBB3E968AB8FACBB42B.jpg)

风 23:46:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C15EF7866196C79D418DCECBC4D33358.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/69490C61145109D46C98A19C56B204BD.jpg)

风 23:46:15
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/0DAF1C2D9659D76ED8EE873A64431511.jpg)

风 23:46:16
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/AC53BA985C9A6E9E5B79F90A72375321.jpg)

## 岛屿数量



多cpu情况



![image-20211202232412841](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202232412841.png)





## kmp算法

![image-20211202233541685](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211202233541685.png)

前缀和后缀相等以后的最长长度，取到整体没意义

![image-20211203000035126](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000035126.png)

aaaaa这个就是4，不能取5.取5没意义

**先求短的字符串的最长相等的前缀和后缀的next数组**

![image-20211203000953567](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203000953567.png)

这个定位的过程第一个是-1,1位置指的是第一个位置以前的字符串，不包括当前位置，因此第一个位置以前的位置为空，人为固定为-1.

第二个位置以前只有一个a，因此为0，不能取全部。

第三个位置以前为aa，不能取全部，因此为1.

第四个位置为aab，浅醉和后缀为1不等于，为2不等于。为3不能取，因此为0.



**根据next数组进行加速**

![image-20211203001407361](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203001407361.png)

直接从箭头的地方开始比较

![image-20211203002209397](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203002209397.png)

![image-20211203003039686](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003039686.png)

### 代码

![image-20211203003455767](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211203003455767.png)



## 最长回文子串

1 ， 后面的寻找回文串的中心位置i不在前面以c为中心的回文串的有边界r的范围内，直接按照老办法找回文

2. 
   2.1i在这个范围内，可以根据以c对称的i‘来计算

![image-20211207092116654](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207092116654.png)

2.2 i的回文串右边界刚好与c的右边界相同，i-r中不需要考虑。考虑从右边界开始扩容

**代码**

伪代码：

风 22:42:08
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/76FB30A4371644B84C1CAC1AC49D7D41.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9D3833843936959963D9C0A0DF04F880.jpg)

风 22:42:09
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/BA10CBA50ABE03AC87FC5C9FB8D054AC.jpg)



风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/739DF3D4D980A0B10DDDFD0458D0D647.jpg)

风 22:42:10
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C78E0F3D08E2A13E4B9A6E867D9DDD22.jpg)

风 22:42:11
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/9C839B97C64FF985146AE6C14350D662.jpg)

## 滑动窗口

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/130FCF4F6383AFED89A865FE60076E00.jpg)

风 22:42:12
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/FB3CFE33EE3A1BDA5E5E4D0C35DE02B4.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/C6C7CA853DBBAF8CE28AB1B936E591A1.jpg)

风 22:42:13
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/DC6657DFD573D6030887509823B7B85B.jpg)

风 22:42:14
![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/CA2024DBF45DA7A37BE1181A47052BA2.jpg)





## 单调栈

![img](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/7A5126665B31684F6CDF9BBA1DC8CB14-16388883522091.jpg)

![image-20211207225427943](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207225427943.png)

有相同值的情况搞一个

![image-20211207233622331](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207233622331.png)



## 子数组与最小值的最大积

遍历每个数，使每个数都是子数组里面的最小值，然后算乘积，就是单调栈

![image-20211207234826075](%E5%93%88%E5%B8%8C%E5%87%BD%E6%95%B0%E3%80%81%E5%93%88%E5%B8%8C%E8%A1%A8.assets/image-20211207234826075.png)

前缀和求区间和，避免重复计算

















# 其他

## 1 比较器

  public static class MyComparator implements Comparator<Integer> {
    @Override
    public int compare(Integer o1, Integer o2) {
      return o1 - o2;
    }
  }

  public static void main(String[] args) {
    Integer[] arr = new Integer[]{1, Integer.MAX_VALUE, -5, 0, Integer.MIN_VALUE, -1, 5};
    Arrays.sort(arr, new MyComparator());
    System.out.println(Arrays.toString(arr));
  }

用大数类BigInteger， 或者说让两个比较的数先除100再比较
public static class MyComparator implements Comparator<Integer> {
        @Override
        public int compare(Integer o1, Integer o2) {
//            BigInteger a = new BigInteger(String.valueOf(o1));
//            BigInteger b = new BigInteger(String.valueOf(o2));
//
//            return a.compareTo(b);
            return o1/100-o2/100;
        }
    }

你可以直接用Integer.compare(a,b)，每一个基础类型的包装器类型都有一样的方法

## 异或交换

关于异或交换(^)，其实不用懂原理，只要记住一个规律。
如：a=b^c;
则a、b、c三个数中任意两个异或之后都等于剩下的那个数。为了便于描述，我们可以定义这种情况下a为b和c的异或数；同样的b也是a和c的异或数；c也是a和b的异或数。

比较难理解的是他用了两个变量就完成了交换操作。
可以先这样理解:
a=1;
b=2;
c=a^b;  // c为1和2的异或数3
a=a^c; // 1^3等于2，a变为2
b=b^c; // 2^3等于1，b变为1
完成互换。

简化后：
a=1;
b=2;
a=a^b; // a为1和2的异或数3
b=a^b; // 3^2等于1，b变为1
a=a^b; // 3^1等于2，a变为2




# 笔记整理

https://blog.csdn.net/weixin_54884881/article/details/121140623

